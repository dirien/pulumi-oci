# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AnalyticsAnalyticsInstanceCapacityArgs',
    'AnalyticsAnalyticsInstanceNetworkEndpointDetailsArgs',
    'AnalyticsAnalyticsInstanceNetworkEndpointDetailsWhitelistedVcnArgs',
    'AnalyticsAnalyticsInstancePrivateAccessChannelPrivateSourceDnsZoneArgs',
    'ApigatewayApiValidationResultArgs',
    'ApigatewayDeploymentSpecificationArgs',
    'ApigatewayDeploymentSpecificationLoggingPoliciesArgs',
    'ApigatewayDeploymentSpecificationLoggingPoliciesAccessLogArgs',
    'ApigatewayDeploymentSpecificationLoggingPoliciesExecutionLogArgs',
    'ApigatewayDeploymentSpecificationRequestPoliciesArgs',
    'ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationArgs',
    'ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs',
    'ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs',
    'ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs',
    'ApigatewayDeploymentSpecificationRequestPoliciesCorsArgs',
    'ApigatewayDeploymentSpecificationRequestPoliciesRateLimitingArgs',
    'ApigatewayDeploymentSpecificationRouteArgs',
    'ApigatewayDeploymentSpecificationRouteBackendArgs',
    'ApigatewayDeploymentSpecificationRouteBackendHeaderArgs',
    'ApigatewayDeploymentSpecificationRouteLoggingPoliciesArgs',
    'ApigatewayDeploymentSpecificationRouteLoggingPoliciesAccessLogArgs',
    'ApigatewayDeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesAuthorizationArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesCorsArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs',
    'ApigatewayDeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs',
    'ApigatewayDeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs',
    'ApigatewayGatewayIpAddressArgs',
    'ApigatewayGatewayResponseCacheDetailsArgs',
    'ApigatewayGatewayResponseCacheDetailsServerArgs',
    'ApmSyntheticsMonitorConfigurationArgs',
    'ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsArgs',
    'ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsAuthHeaderArgs',
    'ApmSyntheticsMonitorConfigurationRequestHeaderArgs',
    'ApmSyntheticsMonitorConfigurationRequestQueryParamArgs',
    'ApmSyntheticsMonitorConfigurationVerifyTextArgs',
    'ApmSyntheticsMonitorScriptParameterArgs',
    'ApmSyntheticsMonitorScriptParameterMonitorScriptParameterArgs',
    'ApmSyntheticsScriptMonitorStatusCountMapArgs',
    'ApmSyntheticsScriptParameterArgs',
    'ApmSyntheticsScriptParameterScriptParameterArgs',
    'ArtifactsContainerRepositoryReadmeArgs',
    'AutoscalingAutoScalingConfigurationAutoScalingResourcesArgs',
    'AutoscalingAutoScalingConfigurationPolicyArgs',
    'AutoscalingAutoScalingConfigurationPolicyCapacityArgs',
    'AutoscalingAutoScalingConfigurationPolicyExecutionScheduleArgs',
    'AutoscalingAutoScalingConfigurationPolicyResourceActionArgs',
    'AutoscalingAutoScalingConfigurationPolicyRuleArgs',
    'AutoscalingAutoScalingConfigurationPolicyRuleActionArgs',
    'AutoscalingAutoScalingConfigurationPolicyRuleMetricArgs',
    'AutoscalingAutoScalingConfigurationPolicyRuleMetricThresholdArgs',
    'BastionSessionKeyDetailsArgs',
    'BastionSessionTargetResourceDetailsArgs',
    'BdsAutoScalingConfigurationPolicyArgs',
    'BdsAutoScalingConfigurationPolicyRuleArgs',
    'BdsAutoScalingConfigurationPolicyRuleMetricArgs',
    'BdsAutoScalingConfigurationPolicyRuleMetricThresholdArgs',
    'BdsBdsInstanceCloudSqlDetailsArgs',
    'BdsBdsInstanceCloudSqlDetailsKerberosDetailArgs',
    'BdsBdsInstanceClusterDetailsArgs',
    'BdsBdsInstanceMasterNodeArgs',
    'BdsBdsInstanceNetworkConfigArgs',
    'BdsBdsInstanceNodeArgs',
    'BdsBdsInstanceNodeAttachedBlockVolumeArgs',
    'BdsBdsInstanceUtilNodeArgs',
    'BdsBdsInstanceWorkerNodeArgs',
    'BlockchainBlockchainPlatformComponentDetailsArgs',
    'BlockchainBlockchainPlatformComponentDetailsOsnArgs',
    'BlockchainBlockchainPlatformComponentDetailsOsnOcpuAllocationParamArgs',
    'BlockchainBlockchainPlatformComponentDetailsPeerArgs',
    'BlockchainBlockchainPlatformComponentDetailsPeerOcpuAllocationParamArgs',
    'BlockchainBlockchainPlatformHostOcpuUtilizationInfoArgs',
    'BlockchainBlockchainPlatformReplicasArgs',
    'BlockchainOsnOcpuAllocationParamArgs',
    'BlockchainPeerOcpuAllocationParamArgs',
    'CloudGuardDataMaskRuleTargetSelectedArgs',
    'CloudGuardDetectorRecipeDetectorRuleArgs',
    'CloudGuardDetectorRecipeDetectorRuleCandidateResponderRuleArgs',
    'CloudGuardDetectorRecipeDetectorRuleDetailsArgs',
    'CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationArgs',
    'CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationValueArgs',
    'CloudGuardDetectorRecipeEffectiveDetectorRuleArgs',
    'CloudGuardDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs',
    'CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsArgs',
    'CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs',
    'CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs',
    'CloudGuardResponderRecipeEffectiveResponderRuleArgs',
    'CloudGuardResponderRecipeEffectiveResponderRuleDetailsArgs',
    'CloudGuardResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs',
    'CloudGuardResponderRecipeResponderRuleArgs',
    'CloudGuardResponderRecipeResponderRuleDetailsArgs',
    'CloudGuardResponderRecipeResponderRuleDetailsConfigurationArgs',
    'CloudGuardTargetTargetDetectorRecipeArgs',
    'CloudGuardTargetTargetDetectorRecipeDetectorRuleArgs',
    'CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsArgs',
    'CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs',
    'CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs',
    'CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs',
    'CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleArgs',
    'CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsArgs',
    'CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConditionGroupArgs',
    'CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs',
    'CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs',
    'CloudGuardTargetTargetResponderRecipeArgs',
    'CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleArgs',
    'CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsArgs',
    'CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs',
    'CloudGuardTargetTargetResponderRecipeResponderRuleArgs',
    'CloudGuardTargetTargetResponderRecipeResponderRuleDetailsArgs',
    'CloudGuardTargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs',
    'ContainerengineClusterEndpointConfigArgs',
    'ContainerengineClusterEndpointsArgs',
    'ContainerengineClusterImagePolicyConfigArgs',
    'ContainerengineClusterImagePolicyConfigKeyDetailArgs',
    'ContainerengineClusterMetadataArgs',
    'ContainerengineClusterOptionsArgs',
    'ContainerengineClusterOptionsAddOnsArgs',
    'ContainerengineClusterOptionsAdmissionControllerOptionsArgs',
    'ContainerengineClusterOptionsKubernetesNetworkConfigArgs',
    'ContainerengineNodePoolInitialNodeLabelArgs',
    'ContainerengineNodePoolNodeArgs',
    'ContainerengineNodePoolNodeConfigDetailsArgs',
    'ContainerengineNodePoolNodeConfigDetailsPlacementConfigArgs',
    'ContainerengineNodePoolNodeErrorArgs',
    'ContainerengineNodePoolNodeShapeConfigArgs',
    'ContainerengineNodePoolNodeSourceArgs',
    'ContainerengineNodePoolNodeSourceDetailsArgs',
    'CoreBootVolumeBackupSourceDetailsArgs',
    'CoreBootVolumeBootVolumeReplicaArgs',
    'CoreBootVolumeSourceDetailsArgs',
    'CoreClusterNetworkInstancePoolArgs',
    'CoreClusterNetworkInstancePoolLoadBalancerArgs',
    'CoreClusterNetworkInstancePoolPlacementConfigurationArgs',
    'CoreClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs',
    'CoreClusterNetworkPlacementConfigurationArgs',
    'CoreClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs',
    'CoreComputeCapacityReservationInstanceReservationConfigArgs',
    'CoreComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs',
    'CoreDefaultDhcpOptionsOptionArgs',
    'CoreDefaultRouteTableRouteRuleArgs',
    'CoreDefaultSecurityListEgressSecurityRuleArgs',
    'CoreDefaultSecurityListEgressSecurityRuleIcmpOptionsArgs',
    'CoreDefaultSecurityListEgressSecurityRuleTcpOptionsArgs',
    'CoreDefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'CoreDefaultSecurityListEgressSecurityRuleUdpOptionsArgs',
    'CoreDefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'CoreDefaultSecurityListIngressSecurityRuleArgs',
    'CoreDefaultSecurityListIngressSecurityRuleIcmpOptionsArgs',
    'CoreDefaultSecurityListIngressSecurityRuleTcpOptionsArgs',
    'CoreDefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'CoreDefaultSecurityListIngressSecurityRuleUdpOptionsArgs',
    'CoreDefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'CoreDhcpOptionsOptionArgs',
    'CoreDrgAttachmentManagementNetworkDetailsArgs',
    'CoreDrgAttachmentNetworkDetailsArgs',
    'CoreDrgAttachmentsListDrgAllAttachmentArgs',
    'CoreDrgDefaultDrgRouteTablesArgs',
    'CoreDrgRouteDistributionStatementMatchCriteriaArgs',
    'CoreImageAgentFeaturesArgs',
    'CoreImageImageSourceDetailsArgs',
    'CoreImageLaunchOptionsArgs',
    'CoreInstanceAgentConfigArgs',
    'CoreInstanceAgentConfigPluginsConfigArgs',
    'CoreInstanceAvailabilityConfigArgs',
    'CoreInstanceConfigurationInstanceDetailsArgs',
    'CoreInstanceConfigurationInstanceDetailsBlockVolumeArgs',
    'CoreInstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs',
    'CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs',
    'CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs',
    'CoreInstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs',
    'CoreInstanceConfigurationInstanceDetailsSecondaryVnicArgs',
    'CoreInstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs',
    'CoreInstanceCreateVnicDetailsArgs',
    'CoreInstanceInstanceOptionsArgs',
    'CoreInstanceLaunchOptionsArgs',
    'CoreInstancePlatformConfigArgs',
    'CoreInstancePoolInstanceLoadBalancerBackendArgs',
    'CoreInstancePoolLoadBalancerArgs',
    'CoreInstancePoolPlacementConfigurationArgs',
    'CoreInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs',
    'CoreInstancePreemptibleInstanceConfigArgs',
    'CoreInstancePreemptibleInstanceConfigPreemptionActionArgs',
    'CoreInstanceShapeConfigArgs',
    'CoreInstanceSourceDetailsArgs',
    'CoreIpsecConnectionTunnelManagementBgpSessionInfoArgs',
    'CoreIpsecConnectionTunnelManagementEncryptionDomainConfigArgs',
    'CoreNetworkSecurityGroupSecurityRuleIcmpOptionsArgs',
    'CoreNetworkSecurityGroupSecurityRuleTcpOptionsArgs',
    'CoreNetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs',
    'CoreNetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs',
    'CoreNetworkSecurityGroupSecurityRuleUdpOptionsArgs',
    'CoreNetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs',
    'CoreNetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs',
    'CoreRouteTableRouteRuleArgs',
    'CoreSecurityListEgressSecurityRuleArgs',
    'CoreSecurityListEgressSecurityRuleIcmpOptionsArgs',
    'CoreSecurityListEgressSecurityRuleTcpOptionsArgs',
    'CoreSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'CoreSecurityListEgressSecurityRuleUdpOptionsArgs',
    'CoreSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'CoreSecurityListIngressSecurityRuleArgs',
    'CoreSecurityListIngressSecurityRuleIcmpOptionsArgs',
    'CoreSecurityListIngressSecurityRuleTcpOptionsArgs',
    'CoreSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs',
    'CoreSecurityListIngressSecurityRuleUdpOptionsArgs',
    'CoreSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs',
    'CoreServiceGatewayServiceArgs',
    'CoreVirtualCircuitCrossConnectMappingArgs',
    'CoreVirtualCircuitPublicPrefixArgs',
    'CoreVnicAttachmentCreateVnicDetailsArgs',
    'CoreVolumeAttachmentMultipathDeviceArgs',
    'CoreVolumeBackupPolicyScheduleArgs',
    'CoreVolumeBackupSourceDetailsArgs',
    'CoreVolumeBlockVolumeReplicaArgs',
    'CoreVolumeGroupBackupSourceDetailsArgs',
    'CoreVolumeGroupSourceDetailsArgs',
    'CoreVolumeSourceDetailsArgs',
    'DataSafeTargetDatabaseConnectionOptionArgs',
    'DataSafeTargetDatabaseCredentialsArgs',
    'DataSafeTargetDatabaseDatabaseDetailsArgs',
    'DataSafeTargetDatabaseTlsConfigArgs',
    'DatabaseAutonomousContainerDatabaseBackupConfigArgs',
    'DatabaseAutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs',
    'DatabaseAutonomousContainerDatabaseMaintenanceWindowArgs',
    'DatabaseAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs',
    'DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsArgs',
    'DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs',
    'DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs',
    'DatabaseAutonomousContainerDatabaseMaintenanceWindowMonthArgs',
    'DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgs',
    'DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs',
    'DatabaseAutonomousDatabaseApexDetailsArgs',
    'DatabaseAutonomousDatabaseBackupConfigArgs',
    'DatabaseAutonomousDatabaseConnectionStringsArgs',
    'DatabaseAutonomousDatabaseConnectionUrlsArgs',
    'DatabaseAutonomousDatabaseCustomerContactArgs',
    'DatabaseAutonomousDatabaseKeyHistoryEntryArgs',
    'DatabaseAutonomousDatabaseStandbyDbArgs',
    'DatabaseAutonomousExadataInfrastructureMaintenanceWindowArgs',
    'DatabaseAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsArgs',
    'DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs',
    'DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs',
    'DatabaseAutonomousExadataInfrastructureMaintenanceWindowMonthArgs',
    'DatabaseBackupDestinationAssociatedDatabaseArgs',
    'DatabaseBackupDestinationMountTypeDetailsArgs',
    'DatabaseCloudExadataInfrastructureCustomerContactArgs',
    'DatabaseCloudExadataInfrastructureMaintenanceWindowArgs',
    'DatabaseCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'DatabaseCloudExadataInfrastructureMaintenanceWindowMonthArgs',
    'DatabaseCloudVmClusterIormConfigCacheArgs',
    'DatabaseCloudVmClusterIormConfigCacheDbPlanArgs',
    'DatabaseDatabaseConnectionStringsArgs',
    'DatabaseDatabaseDatabaseArgs',
    'DatabaseDatabaseDatabaseDbBackupConfigArgs',
    'DatabaseDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDatabaseDbBackupConfigArgs',
    'DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDatabaseUpgradeConnectionStringsArgs',
    'DatabaseDatabaseUpgradeDatabaseUpgradeSourceDetailsArgs',
    'DatabaseDatabaseUpgradeDbBackupConfigArgs',
    'DatabaseDatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDbHomeDatabaseArgs',
    'DatabaseDbHomeDatabaseConnectionStringArgs',
    'DatabaseDbHomeDatabaseDbBackupConfigArgs',
    'DatabaseDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDbSystemDbHomeArgs',
    'DatabaseDbSystemDbHomeDatabaseArgs',
    'DatabaseDbSystemDbHomeDatabaseConnectionStringArgs',
    'DatabaseDbSystemDbHomeDatabaseDbBackupConfigArgs',
    'DatabaseDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs',
    'DatabaseDbSystemDbSystemOptionsArgs',
    'DatabaseDbSystemIormConfigCacheArgs',
    'DatabaseDbSystemIormConfigCacheDbPlanArgs',
    'DatabaseDbSystemMaintenanceWindowArgs',
    'DatabaseDbSystemMaintenanceWindowDaysOfWeekArgs',
    'DatabaseDbSystemMaintenanceWindowDetailsArgs',
    'DatabaseDbSystemMaintenanceWindowDetailsDaysOfWeekArgs',
    'DatabaseDbSystemMaintenanceWindowDetailsMonthArgs',
    'DatabaseDbSystemMaintenanceWindowMonthArgs',
    'DatabaseExadataInfrastructureContactArgs',
    'DatabaseExadataInfrastructureMaintenanceWindowArgs',
    'DatabaseExadataInfrastructureMaintenanceWindowDaysOfWeekArgs',
    'DatabaseExadataInfrastructureMaintenanceWindowMonthArgs',
    'DatabaseExadataInfrastructureStorageContactArgs',
    'DatabaseExadataInfrastructureStorageMaintenanceWindowArgs',
    'DatabaseExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs',
    'DatabaseExadataInfrastructureStorageMaintenanceWindowMonthArgs',
    'DatabaseExadataIormConfigDbPlanArgs',
    'DatabaseExternalContainerDatabaseDatabaseManagementConfigArgs',
    'DatabaseExternalDatabaseConnectorConnectionCredentialsArgs',
    'DatabaseExternalDatabaseConnectorConnectionStringArgs',
    'DatabaseExternalNonContainerDatabaseDatabaseManagementConfigArgs',
    'DatabaseExternalNonContainerDatabaseOperationsInsightsConfigArgs',
    'DatabaseExternalPluggableDatabaseDatabaseManagementConfigArgs',
    'DatabaseExternalPluggableDatabaseOperationsInsightsConfigArgs',
    'DatabaseKeyStoreAssociatedDatabaseArgs',
    'DatabaseKeyStoreTypeDetailsArgs',
    'DatabaseManagementManagedDatabaseGroupManagedDatabaseArgs',
    'DatabaseManagementManagedDatabasesChangeDatabaseParameterCredentialsArgs',
    'DatabaseManagementManagedDatabasesChangeDatabaseParameterParameterArgs',
    'DatabaseManagementManagedDatabasesResetDatabaseParameterCredentialsArgs',
    'DatabaseMigrationAdditionalMigrationArgs',
    'DatabaseMigrationConnectionAdminCredentialsArgs',
    'DatabaseMigrationConnectionConnectDescriptorArgs',
    'DatabaseMigrationConnectionPrivateEndpointArgs',
    'DatabaseMigrationConnectionSshDetailsArgs',
    'DatabaseMigrationConnectionVaultDetailsArgs',
    'DatabaseMigrationJobProgressArgs',
    'DatabaseMigrationJobProgressPhaseArgs',
    'DatabaseMigrationJobUnsupportedObjectArgs',
    'DatabaseMigrationMigrationDataTransferMediumDetailsArgs',
    'DatabaseMigrationMigrationDataTransferMediumDetailsDatabaseLinkDetailsArgs',
    'DatabaseMigrationMigrationDataTransferMediumDetailsObjectStorageDetailsArgs',
    'DatabaseMigrationMigrationDatapumpSettingsArgs',
    'DatabaseMigrationMigrationDatapumpSettingsDataPumpParametersArgs',
    'DatabaseMigrationMigrationDatapumpSettingsExportDirectoryObjectArgs',
    'DatabaseMigrationMigrationDatapumpSettingsImportDirectoryObjectArgs',
    'DatabaseMigrationMigrationDatapumpSettingsMetadataRemapArgs',
    'DatabaseMigrationMigrationExcludeObjectArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsHubArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsHubRestAdminCredentialsArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsHubSourceContainerDbAdminCredentialsArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsHubSourceDbAdminCredentialsArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsHubTargetDbAdminCredentialsArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsSettingsArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsSettingsExtractArgs',
    'DatabaseMigrationMigrationGoldenGateDetailsSettingsReplicatArgs',
    'DatabaseMigrationMigrationVaultDetailsArgs',
    'DatabasePluggableDatabaseConnectionStringsArgs',
    'DatabasePluggableDatabasesLocalCloneConnectionStringsArgs',
    'DatabasePluggableDatabasesRemoteCloneConnectionStringsArgs',
    'DatabaseVmClusterNetworkScanArgs',
    'DatabaseVmClusterNetworkVmNetworkArgs',
    'DatabaseVmClusterNetworkVmNetworkNodeArgs',
    'DataflowApplicationParameterArgs',
    'DataflowInvokeRunParameterArgs',
    'DatascienceModelCustomMetadataListArgs',
    'DatascienceModelDefinedMetadataListArgs',
    'DatascienceModelDeploymentCategoryLogDetailsArgs',
    'DatascienceModelDeploymentCategoryLogDetailsAccessArgs',
    'DatascienceModelDeploymentCategoryLogDetailsPredictArgs',
    'DatascienceModelDeploymentModelDeploymentConfigurationDetailsArgs',
    'DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs',
    'DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs',
    'DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs',
    'DatascienceNotebookSessionNotebookSessionConfigurationDetailsArgs',
    'DatascienceNotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs',
    'DevopsDeployArtifactDeployArtifactSourceArgs',
    'DevopsDeployEnvironmentComputeInstanceGroupSelectorsArgs',
    'DevopsDeployEnvironmentComputeInstanceGroupSelectorsItemArgs',
    'DevopsDeployPipelineDeployPipelineArtifactsArgs',
    'DevopsDeployPipelineDeployPipelineArtifactsItemArgs',
    'DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesArgs',
    'DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesItemArgs',
    'DevopsDeployPipelineDeployPipelineEnvironmentsArgs',
    'DevopsDeployPipelineDeployPipelineEnvironmentsItemArgs',
    'DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesArgs',
    'DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs',
    'DevopsDeployPipelineDeployPipelineParametersArgs',
    'DevopsDeployPipelineDeployPipelineParametersItemArgs',
    'DevopsDeployStageApprovalPolicyArgs',
    'DevopsDeployStageBlueBackendIpsArgs',
    'DevopsDeployStageDeployStagePredecessorCollectionArgs',
    'DevopsDeployStageDeployStagePredecessorCollectionItemArgs',
    'DevopsDeployStageFailurePolicyArgs',
    'DevopsDeployStageGreenBackendIpsArgs',
    'DevopsDeployStageLoadBalancerConfigArgs',
    'DevopsDeployStageRollbackPolicyArgs',
    'DevopsDeployStageRolloutPolicyArgs',
    'DevopsDeployStageWaitCriteriaArgs',
    'DevopsDeploymentDeployArtifactOverrideArgumentsArgs',
    'DevopsDeploymentDeployArtifactOverrideArgumentsItemArgs',
    'DevopsDeploymentDeployPipelineArtifactsArgs',
    'DevopsDeploymentDeployPipelineArtifactsItemArgs',
    'DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesArgs',
    'DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesItemArgs',
    'DevopsDeploymentDeployPipelineEnvironmentsArgs',
    'DevopsDeploymentDeployPipelineEnvironmentsItemArgs',
    'DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesArgs',
    'DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs',
    'DevopsDeploymentDeploymentArgumentsArgs',
    'DevopsDeploymentDeploymentArgumentsItemArgs',
    'DevopsDeploymentDeploymentExecutionProgressArgs',
    'DevopsProjectNotificationConfigArgs',
    'DnsResolverAttachedViewArgs',
    'DnsResolverEndpointArgs',
    'DnsResolverRuleArgs',
    'DnsRrsetItemArgs',
    'DnsSteeringPolicyAnswerArgs',
    'DnsSteeringPolicyRuleArgs',
    'DnsSteeringPolicyRuleCaseArgs',
    'DnsSteeringPolicyRuleCaseAnswerDataArgs',
    'DnsSteeringPolicyRuleDefaultAnswerDataArgs',
    'DnsZoneExternalMasterArgs',
    'DnsZoneNameserverArgs',
    'EventsRuleActionsArgs',
    'EventsRuleActionsActionArgs',
    'FileStorageExportExportOptionArgs',
    'FileStorageFileSystemSourceDetailsArgs',
    'FunctionsApplicationTraceConfigArgs',
    'FunctionsFunctionTraceConfigArgs',
    'GetAnalyticsAnalyticsInstancesFilterArgs',
    'GetApigatewayApisFilterArgs',
    'GetApigatewayCertificatesFilterArgs',
    'GetApigatewayDeploymentsFilterArgs',
    'GetApigatewayGatewaysFilterArgs',
    'GetApmApmDomainsFilterArgs',
    'GetApmDataKeysFilterArgs',
    'GetApmSyntheticsMonitorsFilterArgs',
    'GetApmSyntheticsPublicVantagePointsFilterArgs',
    'GetApmSyntheticsScriptsFilterArgs',
    'GetArtifactsContainerImageSignaturesFilterArgs',
    'GetArtifactsContainerImagesFilterArgs',
    'GetArtifactsContainerRepositoriesFilterArgs',
    'GetArtifactsGenericArtifactsFilterArgs',
    'GetArtifactsRepositoriesFilterArgs',
    'GetAuditEventsFilterArgs',
    'GetAutoscalingAutoScalingConfigurationsFilterArgs',
    'GetBastionBastionsFilterArgs',
    'GetBastionSessionsFilterArgs',
    'GetBdsAutoScalingConfigurationsFilterArgs',
    'GetBdsBdsInstancesFilterArgs',
    'GetBlockchainBlockchainPlatformsFilterArgs',
    'GetBlockchainOsnsFilterArgs',
    'GetBlockchainPeersFilterArgs',
    'GetBudgetAlertRulesFilterArgs',
    'GetBudgetBudgetsFilterArgs',
    'GetCloudGuardDataMaskRulesFilterArgs',
    'GetCloudGuardDetectorRecipesFilterArgs',
    'GetCloudGuardManagedListsFilterArgs',
    'GetCloudGuardResponderRecipesFilterArgs',
    'GetCloudGuardTargetsFilterArgs',
    'GetComputeinstanceagentInstanceAgentPluginsFilterArgs',
    'GetComputeinstanceagentInstanceAvailablePluginsFilterArgs',
    'GetContainerengineClustersFilterArgs',
    'GetContainerengineNodePoolsFilterArgs',
    'GetContainerengineWorkRequestErrorsFilterArgs',
    'GetContainerengineWorkRequestLogEntriesFilterArgs',
    'GetContainerengineWorkRequestsFilterArgs',
    'GetCoreAppCatalogListingResourceVersionsFilterArgs',
    'GetCoreAppCatalogListingsFilterArgs',
    'GetCoreAppCatalogSubscriptionsFilterArgs',
    'GetCoreBlockVolumeReplicasFilterArgs',
    'GetCoreBootVolumeAttachmentsFilterArgs',
    'GetCoreBootVolumeBackupsFilterArgs',
    'GetCoreBootVolumeReplicasFilterArgs',
    'GetCoreBootVolumesFilterArgs',
    'GetCoreByoipAllocatedRangesFilterArgs',
    'GetCoreByoipRangesFilterArgs',
    'GetCoreClusterNetworkInstancesFilterArgs',
    'GetCoreClusterNetworksFilterArgs',
    'GetCoreComputeCapacityReservationInstanceShapesFilterArgs',
    'GetCoreComputeCapacityReservationInstancesFilterArgs',
    'GetCoreComputeCapacityReservationsFilterArgs',
    'GetCoreComputeGlobalImageCapabilitySchemasFilterArgs',
    'GetCoreComputeGlobalImageCapabilitySchemasVersionsFilterArgs',
    'GetCoreComputeImageCapabilitySchemasFilterArgs',
    'GetCoreConsoleHistoriesFilterArgs',
    'GetCoreCpeDeviceShapesFilterArgs',
    'GetCoreCpesFilterArgs',
    'GetCoreCrossConnectGroupsFilterArgs',
    'GetCoreCrossConnectLocationsFilterArgs',
    'GetCoreCrossConnectPortSpeedShapesFilterArgs',
    'GetCoreCrossConnectsFilterArgs',
    'GetCoreDedicatedVmHostInstanceShapesFilterArgs',
    'GetCoreDedicatedVmHostShapesFilterArgs',
    'GetCoreDedicatedVmHostsFilterArgs',
    'GetCoreDedicatedVmHostsInstancesFilterArgs',
    'GetCoreDhcpOptionsFilterArgs',
    'GetCoreDrgAttachmentsFilterArgs',
    'GetCoreDrgRouteDistributionStatementsFilterArgs',
    'GetCoreDrgRouteDistributionsFilterArgs',
    'GetCoreDrgRouteTableRouteRulesFilterArgs',
    'GetCoreDrgRouteTablesFilterArgs',
    'GetCoreDrgsFilterArgs',
    'GetCoreFastConnectProviderServicesFilterArgs',
    'GetCoreImageShapesFilterArgs',
    'GetCoreImagesFilterArgs',
    'GetCoreInstanceConfigurationsFilterArgs',
    'GetCoreInstanceConsoleConnectionsFilterArgs',
    'GetCoreInstanceDevicesFilterArgs',
    'GetCoreInstancePoolInstancesFilterArgs',
    'GetCoreInstancePoolsFilterArgs',
    'GetCoreInstancesFilterArgs',
    'GetCoreInternetGatewaysFilterArgs',
    'GetCoreIpsecConfigFilterArgs',
    'GetCoreIpsecConnectionTunnelsFilterArgs',
    'GetCoreIpsecConnectionsFilterArgs',
    'GetCoreIpsecStatusFilterArgs',
    'GetCoreIpv6sFilterArgs',
    'GetCoreListingResourceVersionsFilterArgs',
    'GetCoreLocalPeeringGatewaysFilterArgs',
    'GetCoreNatGatewaysFilterArgs',
    'GetCoreNetworkSecurityGroupSecurityRulesFilterArgs',
    'GetCoreNetworkSecurityGroupVnicsFilterArgs',
    'GetCoreNetworkSecurityGroupsFilterArgs',
    'GetCorePeerRegionForRemotePeeringsFilterArgs',
    'GetCorePrivateIpsFilterArgs',
    'GetCorePublicIpPoolsFilterArgs',
    'GetCorePublicIpsFilterArgs',
    'GetCoreRemotePeeringConnectionsFilterArgs',
    'GetCoreRouteTablesFilterArgs',
    'GetCoreSecurityListsFilterArgs',
    'GetCoreServiceGatewaysFilterArgs',
    'GetCoreServicesFilterArgs',
    'GetCoreShapeFilterArgs',
    'GetCoreShapesFilterArgs',
    'GetCoreSubnetsFilterArgs',
    'GetCoreVcnsFilterArgs',
    'GetCoreVirtualCircuitBandwidthShapesFilterArgs',
    'GetCoreVirtualCircuitPublicPrefixesFilterArgs',
    'GetCoreVirtualCircuitsFilterArgs',
    'GetCoreVirtualNetworksFilterArgs',
    'GetCoreVlansFilterArgs',
    'GetCoreVnicAttachmentsFilterArgs',
    'GetCoreVolumeAttachmentsFilterArgs',
    'GetCoreVolumeBackupPoliciesFilterArgs',
    'GetCoreVolumeBackupPolicyAssignmentsFilterArgs',
    'GetCoreVolumeBackupsFilterArgs',
    'GetCoreVolumeGroupBackupsFilterArgs',
    'GetCoreVolumeGroupsFilterArgs',
    'GetCoreVolumesFilterArgs',
    'GetDataSafeDataSafePrivateEndpointsFilterArgs',
    'GetDataSafeOnPremConnectorsFilterArgs',
    'GetDataSafeTargetDatabasesFilterArgs',
    'GetDatabaseAutonomousContainerDatabaseDataguardAssociationsFilterArgs',
    'GetDatabaseAutonomousContainerDatabasesFilterArgs',
    'GetDatabaseAutonomousContainerPatchesFilterArgs',
    'GetDatabaseAutonomousDatabaseBackupsFilterArgs',
    'GetDatabaseAutonomousDatabaseDataguardAssociationsFilterArgs',
    'GetDatabaseAutonomousDatabasesClonesFilterArgs',
    'GetDatabaseAutonomousDatabasesFilterArgs',
    'GetDatabaseAutonomousDbPreviewVersionsFilterArgs',
    'GetDatabaseAutonomousDbVersionsFilterArgs',
    'GetDatabaseAutonomousExadataInfrastructureShapesFilterArgs',
    'GetDatabaseAutonomousExadataInfrastructuresFilterArgs',
    'GetDatabaseAutonomousVmClustersFilterArgs',
    'GetDatabaseBackupDestinationsFilterArgs',
    'GetDatabaseBackupsFilterArgs',
    'GetDatabaseCloudExadataInfrastructuresFilterArgs',
    'GetDatabaseCloudVmClustersFilterArgs',
    'GetDatabaseDataGuardAssociationsFilterArgs',
    'GetDatabaseDatabaseSoftwareImagesFilterArgs',
    'GetDatabaseDatabaseUpgradeHistoryEntriesFilterArgs',
    'GetDatabaseDatabasesFilterArgs',
    'GetDatabaseDbHomePatchHistoryEntriesFilterArgs',
    'GetDatabaseDbHomePatchesFilterArgs',
    'GetDatabaseDbHomesFilterArgs',
    'GetDatabaseDbNodeConsoleConnectionsFilterArgs',
    'GetDatabaseDbNodesFilterArgs',
    'GetDatabaseDbSystemPatchHistoryEntriesFilterArgs',
    'GetDatabaseDbSystemPatchesFilterArgs',
    'GetDatabaseDbSystemShapesFilterArgs',
    'GetDatabaseDbSystemsFilterArgs',
    'GetDatabaseDbVersionsFilterArgs',
    'GetDatabaseExadataInfrastructuresFilterArgs',
    'GetDatabaseExternalContainerDatabasesFilterArgs',
    'GetDatabaseExternalDatabaseConnectorsFilterArgs',
    'GetDatabaseExternalNonContainerDatabasesFilterArgs',
    'GetDatabaseExternalPluggableDatabasesFilterArgs',
    'GetDatabaseFlexComponentsFilterArgs',
    'GetDatabaseGiVersionsFilterArgs',
    'GetDatabaseKeyStoresFilterArgs',
    'GetDatabaseMaintenanceRunsFilterArgs',
    'GetDatabaseManagementManagedDatabaseGroupsFilterArgs',
    'GetDatabaseManagementManagedDatabasesDatabaseParametersFilterArgs',
    'GetDatabaseManagementManagedDatabasesFilterArgs',
    'GetDatabaseMigrationAgentImagesFilterArgs',
    'GetDatabaseMigrationAgentsFilterArgs',
    'GetDatabaseMigrationConnectionsFilterArgs',
    'GetDatabaseMigrationJobsFilterArgs',
    'GetDatabaseMigrationMigrationsFilterArgs',
    'GetDatabasePluggableDatabasesFilterArgs',
    'GetDatabaseVmClusterNetworksFilterArgs',
    'GetDatabaseVmClusterPatchHistoryEntriesFilterArgs',
    'GetDatabaseVmClusterPatchesFilterArgs',
    'GetDatabaseVmClusterRecommendedNetworkNetworkArgs',
    'GetDatabaseVmClusterUpdateHistoryEntriesFilterArgs',
    'GetDatabaseVmClusterUpdatesFilterArgs',
    'GetDatabaseVmClustersFilterArgs',
    'GetDatacatalogCatalogPrivateEndpointsFilterArgs',
    'GetDatacatalogCatalogTypesFilterArgs',
    'GetDatacatalogCatalogsFilterArgs',
    'GetDatacatalogConnectionsFilterArgs',
    'GetDatacatalogDataAssetsFilterArgs',
    'GetDatacatalogMetastoresFilterArgs',
    'GetDataflowApplicationsFilterArgs',
    'GetDataflowInvokeRunsFilterArgs',
    'GetDataflowPrivateEndpointsFilterArgs',
    'GetDataflowRunLogsFilterArgs',
    'GetDataintegrationWorkspacesFilterArgs',
    'GetDatascienceModelDeploymentShapesFilterArgs',
    'GetDatascienceModelDeploymentsFilterArgs',
    'GetDatascienceModelsFilterArgs',
    'GetDatascienceNotebookSessionShapesFilterArgs',
    'GetDatascienceNotebookSessionsFilterArgs',
    'GetDatascienceProjectsFilterArgs',
    'GetDevopsDeployArtifactsFilterArgs',
    'GetDevopsDeployEnvironmentsFilterArgs',
    'GetDevopsDeployPipelinesFilterArgs',
    'GetDevopsDeployStagesFilterArgs',
    'GetDevopsDeploymentsFilterArgs',
    'GetDevopsProjectsFilterArgs',
    'GetDnsRecordsFilterArgs',
    'GetDnsResolverEndpointsFilterArgs',
    'GetDnsResolversFilterArgs',
    'GetDnsSteeringPoliciesFilterArgs',
    'GetDnsSteeringPolicyAttachmentsFilterArgs',
    'GetDnsTsigKeysFilterArgs',
    'GetDnsViewsFilterArgs',
    'GetDnsZonesFilterArgs',
    'GetEmailDkimsFilterArgs',
    'GetEmailEmailDomainsFilterArgs',
    'GetEmailSendersFilterArgs',
    'GetEmailSuppressionsFilterArgs',
    'GetEventsRulesFilterArgs',
    'GetFileStorageExportSetsFilterArgs',
    'GetFileStorageExportsFilterArgs',
    'GetFileStorageFileSystemsFilterArgs',
    'GetFileStorageMountTargetsFilterArgs',
    'GetFileStorageSnapshotsFilterArgs',
    'GetFunctionsApplicationsFilterArgs',
    'GetFunctionsFunctionsFilterArgs',
    'GetGoldenGateDatabaseRegistrationsFilterArgs',
    'GetGoldenGateDeploymentBackupsFilterArgs',
    'GetGoldenGateDeploymentsFilterArgs',
    'GetHealthChecksHttpMonitorsFilterArgs',
    'GetHealthChecksHttpProbeResultsFilterArgs',
    'GetHealthChecksPingMonitorsFilterArgs',
    'GetHealthChecksPingProbeResultsFilterArgs',
    'GetHealthChecksVantagePointsFilterArgs',
    'GetIdentityApiKeysFilterArgs',
    'GetIdentityAuthTokensFilterArgs',
    'GetIdentityAvailabilityDomainsFilterArgs',
    'GetIdentityCompartmentsFilterArgs',
    'GetIdentityCostTrackingTagsFilterArgs',
    'GetIdentityCustomerSecretKeysFilterArgs',
    'GetIdentityDynamicGroupsFilterArgs',
    'GetIdentityFaultDomainsFilterArgs',
    'GetIdentityGroupsFilterArgs',
    'GetIdentityIdentityProviderGroupsFilterArgs',
    'GetIdentityIdentityProvidersFilterArgs',
    'GetIdentityIdpGroupMappingsFilterArgs',
    'GetIdentityNetworkSourcesFilterArgs',
    'GetIdentityPoliciesFilterArgs',
    'GetIdentityRegionSubscriptionsFilterArgs',
    'GetIdentityRegionsFilterArgs',
    'GetIdentitySmtpCredentialsFilterArgs',
    'GetIdentitySwiftPasswordsFilterArgs',
    'GetIdentityTagDefaultsFilterArgs',
    'GetIdentityTagNamespacesFilterArgs',
    'GetIdentityTagsFilterArgs',
    'GetIdentityUserGroupMembershipsFilterArgs',
    'GetIdentityUsersFilterArgs',
    'GetIntegrationIntegrationInstancesFilterArgs',
    'GetJmsFleetsFilterArgs',
    'GetKmsKeyVersionsFilterArgs',
    'GetKmsKeysFilterArgs',
    'GetKmsVaultReplicasFilterArgs',
    'GetKmsVaultsFilterArgs',
    'GetLimitsLimitDefinitionsFilterArgs',
    'GetLimitsLimitValuesFilterArgs',
    'GetLimitsQuotasFilterArgs',
    'GetLimitsServicesFilterArgs',
    'GetLoadBalancerBackendSetsFilterArgs',
    'GetLoadBalancerBackendsFilterArgs',
    'GetLoadBalancerCertificatesFilterArgs',
    'GetLoadBalancerHostnamesFilterArgs',
    'GetLoadBalancerListenerRulesFilterArgs',
    'GetLoadBalancerLoadBalancerRoutingPoliciesFilterArgs',
    'GetLoadBalancerLoadBalancersFilterArgs',
    'GetLoadBalancerPathRouteSetsFilterArgs',
    'GetLoadBalancerPoliciesFilterArgs',
    'GetLoadBalancerProtocolsFilterArgs',
    'GetLoadBalancerRuleSetsFilterArgs',
    'GetLoadBalancerShapesFilterArgs',
    'GetLoadBalancerSslCipherSuitesFilterArgs',
    'GetLoadBalancersFilterArgs',
    'GetLogAnalyticsLogAnalyticsEntitiesFilterArgs',
    'GetLogAnalyticsLogAnalyticsLogGroupsFilterArgs',
    'GetLogAnalyticsLogAnalyticsObjectCollectionRulesFilterArgs',
    'GetLogAnalyticsNamespacesFilterArgs',
    'GetLoggingLogGroupsFilterArgs',
    'GetLoggingLogSavedSearchesFilterArgs',
    'GetLoggingLogsFilterArgs',
    'GetLoggingUnifiedAgentConfigurationsFilterArgs',
    'GetManagementAgentManagementAgentAvailableHistoriesFilterArgs',
    'GetManagementAgentManagementAgentImagesFilterArgs',
    'GetManagementAgentManagementAgentInstallKeysFilterArgs',
    'GetManagementAgentManagementAgentPluginsFilterArgs',
    'GetManagementAgentManagementAgentsFilterArgs',
    'GetMarketplaceAcceptedAgreementsFilterArgs',
    'GetMarketplaceCategoriesFilterArgs',
    'GetMarketplaceListingPackageAgreementsFilterArgs',
    'GetMarketplaceListingPackagesFilterArgs',
    'GetMarketplaceListingTaxesFilterArgs',
    'GetMarketplaceListingsFilterArgs',
    'GetMarketplacePublicationPackagesFilterArgs',
    'GetMarketplacePublicationsFilterArgs',
    'GetMarketplacePublishersFilterArgs',
    'GetMeteringComputationCustomTablesFilterArgs',
    'GetMeteringComputationQueriesFilterArgs',
    'GetMonitoringAlarmStatusesFilterArgs',
    'GetMonitoringAlarmsFilterArgs',
    'GetMonitoringMetricDataFilterArgs',
    'GetMonitoringMetricsFilterArgs',
    'GetMysqlChannelsFilterArgs',
    'GetMysqlMysqlBackupsFilterArgs',
    'GetMysqlMysqlConfigurationsFilterArgs',
    'GetMysqlMysqlDbSystemsFilterArgs',
    'GetMysqlMysqlVersionsFilterArgs',
    'GetMysqlShapesFilterArgs',
    'GetNetworkLoadBalancerBackendSetsFilterArgs',
    'GetNetworkLoadBalancerBackendsFilterArgs',
    'GetNetworkLoadBalancerListenersFilterArgs',
    'GetNetworkLoadBalancerNetworkLoadBalancersFilterArgs',
    'GetNetworkLoadBalancerNetworkLoadBalancersPoliciesFilterArgs',
    'GetNetworkLoadBalancerNetworkLoadBalancersProtocolsFilterArgs',
    'GetNosqlIndexesFilterArgs',
    'GetNosqlTablesFilterArgs',
    'GetObjectstorageBucketSummariesFilterArgs',
    'GetObjectstorageObjectVersionsFilterArgs',
    'GetObjectstorageObjectsFilterArgs',
    'GetObjectstoragePreauthrequestsFilterArgs',
    'GetObjectstorageReplicationPoliciesFilterArgs',
    'GetObjectstorageReplicationSourcesFilterArgs',
    'GetOceOceInstancesFilterArgs',
    'GetOcvpEsxiHostsFilterArgs',
    'GetOcvpSddcsFilterArgs',
    'GetOcvpSupportedSkusFilterArgs',
    'GetOcvpSupportedVmwareSoftwareVersionsFilterArgs',
    'GetOdaOdaInstancesFilterArgs',
    'GetOnsNotificationTopicsFilterArgs',
    'GetOnsSubscriptionsFilterArgs',
    'GetOpsiDatabaseInsightsFilterArgs',
    'GetOpsiEnterpriseManagerBridgesFilterArgs',
    'GetOpsiHostInsightsFilterArgs',
    'GetOptimizerCategoriesFilterArgs',
    'GetOptimizerEnrollmentStatusesFilterArgs',
    'GetOptimizerHistoriesFilterArgs',
    'GetOptimizerProfilesFilterArgs',
    'GetOptimizerRecommendationsFilterArgs',
    'GetOptimizerResourceActionsFilterArgs',
    'GetOsmanagementManagedInstanceGroupsFilterArgs',
    'GetOsmanagementManagedInstancesFilterArgs',
    'GetOsmanagementSoftwareSourcesFilterArgs',
    'GetResourcemanagerStacksFilterArgs',
    'GetSchServiceConnectorsFilterArgs',
    'GetServiceCatalogPrivateApplicationPackagesFilterArgs',
    'GetServiceCatalogPrivateApplicationsFilterArgs',
    'GetServiceCatalogServiceCatalogAssociationsFilterArgs',
    'GetServiceCatalogServiceCatalogsFilterArgs',
    'GetStreamingConnectHarnessesFilterArgs',
    'GetStreamingStreamPoolsFilterArgs',
    'GetStreamingStreamsFilterArgs',
    'GetVaultSecretsFilterArgs',
    'GetVulnerabilityScanningHostScanRecipesFilterArgs',
    'GetVulnerabilityScanningHostScanTargetsFilterArgs',
    'GetWaasAddressListsFilterArgs',
    'GetWaasCertificatesFilterArgs',
    'GetWaasCustomProtectionRulesFilterArgs',
    'GetWaasEdgeSubnetsFilterArgs',
    'GetWaasHttpRedirectsFilterArgs',
    'GetWaasProtectionRulesFilterArgs',
    'GetWaasWaasPoliciesFilterArgs',
    'GoldenGateDeploymentOggDataArgs',
    'IdentityAuthenticationPolicyNetworkPolicyArgs',
    'IdentityAuthenticationPolicyPasswordPolicyArgs',
    'IdentityNetworkSourceVirtualSourceListArgs',
    'IdentityTagValidatorArgs',
    'IdentityUserCapabilitiesArgs',
    'IntegrationIntegrationInstanceAlternateCustomEndpointArgs',
    'IntegrationIntegrationInstanceCustomEndpointArgs',
    'IntegrationIntegrationInstanceNetworkEndpointDetailsArgs',
    'IntegrationIntegrationInstanceNetworkEndpointDetailsAllowlistedHttpVcnArgs',
    'KmsGeneratedKeyKeyShapeArgs',
    'KmsKeyKeyShapeArgs',
    'KmsKeyReplicaDetailsArgs',
    'KmsKeyRestoreFromFileArgs',
    'KmsKeyRestoreFromObjectStoreArgs',
    'KmsKeyVersionReplicaDetailsArgs',
    'KmsVaultReplicaDetailsArgs',
    'KmsVaultRestoreFromFileArgs',
    'KmsVaultRestoreFromObjectStoreArgs',
    'LoadBalancerBackendSetBackendArgs',
    'LoadBalancerBackendSetHealthCheckerArgs',
    'LoadBalancerBackendSetLbCookieSessionPersistenceConfigurationArgs',
    'LoadBalancerBackendSetSessionPersistenceConfigurationArgs',
    'LoadBalancerBackendSetSslConfigurationArgs',
    'LoadBalancerIpAddressDetailArgs',
    'LoadBalancerIpAddressDetailReservedIpArgs',
    'LoadBalancerListenerConnectionConfigurationArgs',
    'LoadBalancerListenerSslConfigurationArgs',
    'LoadBalancerLoadBalancerIpAddressDetailArgs',
    'LoadBalancerLoadBalancerIpAddressDetailReservedIpArgs',
    'LoadBalancerLoadBalancerReservedIpArgs',
    'LoadBalancerLoadBalancerRoutingPolicyRuleArgs',
    'LoadBalancerLoadBalancerRoutingPolicyRuleActionArgs',
    'LoadBalancerLoadBalancerShapeDetailsArgs',
    'LoadBalancerPathRouteSetPathRouteArgs',
    'LoadBalancerPathRouteSetPathRoutePathMatchTypeArgs',
    'LoadBalancerReservedIpArgs',
    'LoadBalancerRuleSetItemArgs',
    'LoadBalancerRuleSetItemConditionArgs',
    'LoadBalancerRuleSetItemRedirectUriArgs',
    'LoadBalancerShapeDetailsArgs',
    'LogAnalyticsLogAnalyticsObjectCollectionRuleOverrideArgs',
    'LoggingLogConfigurationArgs',
    'LoggingLogConfigurationSourceArgs',
    'LoggingUnifiedAgentConfigurationGroupAssociationArgs',
    'LoggingUnifiedAgentConfigurationServiceConfigurationArgs',
    'LoggingUnifiedAgentConfigurationServiceConfigurationDestinationArgs',
    'LoggingUnifiedAgentConfigurationServiceConfigurationSourceArgs',
    'LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserArgs',
    'LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs',
    'ManagementAgentManagementAgentPluginListArgs',
    'MarketplacePublicationIconArgs',
    'MarketplacePublicationPackageDetailsArgs',
    'MarketplacePublicationPackageDetailsEulaArgs',
    'MarketplacePublicationPackageDetailsOperatingSystemArgs',
    'MarketplacePublicationSupportContactArgs',
    'MarketplacePublicationSupportedOperatingSystemArgs',
    'MeteringComputationCustomTableSavedCustomTableArgs',
    'MeteringComputationCustomTableSavedCustomTableGroupByTagArgs',
    'MeteringComputationQueryQueryDefinitionArgs',
    'MeteringComputationQueryQueryDefinitionCostAnalysisUiArgs',
    'MeteringComputationQueryQueryDefinitionReportQueryArgs',
    'MeteringComputationQueryQueryDefinitionReportQueryForecastArgs',
    'MeteringComputationQueryQueryDefinitionReportQueryGroupByTagArgs',
    'MeteringComputationUsageForecastArgs',
    'MeteringComputationUsageGroupByTagArgs',
    'MeteringComputationUsageItemArgs',
    'MeteringComputationUsageItemTagArgs',
    'MonitoringAlarmSuppressionArgs',
    'MysqlAnalyticsClusterClusterNodeArgs',
    'MysqlChannelSourceArgs',
    'MysqlChannelSourceSslCaCertificateArgs',
    'MysqlChannelTargetArgs',
    'MysqlHeatWaveClusterClusterNodeArgs',
    'MysqlMysqlBackupDbSystemSnapshotArgs',
    'MysqlMysqlBackupDbSystemSnapshotBackupPolicyArgs',
    'MysqlMysqlBackupDbSystemSnapshotEndpointArgs',
    'MysqlMysqlBackupDbSystemSnapshotMaintenanceArgs',
    'MysqlMysqlDbSystemAnalyticsClusterArgs',
    'MysqlMysqlDbSystemBackupPolicyArgs',
    'MysqlMysqlDbSystemChannelArgs',
    'MysqlMysqlDbSystemChannelSourceArgs',
    'MysqlMysqlDbSystemChannelSourceSslCaCertificateArgs',
    'MysqlMysqlDbSystemChannelTargetArgs',
    'MysqlMysqlDbSystemCurrentPlacementArgs',
    'MysqlMysqlDbSystemEndpointArgs',
    'MysqlMysqlDbSystemHeatWaveClusterArgs',
    'MysqlMysqlDbSystemMaintenanceArgs',
    'MysqlMysqlDbSystemSourceArgs',
    'NetworkLoadBalancerBackendSetBackendArgs',
    'NetworkLoadBalancerBackendSetHealthCheckerArgs',
    'NetworkLoadBalancerNetworkLoadBalancerIpAddressArgs',
    'NetworkLoadBalancerNetworkLoadBalancerIpAddressReservedIpArgs',
    'NetworkLoadBalancerNetworkLoadBalancerReservedIpArgs',
    'NosqlIndexKeyArgs',
    'NosqlTableSchemaArgs',
    'NosqlTableSchemaColumnArgs',
    'NosqlTableTableLimitsArgs',
    'ObjectstorageBucketRetentionRuleArgs',
    'ObjectstorageBucketRetentionRuleDurationArgs',
    'ObjectstorageObjectLifecyclePolicyRuleArgs',
    'ObjectstorageObjectLifecyclePolicyRuleObjectNameFilterArgs',
    'ObjectstorageObjectSourceUriDetailsArgs',
    'OcvpSddcHcxOnPremLicenseArgs',
    'OptimizerProfileLevelsConfigurationArgs',
    'OptimizerProfileLevelsConfigurationItemArgs',
    'OptimizerProfileTargetCompartmentsArgs',
    'OptimizerProfileTargetTagsArgs',
    'OptimizerProfileTargetTagsItemArgs',
    'OptimizerRecommendationResourceCountArgs',
    'OptimizerRecommendationSupportedLevelsArgs',
    'OptimizerRecommendationSupportedLevelsItemArgs',
    'OptimizerResourceActionActionArgs',
    'OsmanagementManagedInstanceGroupManagedInstanceArgs',
    'OsmanagementManagedInstanceManagementChildSoftwareSourceArgs',
    'OsmanagementManagedInstanceManagementManagedInstanceGroupArgs',
    'OsmanagementManagedInstanceManagementParentSoftwareSourceArgs',
    'OsmanagementSoftwareSourceAssociatedManagedInstanceArgs',
    'SchServiceConnectorSourceArgs',
    'SchServiceConnectorSourceCursorArgs',
    'SchServiceConnectorSourceLogSourceArgs',
    'SchServiceConnectorTargetArgs',
    'SchServiceConnectorTaskArgs',
    'ServiceCatalogPrivateApplicationLogoArgs',
    'ServiceCatalogPrivateApplicationPackageDetailsArgs',
    'StreamingStreamPoolCustomEncryptionKeyArgs',
    'StreamingStreamPoolKafkaSettingsArgs',
    'StreamingStreamPoolPrivateEndpointSettingsArgs',
    'VulnerabilityScanningHostScanRecipeAgentSettingsArgs',
    'VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationArgs',
    'VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs',
    'VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs',
    'VulnerabilityScanningHostScanRecipePortSettingsArgs',
    'VulnerabilityScanningHostScanRecipeScheduleArgs',
    'WaasCertificateExtensionArgs',
    'WaasCertificateIssuerNameArgs',
    'WaasCertificatePublicKeyInfoArgs',
    'WaasCertificateSubjectNameArgs',
    'WaasHttpRedirectTargetArgs',
    'WaasProtectionRuleExclusionArgs',
    'WaasWaasPolicyOriginArgs',
    'WaasWaasPolicyOriginCustomHeaderArgs',
    'WaasWaasPolicyOriginGroupArgs',
    'WaasWaasPolicyOriginGroupOriginGroupArgs',
    'WaasWaasPolicyPolicyConfigArgs',
    'WaasWaasPolicyPolicyConfigHealthChecksArgs',
    'WaasWaasPolicyPolicyConfigLoadBalancingMethodArgs',
    'WaasWaasPolicyWafConfigArgs',
    'WaasWaasPolicyWafConfigAccessRuleArgs',
    'WaasWaasPolicyWafConfigAccessRuleCriteriaArgs',
    'WaasWaasPolicyWafConfigAccessRuleResponseHeaderManipulationArgs',
    'WaasWaasPolicyWafConfigAddressRateLimitingArgs',
    'WaasWaasPolicyWafConfigCachingRuleArgs',
    'WaasWaasPolicyWafConfigCachingRuleCriteriaArgs',
    'WaasWaasPolicyWafConfigCaptchaArgs',
    'WaasWaasPolicyWafConfigCustomProtectionRuleArgs',
    'WaasWaasPolicyWafConfigCustomProtectionRuleExclusionArgs',
    'WaasWaasPolicyWafConfigDeviceFingerprintChallengeArgs',
    'WaasWaasPolicyWafConfigDeviceFingerprintChallengeChallengeSettingsArgs',
    'WaasWaasPolicyWafConfigHumanInteractionChallengeArgs',
    'WaasWaasPolicyWafConfigHumanInteractionChallengeChallengeSettingsArgs',
    'WaasWaasPolicyWafConfigHumanInteractionChallengeSetHttpHeaderArgs',
    'WaasWaasPolicyWafConfigJsChallengeArgs',
    'WaasWaasPolicyWafConfigJsChallengeChallengeSettingsArgs',
    'WaasWaasPolicyWafConfigJsChallengeCriteriaArgs',
    'WaasWaasPolicyWafConfigJsChallengeSetHttpHeaderArgs',
    'WaasWaasPolicyWafConfigProtectionSettingsArgs',
    'WaasWaasPolicyWafConfigWhitelistArgs',
]

@pulumi.input_type
class AnalyticsAnalyticsInstanceCapacityArgs:
    def __init__(__self__, *,
                 capacity_type: pulumi.Input[str],
                 capacity_value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] capacity_type: The capacity model to use.
        :param pulumi.Input[int] capacity_value: (Updatable) The capacity value selected (OLPU count, number of users, ...etc...). This parameter affects the number of CPUs, amount of memory or other resources allocated to the instance.
        """
        pulumi.set(__self__, "capacity_type", capacity_type)
        pulumi.set(__self__, "capacity_value", capacity_value)

    @property
    @pulumi.getter(name="capacityType")
    def capacity_type(self) -> pulumi.Input[str]:
        """
        The capacity model to use.
        """
        return pulumi.get(self, "capacity_type")

    @capacity_type.setter
    def capacity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "capacity_type", value)

    @property
    @pulumi.getter(name="capacityValue")
    def capacity_value(self) -> pulumi.Input[int]:
        """
        (Updatable) The capacity value selected (OLPU count, number of users, ...etc...). This parameter affects the number of CPUs, amount of memory or other resources allocated to the instance.
        """
        return pulumi.get(self, "capacity_value")

    @capacity_value.setter
    def capacity_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "capacity_value", value)


@pulumi.input_type
class AnalyticsAnalyticsInstanceNetworkEndpointDetailsArgs:
    def __init__(__self__, *,
                 network_endpoint_type: pulumi.Input[str],
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vcn_id: Optional[pulumi.Input[str]] = None,
                 whitelisted_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 whitelisted_vcns: Optional[pulumi.Input[Sequence[pulumi.Input['AnalyticsAnalyticsInstanceNetworkEndpointDetailsWhitelistedVcnArgs']]]] = None):
        """
        :param pulumi.Input[str] network_endpoint_type: The type of network endpoint.
        :param pulumi.Input[str] subnet_id: The subnet OCID for the private endpoint.
        :param pulumi.Input[str] vcn_id: The VCN OCID for the private endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] whitelisted_ips: Source IP addresses or IP address ranges igress rules.
        :param pulumi.Input[Sequence[pulumi.Input['AnalyticsAnalyticsInstanceNetworkEndpointDetailsWhitelistedVcnArgs']]] whitelisted_vcns: Virtual Cloud Networks allowed to access this network endpoint.
        """
        pulumi.set(__self__, "network_endpoint_type", network_endpoint_type)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vcn_id is not None:
            pulumi.set(__self__, "vcn_id", vcn_id)
        if whitelisted_ips is not None:
            pulumi.set(__self__, "whitelisted_ips", whitelisted_ips)
        if whitelisted_vcns is not None:
            pulumi.set(__self__, "whitelisted_vcns", whitelisted_vcns)

    @property
    @pulumi.getter(name="networkEndpointType")
    def network_endpoint_type(self) -> pulumi.Input[str]:
        """
        The type of network endpoint.
        """
        return pulumi.get(self, "network_endpoint_type")

    @network_endpoint_type.setter
    def network_endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_endpoint_type", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet OCID for the private endpoint.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vcnId")
    def vcn_id(self) -> Optional[pulumi.Input[str]]:
        """
        The VCN OCID for the private endpoint.
        """
        return pulumi.get(self, "vcn_id")

    @vcn_id.setter
    def vcn_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcn_id", value)

    @property
    @pulumi.getter(name="whitelistedIps")
    def whitelisted_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Source IP addresses or IP address ranges igress rules.
        """
        return pulumi.get(self, "whitelisted_ips")

    @whitelisted_ips.setter
    def whitelisted_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "whitelisted_ips", value)

    @property
    @pulumi.getter(name="whitelistedVcns")
    def whitelisted_vcns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AnalyticsAnalyticsInstanceNetworkEndpointDetailsWhitelistedVcnArgs']]]]:
        """
        Virtual Cloud Networks allowed to access this network endpoint.
        """
        return pulumi.get(self, "whitelisted_vcns")

    @whitelisted_vcns.setter
    def whitelisted_vcns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AnalyticsAnalyticsInstanceNetworkEndpointDetailsWhitelistedVcnArgs']]]]):
        pulumi.set(self, "whitelisted_vcns", value)


@pulumi.input_type
class AnalyticsAnalyticsInstanceNetworkEndpointDetailsWhitelistedVcnArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 whitelisted_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] id: The Virtual Cloud Network OCID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] whitelisted_ips: Source IP addresses or IP address ranges igress rules.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if whitelisted_ips is not None:
            pulumi.set(__self__, "whitelisted_ips", whitelisted_ips)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Virtual Cloud Network OCID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="whitelistedIps")
    def whitelisted_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Source IP addresses or IP address ranges igress rules.
        """
        return pulumi.get(self, "whitelisted_ips")

    @whitelisted_ips.setter
    def whitelisted_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "whitelisted_ips", value)


@pulumi.input_type
class AnalyticsAnalyticsInstancePrivateAccessChannelPrivateSourceDnsZoneArgs:
    def __init__(__self__, *,
                 dns_zone: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dns_zone: (Updatable) Private Source DNS Zone. Ex: example-vcn.oraclevcn.com, corp.example.com.
        :param pulumi.Input[str] description: (Updatable) Description of private source dns zone.
        """
        pulumi.set(__self__, "dns_zone", dns_zone)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="dnsZone")
    def dns_zone(self) -> pulumi.Input[str]:
        """
        (Updatable) Private Source DNS Zone. Ex: example-vcn.oraclevcn.com, corp.example.com.
        """
        return pulumi.get(self, "dns_zone")

    @dns_zone.setter
    def dns_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "dns_zone", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Description of private source dns zone.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ApigatewayApiValidationResultArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 result: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the validation.
        :param pulumi.Input[str] result: Result of the validation.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if result is not None:
            pulumi.set(__self__, "result", result)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the validation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def result(self) -> Optional[pulumi.Input[str]]:
        """
        Result of the validation.
        """
        return pulumi.get(self, "result")

    @result.setter
    def result(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "result", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationArgs:
    def __init__(__self__, *,
                 routes: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteArgs']]],
                 logging_policies: Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesArgs']] = None,
                 request_policies: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteArgs']]] routes: (Updatable) A list of routes that this API exposes.
        :param pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesArgs'] logging_policies: (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesArgs'] request_policies: (Updatable) Behavior applied to any requests received by the API on this route.
        """
        pulumi.set(__self__, "routes", routes)
        if logging_policies is not None:
            pulumi.set(__self__, "logging_policies", logging_policies)
        if request_policies is not None:
            pulumi.set(__self__, "request_policies", request_policies)

    @property
    @pulumi.getter
    def routes(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteArgs']]]:
        """
        (Updatable) A list of routes that this API exposes.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteArgs']]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="loggingPolicies")
    def logging_policies(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesArgs']]:
        """
        (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        """
        return pulumi.get(self, "logging_policies")

    @logging_policies.setter
    def logging_policies(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesArgs']]):
        pulumi.set(self, "logging_policies", value)

    @property
    @pulumi.getter(name="requestPolicies")
    def request_policies(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesArgs']]:
        """
        (Updatable) Behavior applied to any requests received by the API on this route.
        """
        return pulumi.get(self, "request_policies")

    @request_policies.setter
    def request_policies(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesArgs']]):
        pulumi.set(self, "request_policies", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationLoggingPoliciesArgs:
    def __init__(__self__, *,
                 access_log: Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesAccessLogArgs']] = None,
                 execution_log: Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesExecutionLogArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesAccessLogArgs'] access_log: (Updatable) Configures the logging policies for the access logs of an API Deployment.
        :param pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesExecutionLogArgs'] execution_log: (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        if access_log is not None:
            pulumi.set(__self__, "access_log", access_log)
        if execution_log is not None:
            pulumi.set(__self__, "execution_log", execution_log)

    @property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesAccessLogArgs']]:
        """
        (Updatable) Configures the logging policies for the access logs of an API Deployment.
        """
        return pulumi.get(self, "access_log")

    @access_log.setter
    def access_log(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesAccessLogArgs']]):
        pulumi.set(self, "access_log", value)

    @property
    @pulumi.getter(name="executionLog")
    def execution_log(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesExecutionLogArgs']]:
        """
        (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        return pulumi.get(self, "execution_log")

    @execution_log.setter
    def execution_log(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationLoggingPoliciesExecutionLogArgs']]):
        pulumi.set(self, "execution_log", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationLoggingPoliciesAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Whether this policy is currently enabled.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether this policy is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationLoggingPoliciesExecutionLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 log_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Whether this policy is currently enabled.
        :param pulumi.Input[str] log_level: (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether this policy is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRequestPoliciesArgs:
    def __init__(__self__, *,
                 authentication: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationArgs']] = None,
                 cors: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesCorsArgs']] = None,
                 rate_limiting: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesRateLimitingArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationArgs'] authentication: (Updatable) Information on how to authenticate incoming requests.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesCorsArgs'] cors: (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesRateLimitingArgs'] rate_limiting: (Updatable) Limit the number of requests that should be handled for the specified window using a specfic key.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if rate_limiting is not None:
            pulumi.set(__self__, "rate_limiting", rate_limiting)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationArgs']]:
        """
        (Updatable) Information on how to authenticate incoming requests.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesCorsArgs']]:
        """
        (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="rateLimiting")
    def rate_limiting(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesRateLimitingArgs']]:
        """
        (Updatable) Limit the number of requests that should be handled for the specified window using a specfic key.
        """
        return pulumi.get(self, "rate_limiting")

    @rate_limiting.setter
    def rate_limiting(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesRateLimitingArgs']]):
        pulumi.set(self, "rate_limiting", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 function_id: Optional[pulumi.Input[str]] = None,
                 is_anonymous_access_allowed: Optional[pulumi.Input[bool]] = None,
                 issuers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_clock_skew_in_seconds: Optional[pulumi.Input[float]] = None,
                 public_keys: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs']] = None,
                 token_auth_scheme: Optional[pulumi.Input[str]] = None,
                 token_header: Optional[pulumi.Input[str]] = None,
                 token_query_param: Optional[pulumi.Input[str]] = None,
                 verify_claims: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] audiences: (Updatable) The list of intended recipients for the token.
        :param pulumi.Input[str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        :param pulumi.Input[bool] is_anonymous_access_allowed: (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] issuers: (Updatable) A list of parties that could have issued the token.
        :param pulumi.Input[float] max_clock_skew_in_seconds: (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs'] public_keys: (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        :param pulumi.Input[str] token_auth_scheme: (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        :param pulumi.Input[str] token_header: (Updatable) The name of the header containing the authentication token.
        :param pulumi.Input[str] token_query_param: (Updatable) The name of the query parameter containing the authentication token.
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]] verify_claims: (Updatable) A list of claims which should be validated to consider the token valid.
        """
        pulumi.set(__self__, "type", type)
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if is_anonymous_access_allowed is not None:
            pulumi.set(__self__, "is_anonymous_access_allowed", is_anonymous_access_allowed)
        if issuers is not None:
            pulumi.set(__self__, "issuers", issuers)
        if max_clock_skew_in_seconds is not None:
            pulumi.set(__self__, "max_clock_skew_in_seconds", max_clock_skew_in_seconds)
        if public_keys is not None:
            pulumi.set(__self__, "public_keys", public_keys)
        if token_auth_scheme is not None:
            pulumi.set(__self__, "token_auth_scheme", token_auth_scheme)
        if token_header is not None:
            pulumi.set(__self__, "token_header", token_header)
        if token_query_param is not None:
            pulumi.set(__self__, "token_query_param", token_query_param)
        if verify_claims is not None:
            pulumi.set(__self__, "verify_claims", verify_claims)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of intended recipients for the token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "audiences", value)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter(name="isAnonymousAccessAllowed")
    def is_anonymous_access_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether an unauthenticated user may access the API. Must be "true" to enable ANONYMOUS route authorization.
        """
        return pulumi.get(self, "is_anonymous_access_allowed")

    @is_anonymous_access_allowed.setter
    def is_anonymous_access_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_anonymous_access_allowed", value)

    @property
    @pulumi.getter
    def issuers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of parties that could have issued the token.
        """
        return pulumi.get(self, "issuers")

    @issuers.setter
    def issuers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "issuers", value)

    @property
    @pulumi.getter(name="maxClockSkewInSeconds")
    def max_clock_skew_in_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The maximum expected time difference between the system clocks of the token issuer and the API Gateway.
        """
        return pulumi.get(self, "max_clock_skew_in_seconds")

    @max_clock_skew_in_seconds.setter
    def max_clock_skew_in_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_clock_skew_in_seconds", value)

    @property
    @pulumi.getter(name="publicKeys")
    def public_keys(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs']]:
        """
        (Updatable) A set of Public Keys that will be used to verify the JWT signature.
        """
        return pulumi.get(self, "public_keys")

    @public_keys.setter
    def public_keys(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs']]):
        pulumi.set(self, "public_keys", value)

    @property
    @pulumi.getter(name="tokenAuthScheme")
    def token_auth_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The authentication scheme that is to be used when authenticating the token. This must to be provided if "tokenHeader" is specified.
        """
        return pulumi.get(self, "token_auth_scheme")

    @token_auth_scheme.setter
    def token_auth_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_auth_scheme", value)

    @property
    @pulumi.getter(name="tokenHeader")
    def token_header(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the header containing the authentication token.
        """
        return pulumi.get(self, "token_header")

    @token_header.setter
    def token_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_header", value)

    @property
    @pulumi.getter(name="tokenQueryParam")
    def token_query_param(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the query parameter containing the authentication token.
        """
        return pulumi.get(self, "token_query_param")

    @token_query_param.setter
    def token_query_param(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_query_param", value)

    @property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]]]:
        """
        (Updatable) A list of claims which should be validated to consider the token valid.
        """
        return pulumi.get(self, "verify_claims")

    @verify_claims.setter
    def verify_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs']]]]):
        pulumi.set(self, "verify_claims", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 is_ssl_verify_disabled: Optional[pulumi.Input[bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]]] = None,
                 max_cache_duration_in_hours: Optional[pulumi.Input[int]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        :param pulumi.Input[bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]] keys: (Updatable) The set of static public keys.
        :param pulumi.Input[int] max_cache_duration_in_hours: (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        :param pulumi.Input[str] uri: (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        pulumi.set(__self__, "type", type)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if max_cache_duration_in_hours is not None:
            pulumi.set(__self__, "max_cache_duration_in_hours", max_cache_duration_in_hours)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]]]:
        """
        (Updatable) The set of static public keys.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs']]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="maxCacheDurationInHours")
    def max_cache_duration_in_hours(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The duration for which the JWKS should be cached before it is fetched again.
        """
        return pulumi.get(self, "max_cache_duration_in_hours")

    @max_cache_duration_in_hours.setter
    def max_cache_duration_in_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_cache_duration_in_hours", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The uri from which to retrieve the key. It must be accessible without authentication.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationPublicKeysKeyArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 alg: Optional[pulumi.Input[str]] = None,
                 e: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 key_ops: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kid: Optional[pulumi.Input[str]] = None,
                 kty: Optional[pulumi.Input[str]] = None,
                 n: Optional[pulumi.Input[str]] = None,
                 use: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] format: (Updatable) The format of the public key.
        :param pulumi.Input[str] alg: (Updatable) The algorithm intended for use with this key.
        :param pulumi.Input[str] e: (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        :param pulumi.Input[str] key: (Updatable) Name of the claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] key_ops: (Updatable) The operations for which this key is to be used.
        :param pulumi.Input[str] kid: (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        :param pulumi.Input[str] kty: (Updatable) The key type.
        :param pulumi.Input[str] n: (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        :param pulumi.Input[str] use: (Updatable) The intended use of the public key.
        """
        pulumi.set(__self__, "format", format)
        if alg is not None:
            pulumi.set(__self__, "alg", alg)
        if e is not None:
            pulumi.set(__self__, "e", e)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if key_ops is not None:
            pulumi.set(__self__, "key_ops", key_ops)
        if kid is not None:
            pulumi.set(__self__, "kid", kid)
        if kty is not None:
            pulumi.set(__self__, "kty", kty)
        if n is not None:
            pulumi.set(__self__, "n", n)
        if use is not None:
            pulumi.set(__self__, "use", use)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        (Updatable) The format of the public key.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def alg(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The algorithm intended for use with this key.
        """
        return pulumi.get(self, "alg")

    @alg.setter
    def alg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alg", value)

    @property
    @pulumi.getter
    def e(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The base64 url encoded exponent of the RSA public key represented by this key.
        """
        return pulumi.get(self, "e")

    @e.setter
    def e(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "e", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the claim.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="keyOps")
    def key_ops(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The operations for which this key is to be used.
        """
        return pulumi.get(self, "key_ops")

    @key_ops.setter
    def key_ops(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "key_ops", value)

    @property
    @pulumi.getter
    def kid(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A unique key ID. This key will be used to verify the signature of a JWT with matching "kid".
        """
        return pulumi.get(self, "kid")

    @kid.setter
    def kid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kid", value)

    @property
    @pulumi.getter
    def kty(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The key type.
        """
        return pulumi.get(self, "kty")

    @kty.setter
    def kty(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kty", value)

    @property
    @pulumi.getter
    def n(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The base64 url encoded modulus of the RSA public key represented by this key.
        """
        return pulumi.get(self, "n")

    @n.setter
    def n(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "n", value)

    @property
    @pulumi.getter
    def use(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The intended use of the public key.
        """
        return pulumi.get(self, "use")

    @use.setter
    def use(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRequestPoliciesAuthenticationVerifyClaimArgs:
    def __init__(__self__, *,
                 is_required: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] is_required: (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        :param pulumi.Input[str] key: (Updatable) Name of the claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        if is_required is not None:
            pulumi.set(__self__, "is_required", is_required)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="isRequired")
    def is_required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the claim is required to be present in the JWT or not. If set to "false", the claim values will be matched only if the claim is present in the JWT.
        """
        return pulumi.get(self, "is_required")

    @is_required.setter
    def is_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_required", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the claim.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRequestPoliciesCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_allow_credentials_enabled: Optional[pulumi.Input[bool]] = None,
                 max_age_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exposed_headers: (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        :param pulumi.Input[bool] is_allow_credentials_enabled: (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        :param pulumi.Input[int] max_age_in_seconds: (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if is_allow_credentials_enabled is not None:
            pulumi.set(__self__, "is_allow_credentials_enabled", is_allow_credentials_enabled)
        if max_age_in_seconds is not None:
            pulumi.set(__self__, "max_age_in_seconds", max_age_in_seconds)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exposed_headers", value)

    @property
    @pulumi.getter(name="isAllowCredentialsEnabled")
    def is_allow_credentials_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        """
        return pulumi.get(self, "is_allow_credentials_enabled")

    @is_allow_credentials_enabled.setter
    def is_allow_credentials_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_allow_credentials_enabled", value)

    @property
    @pulumi.getter(name="maxAgeInSeconds")
    def max_age_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        return pulumi.get(self, "max_age_in_seconds")

    @max_age_in_seconds.setter
    def max_age_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_in_seconds", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRequestPoliciesRateLimitingArgs:
    def __init__(__self__, *,
                 rate_in_requests_per_second: pulumi.Input[int],
                 rate_key: pulumi.Input[str]):
        """
        :param pulumi.Input[int] rate_in_requests_per_second: (Updatable) The maximum number of requests per second to allow.
        :param pulumi.Input[str] rate_key: (Updatable) The key used to group requests together.
        """
        pulumi.set(__self__, "rate_in_requests_per_second", rate_in_requests_per_second)
        pulumi.set(__self__, "rate_key", rate_key)

    @property
    @pulumi.getter(name="rateInRequestsPerSecond")
    def rate_in_requests_per_second(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum number of requests per second to allow.
        """
        return pulumi.get(self, "rate_in_requests_per_second")

    @rate_in_requests_per_second.setter
    def rate_in_requests_per_second(self, value: pulumi.Input[int]):
        pulumi.set(self, "rate_in_requests_per_second", value)

    @property
    @pulumi.getter(name="rateKey")
    def rate_key(self) -> pulumi.Input[str]:
        """
        (Updatable) The key used to group requests together.
        """
        return pulumi.get(self, "rate_key")

    @rate_key.setter
    def rate_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "rate_key", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteArgs:
    def __init__(__self__, *,
                 backend: pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendArgs'],
                 path: pulumi.Input[str],
                 logging_policies: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesArgs']] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 request_policies: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesArgs']] = None,
                 response_policies: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendArgs'] backend: (Updatable) The backend to forward requests to.
        :param pulumi.Input[str] path: (Updatable) A URL path pattern that must be matched on this route. The path pattern may contain a subset of RFC 6570 identifiers to allow wildcard and parameterized matching.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesArgs'] logging_policies: (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] methods: (Updatable) A list of allowed methods on this route.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesArgs'] request_policies: (Updatable) Behavior applied to any requests received by the API on this route.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesArgs'] response_policies: (Updatable) Behavior applied to any responses sent by the API for requests on this route.
        """
        pulumi.set(__self__, "backend", backend)
        pulumi.set(__self__, "path", path)
        if logging_policies is not None:
            pulumi.set(__self__, "logging_policies", logging_policies)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if request_policies is not None:
            pulumi.set(__self__, "request_policies", request_policies)
        if response_policies is not None:
            pulumi.set(__self__, "response_policies", response_policies)

    @property
    @pulumi.getter
    def backend(self) -> pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendArgs']:
        """
        (Updatable) The backend to forward requests to.
        """
        return pulumi.get(self, "backend")

    @backend.setter
    def backend(self, value: pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendArgs']):
        pulumi.set(self, "backend", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        (Updatable) A URL path pattern that must be matched on this route. The path pattern may contain a subset of RFC 6570 identifiers to allow wildcard and parameterized matching.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="loggingPolicies")
    def logging_policies(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesArgs']]:
        """
        (Updatable) Policies controlling the pushing of logs to Oracle Cloud Infrastructure Public Logging.
        """
        return pulumi.get(self, "logging_policies")

    @logging_policies.setter
    def logging_policies(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesArgs']]):
        pulumi.set(self, "logging_policies", value)

    @property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of allowed methods on this route.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "methods", value)

    @property
    @pulumi.getter(name="requestPolicies")
    def request_policies(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesArgs']]:
        """
        (Updatable) Behavior applied to any requests received by the API on this route.
        """
        return pulumi.get(self, "request_policies")

    @request_policies.setter
    def request_policies(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesArgs']]):
        pulumi.set(self, "request_policies", value)

    @property
    @pulumi.getter(name="responsePolicies")
    def response_policies(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesArgs']]:
        """
        (Updatable) Behavior applied to any responses sent by the API for requests on this route.
        """
        return pulumi.get(self, "response_policies")

    @response_policies.setter
    def response_policies(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesArgs']]):
        pulumi.set(self, "response_policies", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteBackendArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 body: Optional[pulumi.Input[str]] = None,
                 connect_timeout_in_seconds: Optional[pulumi.Input[float]] = None,
                 function_id: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendHeaderArgs']]]] = None,
                 is_ssl_verify_disabled: Optional[pulumi.Input[bool]] = None,
                 read_timeout_in_seconds: Optional[pulumi.Input[float]] = None,
                 send_timeout_in_seconds: Optional[pulumi.Input[float]] = None,
                 status: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        :param pulumi.Input[str] body: (Updatable) The body of the stock response from the mock backend.
        :param pulumi.Input[float] connect_timeout_in_seconds: (Updatable) Defines a timeout for establishing a connection with a proxied server.
        :param pulumi.Input[str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendHeaderArgs']]] headers: (Updatable)
        :param pulumi.Input[bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[float] read_timeout_in_seconds: (Updatable) Defines a timeout for reading a response from the proxied server.
        :param pulumi.Input[float] send_timeout_in_seconds: (Updatable) Defines a timeout for transmitting a request to the proxied server.
        :param pulumi.Input[int] status: (Updatable) The status code of the stock response from the mock backend.
        :param pulumi.Input[str] url: (Updatable)
        """
        pulumi.set(__self__, "type", type)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if connect_timeout_in_seconds is not None:
            pulumi.set(__self__, "connect_timeout_in_seconds", connect_timeout_in_seconds)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if read_timeout_in_seconds is not None:
            pulumi.set(__self__, "read_timeout_in_seconds", read_timeout_in_seconds)
        if send_timeout_in_seconds is not None:
            pulumi.set(__self__, "send_timeout_in_seconds", send_timeout_in_seconds)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The body of the stock response from the mock backend.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter(name="connectTimeoutInSeconds")
    def connect_timeout_in_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) Defines a timeout for establishing a connection with a proxied server.
        """
        return pulumi.get(self, "connect_timeout_in_seconds")

    @connect_timeout_in_seconds.setter
    def connect_timeout_in_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "connect_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Functions function resource.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendHeaderArgs']]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteBackendHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @property
    @pulumi.getter(name="readTimeoutInSeconds")
    def read_timeout_in_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) Defines a timeout for reading a response from the proxied server.
        """
        return pulumi.get(self, "read_timeout_in_seconds")

    @read_timeout_in_seconds.setter
    def read_timeout_in_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "read_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="sendTimeoutInSeconds")
    def send_timeout_in_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) Defines a timeout for transmitting a request to the proxied server.
        """
        return pulumi.get(self, "send_timeout_in_seconds")

    @send_timeout_in_seconds.setter
    def send_timeout_in_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "send_timeout_in_seconds", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The status code of the stock response from the mock backend.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteBackendHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[str] value: (Updatable) Value of the header.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteLoggingPoliciesArgs:
    def __init__(__self__, *,
                 access_log: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesAccessLogArgs']] = None,
                 execution_log: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesAccessLogArgs'] access_log: (Updatable) Configures the logging policies for the access logs of an API Deployment.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs'] execution_log: (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        if access_log is not None:
            pulumi.set(__self__, "access_log", access_log)
        if execution_log is not None:
            pulumi.set(__self__, "execution_log", execution_log)

    @property
    @pulumi.getter(name="accessLog")
    def access_log(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesAccessLogArgs']]:
        """
        (Updatable) Configures the logging policies for the access logs of an API Deployment.
        """
        return pulumi.get(self, "access_log")

    @access_log.setter
    def access_log(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesAccessLogArgs']]):
        pulumi.set(self, "access_log", value)

    @property
    @pulumi.getter(name="executionLog")
    def execution_log(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs']]:
        """
        (Updatable) Configures the logging policies for the execution logs of an API Deployment.
        """
        return pulumi.get(self, "execution_log")

    @execution_log.setter
    def execution_log(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs']]):
        pulumi.set(self, "execution_log", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteLoggingPoliciesAccessLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Whether this policy is currently enabled.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether this policy is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteLoggingPoliciesExecutionLogArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 log_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Whether this policy is currently enabled.
        :param pulumi.Input[str] log_level: (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether this policy is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies the log level used to control logging output of execution logs. Enabling logging at a given level also enables logging at all higher levels.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_level", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesAuthorizationArgs']] = None,
                 body_validation: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationArgs']] = None,
                 cors: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesCorsArgs']] = None,
                 header_transformations: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs']] = None,
                 header_validations: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs']] = None,
                 query_parameter_transformations: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs']] = None,
                 query_parameter_validations: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs']] = None,
                 response_cache_lookup: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesAuthorizationArgs'] authorization: (Updatable) If authentication has been performed, validate whether the request scope (if any) applies to this route. If no RouteAuthorizationPolicy is defined for a route, a policy with a type of AUTHENTICATION_ONLY is applied.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationArgs'] body_validation: (Updatable) Validate the payload body of the incoming API requests on a specific route.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesCorsArgs'] cors: (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs'] header_transformations: (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs'] header_validations: (Updatable) Validate the HTTP headers on the incoming API requests on a specific route.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs'] query_parameter_transformations: (Updatable) A set of transformations to apply to query parameters that pass through the gateway.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs'] query_parameter_validations: (Updatable) Validate the URL query parameters on the incoming API requests on a specific route.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs'] response_cache_lookup: (Updatable) Base policy for Response Cache lookup.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if body_validation is not None:
            pulumi.set(__self__, "body_validation", body_validation)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if header_transformations is not None:
            pulumi.set(__self__, "header_transformations", header_transformations)
        if header_validations is not None:
            pulumi.set(__self__, "header_validations", header_validations)
        if query_parameter_transformations is not None:
            pulumi.set(__self__, "query_parameter_transformations", query_parameter_transformations)
        if query_parameter_validations is not None:
            pulumi.set(__self__, "query_parameter_validations", query_parameter_validations)
        if response_cache_lookup is not None:
            pulumi.set(__self__, "response_cache_lookup", response_cache_lookup)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesAuthorizationArgs']]:
        """
        (Updatable) If authentication has been performed, validate whether the request scope (if any) applies to this route. If no RouteAuthorizationPolicy is defined for a route, a policy with a type of AUTHENTICATION_ONLY is applied.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="bodyValidation")
    def body_validation(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationArgs']]:
        """
        (Updatable) Validate the payload body of the incoming API requests on a specific route.
        """
        return pulumi.get(self, "body_validation")

    @body_validation.setter
    def body_validation(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationArgs']]):
        pulumi.set(self, "body_validation", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesCorsArgs']]:
        """
        (Updatable) Enable CORS (Cross-Origin-Resource-Sharing) request handling.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="headerTransformations")
    def header_transformations(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        return pulumi.get(self, "header_transformations")

    @header_transformations.setter
    def header_transformations(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs']]):
        pulumi.set(self, "header_transformations", value)

    @property
    @pulumi.getter(name="headerValidations")
    def header_validations(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs']]:
        """
        (Updatable) Validate the HTTP headers on the incoming API requests on a specific route.
        """
        return pulumi.get(self, "header_validations")

    @header_validations.setter
    def header_validations(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs']]):
        pulumi.set(self, "header_validations", value)

    @property
    @pulumi.getter(name="queryParameterTransformations")
    def query_parameter_transformations(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to query parameters that pass through the gateway.
        """
        return pulumi.get(self, "query_parameter_transformations")

    @query_parameter_transformations.setter
    def query_parameter_transformations(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs']]):
        pulumi.set(self, "query_parameter_transformations", value)

    @property
    @pulumi.getter(name="queryParameterValidations")
    def query_parameter_validations(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs']]:
        """
        (Updatable) Validate the URL query parameters on the incoming API requests on a specific route.
        """
        return pulumi.get(self, "query_parameter_validations")

    @query_parameter_validations.setter
    def query_parameter_validations(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs']]):
        pulumi.set(self, "query_parameter_validations", value)

    @property
    @pulumi.getter(name="responseCacheLookup")
    def response_cache_lookup(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs']]:
        """
        (Updatable) Base policy for Response Cache lookup.
        """
        return pulumi.get(self, "response_cache_lookup")

    @response_cache_lookup.setter
    def response_cache_lookup(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs']]):
        pulumi.set(self, "response_cache_lookup", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesAuthorizationArgs:
    def __init__(__self__, *,
                 allowed_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_scopes: (Updatable) A user whose scope includes any of these access ranges is allowed on this route. Access ranges are case-sensitive.
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        """
        if allowed_scopes is not None:
            pulumi.set(__self__, "allowed_scopes", allowed_scopes)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="allowedScopes")
    def allowed_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A user whose scope includes any of these access ranges is allowed on this route. Access ranges are case-sensitive.
        """
        return pulumi.get(self, "allowed_scopes")

    @allowed_scopes.setter
    def allowed_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_scopes", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationArgs:
    def __init__(__self__, *,
                 contents: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 validation_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]] contents: (Updatable) The content of the request body.
        :param pulumi.Input[bool] required: (Updatable) Determines if the parameter is required in the request.
        :param pulumi.Input[str] validation_mode: (Updatable) Validation behavior mode.
        """
        if contents is not None:
            pulumi.set(__self__, "contents", contents)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]]]:
        """
        (Updatable) The content of the request body.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs']]]]):
        pulumi.set(self, "contents", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Determines if the parameter is required in the request.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Validation behavior mode.
        """
        return pulumi.get(self, "validation_mode")

    @validation_mode.setter
    def validation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_mode", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesBodyValidationContentArgs:
    def __init__(__self__, *,
                 media_type: pulumi.Input[str],
                 validation_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] media_type: (Updatable) The media_type is a [media type range](https://tools.ietf.org/html/rfc7231#appendix-D) subset restricted to the following schema
        :param pulumi.Input[str] validation_type: (Updatable) Validation type defines the content validation method.
        """
        pulumi.set(__self__, "media_type", media_type)
        pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The media_type is a [media type range](https://tools.ietf.org/html/rfc7231#appendix-D) subset restricted to the following schema
        """
        return pulumi.get(self, "media_type")

    @media_type.setter
    def media_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "media_type", value)

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Validation type defines the content validation method.
        """
        return pulumi.get(self, "validation_type")

    @validation_type.setter
    def validation_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "validation_type", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesCorsArgs:
    def __init__(__self__, *,
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_allow_credentials_enabled: Optional[pulumi.Input[bool]] = None,
                 max_age_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exposed_headers: (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        :param pulumi.Input[bool] is_allow_credentials_enabled: (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        :param pulumi.Input[int] max_age_in_seconds: (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if exposed_headers is not None:
            pulumi.set(__self__, "exposed_headers", exposed_headers)
        if is_allow_credentials_enabled is not None:
            pulumi.set(__self__, "is_allow_credentials_enabled", is_allow_credentials_enabled)
        if max_age_in_seconds is not None:
            pulumi.set(__self__, "max_age_in_seconds", max_age_in_seconds)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of allowed origins that the CORS handler will use to respond to CORS requests. The gateway will send the Access-Control-Allow-Origin header with the best origin match for the circumstances. '*' will match any origins, and 'null' will match queries from 'file:' origins. All other origins must be qualified with the scheme, full hostname, and port if necessary.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of headers that will be allowed from the client via the Access-Control-Allow-Headers header. '*' will allow all headers.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of allowed HTTP methods that will be returned for the preflight OPTIONS request in the Access-Control-Allow-Methods header. '*' will allow all methods.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of headers that the client will be allowed to see from the response as indicated by the Access-Control-Expose-Headers header. '*' will expose all headers.
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exposed_headers", value)

    @property
    @pulumi.getter(name="isAllowCredentialsEnabled")
    def is_allow_credentials_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to send the Access-Control-Allow-Credentials header to allow CORS requests with cookies.
        """
        return pulumi.get(self, "is_allow_credentials_enabled")

    @is_allow_credentials_enabled.setter
    def is_allow_credentials_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_allow_credentials_enabled", value)

    @property
    @pulumi.getter(name="maxAgeInSeconds")
    def max_age_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The time in seconds for the client to cache preflight responses. This is sent as the Access-Control-Max-Age if greater than 0.
        """
        return pulumi.get(self, "max_age_in_seconds")

    @max_age_in_seconds.setter
    def max_age_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_in_seconds", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsArgs:
    def __init__(__self__, *,
                 filter_headers: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs']] = None,
                 rename_headers: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs']] = None,
                 set_headers: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs'] filter_headers: (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs'] rename_headers: (Updatable) Rename HTTP headers as they pass through the gateway.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs'] set_headers: (Updatable) Set HTTP headers as they pass through the gateway.
        """
        if filter_headers is not None:
            pulumi.set(__self__, "filter_headers", filter_headers)
        if rename_headers is not None:
            pulumi.set(__self__, "rename_headers", rename_headers)
        if set_headers is not None:
            pulumi.set(__self__, "set_headers", set_headers)

    @property
    @pulumi.getter(name="filterHeaders")
    def filter_headers(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs']]:
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_headers")

    @filter_headers.setter
    def filter_headers(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs']]):
        pulumi.set(self, "filter_headers", value)

    @property
    @pulumi.getter(name="renameHeaders")
    def rename_headers(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs']]:
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "rename_headers")

    @rename_headers.setter
    def rename_headers(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs']]):
        pulumi.set(self, "rename_headers", value)

    @property
    @pulumi.getter(name="setHeaders")
    def set_headers(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs']]:
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "set_headers")

    @set_headers.setter
    def set_headers(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs']]):
        pulumi.set(self, "set_headers", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]] items: (Updatable) The list of headers.
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs']]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsFilterHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsRenameHeadersItemArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 to: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_: (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[str] to: (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[str]:
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[str]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderTransformationsSetHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 if_exists: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        :param pulumi.Input[str] if_exists: (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "if_exists", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]]] = None,
                 validation_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]] headers: (Updatable)
        :param pulumi.Input[str] validation_mode: (Updatable) Validation behavior mode.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Validation behavior mode.
        """
        return pulumi.get(self, "validation_mode")

    @validation_mode.setter
    def validation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_mode", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesHeaderValidationsHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[bool] required: (Updatable) Determines if the parameter is required in the request.
        """
        pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Determines if the parameter is required in the request.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsArgs:
    def __init__(__self__, *,
                 filter_query_parameters: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs']] = None,
                 rename_query_parameters: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs']] = None,
                 set_query_parameters: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs'] filter_query_parameters: (Updatable) Filter parameters from the query string as they pass through the gateway.  The gateway applies filters after other transformations, so any parameters set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs'] rename_query_parameters: (Updatable) Rename parameters on the query string as they pass through the gateway.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs'] set_query_parameters: (Updatable) Set parameters on the query string as they pass through the gateway.
        """
        if filter_query_parameters is not None:
            pulumi.set(__self__, "filter_query_parameters", filter_query_parameters)
        if rename_query_parameters is not None:
            pulumi.set(__self__, "rename_query_parameters", rename_query_parameters)
        if set_query_parameters is not None:
            pulumi.set(__self__, "set_query_parameters", set_query_parameters)

    @property
    @pulumi.getter(name="filterQueryParameters")
    def filter_query_parameters(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs']]:
        """
        (Updatable) Filter parameters from the query string as they pass through the gateway.  The gateway applies filters after other transformations, so any parameters set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_query_parameters")

    @filter_query_parameters.setter
    def filter_query_parameters(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs']]):
        pulumi.set(self, "filter_query_parameters", value)

    @property
    @pulumi.getter(name="renameQueryParameters")
    def rename_query_parameters(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs']]:
        """
        (Updatable) Rename parameters on the query string as they pass through the gateway.
        """
        return pulumi.get(self, "rename_query_parameters")

    @rename_query_parameters.setter
    def rename_query_parameters(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs']]):
        pulumi.set(self, "rename_query_parameters", value)

    @property
    @pulumi.getter(name="setQueryParameters")
    def set_query_parameters(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs']]:
        """
        (Updatable) Set parameters on the query string as they pass through the gateway.
        """
        return pulumi.get(self, "set_query_parameters")

    @set_query_parameters.setter
    def set_query_parameters(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs']]):
        pulumi.set(self, "set_query_parameters", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]] items: (Updatable) The list of headers.
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs']]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsFilterQueryParametersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsRenameQueryParametersItemArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 to: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_: (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[str] to: (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[str]:
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[str]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterTransformationsSetQueryParametersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 if_exists: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        :param pulumi.Input[str] if_exists: (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "if_exists", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]]] = None,
                 validation_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]] parameters: (Updatable)
        :param pulumi.Input[str] validation_mode: (Updatable) Validation behavior mode.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if validation_mode is not None:
            pulumi.set(__self__, "validation_mode", validation_mode)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="validationMode")
    def validation_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Validation behavior mode.
        """
        return pulumi.get(self, "validation_mode")

    @validation_mode.setter
    def validation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_mode", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesQueryParameterValidationsParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[bool] required: (Updatable) Determines if the parameter is required in the request.
        """
        pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Determines if the parameter is required in the request.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteRequestPoliciesResponseCacheLookupArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 cache_key_additions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_private_caching_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cache_key_additions: (Updatable) A list of context expressions whose values will be added to the base cache key. Values should contain an expression enclosed within ${} delimiters. Only the request context is available.
        :param pulumi.Input[bool] is_enabled: (Updatable) Whether this policy is currently enabled.
        :param pulumi.Input[bool] is_private_caching_enabled: (Updatable) Set true to allow caching responses where the request has an Authorization header. Ensure you have configured your  cache key additions to get the level of isolation across authenticated requests that you require.
        """
        pulumi.set(__self__, "type", type)
        if cache_key_additions is not None:
            pulumi.set(__self__, "cache_key_additions", cache_key_additions)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_private_caching_enabled is not None:
            pulumi.set(__self__, "is_private_caching_enabled", is_private_caching_enabled)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="cacheKeyAdditions")
    def cache_key_additions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of context expressions whose values will be added to the base cache key. Values should contain an expression enclosed within ${} delimiters. Only the request context is available.
        """
        return pulumi.get(self, "cache_key_additions")

    @cache_key_additions.setter
    def cache_key_additions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cache_key_additions", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether this policy is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isPrivateCachingEnabled")
    def is_private_caching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Set true to allow caching responses where the request has an Authorization header. Ensure you have configured your  cache key additions to get the level of isolation across authenticated requests that you require.
        """
        return pulumi.get(self, "is_private_caching_enabled")

    @is_private_caching_enabled.setter
    def is_private_caching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_private_caching_enabled", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesArgs:
    def __init__(__self__, *,
                 header_transformations: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs']] = None,
                 response_cache_store: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs'] header_transformations: (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs'] response_cache_store: (Updatable) Base policy for how a response from a backend is cached in the Response Cache.
        """
        if header_transformations is not None:
            pulumi.set(__self__, "header_transformations", header_transformations)
        if response_cache_store is not None:
            pulumi.set(__self__, "response_cache_store", response_cache_store)

    @property
    @pulumi.getter(name="headerTransformations")
    def header_transformations(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs']]:
        """
        (Updatable) A set of transformations to apply to HTTP headers that pass through the gateway.
        """
        return pulumi.get(self, "header_transformations")

    @header_transformations.setter
    def header_transformations(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs']]):
        pulumi.set(self, "header_transformations", value)

    @property
    @pulumi.getter(name="responseCacheStore")
    def response_cache_store(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs']]:
        """
        (Updatable) Base policy for how a response from a backend is cached in the Response Cache.
        """
        return pulumi.get(self, "response_cache_store")

    @response_cache_store.setter
    def response_cache_store(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs']]):
        pulumi.set(self, "response_cache_store", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsArgs:
    def __init__(__self__, *,
                 filter_headers: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs']] = None,
                 rename_headers: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs']] = None,
                 set_headers: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs']] = None):
        """
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs'] filter_headers: (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs'] rename_headers: (Updatable) Rename HTTP headers as they pass through the gateway.
        :param pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs'] set_headers: (Updatable) Set HTTP headers as they pass through the gateway.
        """
        if filter_headers is not None:
            pulumi.set(__self__, "filter_headers", filter_headers)
        if rename_headers is not None:
            pulumi.set(__self__, "rename_headers", rename_headers)
        if set_headers is not None:
            pulumi.set(__self__, "set_headers", set_headers)

    @property
    @pulumi.getter(name="filterHeaders")
    def filter_headers(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs']]:
        """
        (Updatable) Filter HTTP headers as they pass through the gateway.  The gateway applies filters after other transformations, so any headers set or renamed must also be listed here when using an ALLOW type policy.
        """
        return pulumi.get(self, "filter_headers")

    @filter_headers.setter
    def filter_headers(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs']]):
        pulumi.set(self, "filter_headers", value)

    @property
    @pulumi.getter(name="renameHeaders")
    def rename_headers(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs']]:
        """
        (Updatable) Rename HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "rename_headers")

    @rename_headers.setter
    def rename_headers(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs']]):
        pulumi.set(self, "rename_headers", value)

    @property
    @pulumi.getter(name="setHeaders")
    def set_headers(self) -> Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs']]:
        """
        (Updatable) Set HTTP headers as they pass through the gateway.
        """
        return pulumi.get(self, "set_headers")

    @set_headers.setter
    def set_headers(self, value: Optional[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs']]):
        pulumi.set(self, "set_headers", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]] items: (Updatable) The list of headers.
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        """
        pulumi.set(__self__, "items", items)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs']]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsFilterHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsRenameHeadersItemArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 to: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_: (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[str] to: (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        (Updatable) The original case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[str]:
        """
        (Updatable) The new name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[str]):
        pulumi.set(self, "to", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]] items: (Updatable) The list of headers.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]]:
        """
        (Updatable) The list of headers.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesHeaderTransformationsSetHeadersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]],
                 if_exists: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        :param pulumi.Input[str] if_exists: (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if if_exists is not None:
            pulumi.set(__self__, "if_exists", if_exists)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter(name="ifExists")
    def if_exists(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If a header with the same name already exists in the request, OVERWRITE will overwrite the value, APPEND will append to the existing value, or SKIP will keep the existing value.
        """
        return pulumi.get(self, "if_exists")

    @if_exists.setter
    def if_exists(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "if_exists", value)


@pulumi.input_type
class ApigatewayDeploymentSpecificationRouteResponsePoliciesResponseCacheStoreArgs:
    def __init__(__self__, *,
                 time_to_live_in_seconds: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] time_to_live_in_seconds: (Updatable) Sets the number of seconds for a response from a backend being stored in the Response Cache before it expires.
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache Store Policy.
        """
        pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> pulumi.Input[int]:
        """
        (Updatable) Sets the number of seconds for a response from a backend being stored in the Response Cache before it expires.
        """
        return pulumi.get(self, "time_to_live_in_seconds")

    @time_to_live_in_seconds.setter
    def time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_to_live_in_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache Store Policy.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApigatewayGatewayIpAddressArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip_address: An IP address.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        An IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)


@pulumi.input_type
class ApigatewayGatewayResponseCacheDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 authentication_secret_id: Optional[pulumi.Input[str]] = None,
                 authentication_secret_version_number: Optional[pulumi.Input[str]] = None,
                 connect_timeout_in_ms: Optional[pulumi.Input[int]] = None,
                 is_ssl_enabled: Optional[pulumi.Input[bool]] = None,
                 is_ssl_verify_disabled: Optional[pulumi.Input[bool]] = None,
                 read_timeout_in_ms: Optional[pulumi.Input[int]] = None,
                 send_timeout_in_ms: Optional[pulumi.Input[int]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayGatewayResponseCacheDetailsServerArgs']]]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) Type of the Response Cache.
        :param pulumi.Input[str] authentication_secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        :param pulumi.Input[str] authentication_secret_version_number: (Updatable) The version number of the authentication secret to use.
        :param pulumi.Input[int] connect_timeout_in_ms: (Updatable) Defines the timeout for establishing a connection with the Response Cache.
        :param pulumi.Input[bool] is_ssl_enabled: (Updatable) Defines if the connection should be over SSL.
        :param pulumi.Input[bool] is_ssl_verify_disabled: (Updatable) Defines whether or not to uphold SSL verification.
        :param pulumi.Input[int] read_timeout_in_ms: (Updatable) Defines the timeout for reading data from the Response Cache.
        :param pulumi.Input[int] send_timeout_in_ms: (Updatable) Defines the timeout for transmitting data to the Response Cache.
        :param pulumi.Input[Sequence[pulumi.Input['ApigatewayGatewayResponseCacheDetailsServerArgs']]] servers: (Updatable) The set of cache store members to connect to. At present only a single server is supported.
        """
        pulumi.set(__self__, "type", type)
        if authentication_secret_id is not None:
            pulumi.set(__self__, "authentication_secret_id", authentication_secret_id)
        if authentication_secret_version_number is not None:
            pulumi.set(__self__, "authentication_secret_version_number", authentication_secret_version_number)
        if connect_timeout_in_ms is not None:
            pulumi.set(__self__, "connect_timeout_in_ms", connect_timeout_in_ms)
        if is_ssl_enabled is not None:
            pulumi.set(__self__, "is_ssl_enabled", is_ssl_enabled)
        if is_ssl_verify_disabled is not None:
            pulumi.set(__self__, "is_ssl_verify_disabled", is_ssl_verify_disabled)
        if read_timeout_in_ms is not None:
            pulumi.set(__self__, "read_timeout_in_ms", read_timeout_in_ms)
        if send_timeout_in_ms is not None:
            pulumi.set(__self__, "send_timeout_in_ms", send_timeout_in_ms)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of the Response Cache.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="authenticationSecretId")
    def authentication_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Vault Service secret resource.
        """
        return pulumi.get(self, "authentication_secret_id")

    @authentication_secret_id.setter
    def authentication_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_secret_id", value)

    @property
    @pulumi.getter(name="authenticationSecretVersionNumber")
    def authentication_secret_version_number(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The version number of the authentication secret to use.
        """
        return pulumi.get(self, "authentication_secret_version_number")

    @authentication_secret_version_number.setter
    def authentication_secret_version_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authentication_secret_version_number", value)

    @property
    @pulumi.getter(name="connectTimeoutInMs")
    def connect_timeout_in_ms(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines the timeout for establishing a connection with the Response Cache.
        """
        return pulumi.get(self, "connect_timeout_in_ms")

    @connect_timeout_in_ms.setter
    def connect_timeout_in_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "connect_timeout_in_ms", value)

    @property
    @pulumi.getter(name="isSslEnabled")
    def is_ssl_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Defines if the connection should be over SSL.
        """
        return pulumi.get(self, "is_ssl_enabled")

    @is_ssl_enabled.setter
    def is_ssl_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ssl_enabled", value)

    @property
    @pulumi.getter(name="isSslVerifyDisabled")
    def is_ssl_verify_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Defines whether or not to uphold SSL verification.
        """
        return pulumi.get(self, "is_ssl_verify_disabled")

    @is_ssl_verify_disabled.setter
    def is_ssl_verify_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_ssl_verify_disabled", value)

    @property
    @pulumi.getter(name="readTimeoutInMs")
    def read_timeout_in_ms(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines the timeout for reading data from the Response Cache.
        """
        return pulumi.get(self, "read_timeout_in_ms")

    @read_timeout_in_ms.setter
    def read_timeout_in_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_timeout_in_ms", value)

    @property
    @pulumi.getter(name="sendTimeoutInMs")
    def send_timeout_in_ms(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines the timeout for transmitting data to the Response Cache.
        """
        return pulumi.get(self, "send_timeout_in_ms")

    @send_timeout_in_ms.setter
    def send_timeout_in_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "send_timeout_in_ms", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayGatewayResponseCacheDetailsServerArgs']]]]:
        """
        (Updatable) The set of cache store members to connect to. At present only a single server is supported.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApigatewayGatewayResponseCacheDetailsServerArgs']]]]):
        pulumi.set(self, "servers", value)


@pulumi.input_type
class ApigatewayGatewayResponseCacheDetailsServerArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: (Updatable) Hostname or IP address (IPv4 only) where the cache store is running.
        :param pulumi.Input[int] port: (Updatable) The port the cache store is exposed on.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Hostname or IP address (IPv4 only) where the cache store is running.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The port the cache store is exposed on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class ApmSyntheticsMonitorConfigurationArgs:
    def __init__(__self__, *,
                 config_type: Optional[pulumi.Input[str]] = None,
                 is_certificate_validation_enabled: Optional[pulumi.Input[bool]] = None,
                 is_failure_retried: Optional[pulumi.Input[bool]] = None,
                 is_redirection_enabled: Optional[pulumi.Input[bool]] = None,
                 req_authentication_details: Optional[pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsArgs']] = None,
                 req_authentication_scheme: Optional[pulumi.Input[str]] = None,
                 request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestHeaderArgs']]]] = None,
                 request_method: Optional[pulumi.Input[str]] = None,
                 request_post_body: Optional[pulumi.Input[str]] = None,
                 request_query_params: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestQueryParamArgs']]]] = None,
                 verify_response_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verify_response_content: Optional[pulumi.Input[str]] = None,
                 verify_texts: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationVerifyTextArgs']]]] = None):
        """
        :param pulumi.Input[str] config_type: (Updatable) Type of configuration.
        :param pulumi.Input[bool] is_certificate_validation_enabled: (Updatable) If certificate validation is enabled, then the call will fail in case of certification errors.
        :param pulumi.Input[bool] is_failure_retried: (Updatable) If isFailureRetried is enabled, then a failed call will be retried.
        :param pulumi.Input[bool] is_redirection_enabled: (Updatable) If redirection enabled, then redirects will be allowed while accessing target URL.
        :param pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsArgs'] req_authentication_details: (Updatable) Details for request HTTP authentication.
        :param pulumi.Input[str] req_authentication_scheme: (Updatable) Request http authentication scheme.
        :param pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestHeaderArgs']]] request_headers: (Updatable) List of request headers. Example: `[{"headerName": "content-type", "headerValue":"json"}]`
        :param pulumi.Input[str] request_method: (Updatable) Request HTTP method.
        :param pulumi.Input[str] request_post_body: (Updatable) Request post body content.
        :param pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestQueryParamArgs']]] request_query_params: (Updatable) List of request query params. Example: `[{"paramName": "sortOrder", "paramValue": "asc"}]`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] verify_response_codes: (Updatable) Expected HTTP response codes. For status code range, set values such as 2xx, 3xx.
        :param pulumi.Input[str] verify_response_content: (Updatable) Verify response content against regular expression based string. If response content does not match the verifyResponseContent value, then it will be considered a failure.
        :param pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationVerifyTextArgs']]] verify_texts: (Updatable) Verify all the search strings present in response. If any search string is not present in the response, then it will be considered as a failure.
        """
        if config_type is not None:
            pulumi.set(__self__, "config_type", config_type)
        if is_certificate_validation_enabled is not None:
            pulumi.set(__self__, "is_certificate_validation_enabled", is_certificate_validation_enabled)
        if is_failure_retried is not None:
            pulumi.set(__self__, "is_failure_retried", is_failure_retried)
        if is_redirection_enabled is not None:
            pulumi.set(__self__, "is_redirection_enabled", is_redirection_enabled)
        if req_authentication_details is not None:
            pulumi.set(__self__, "req_authentication_details", req_authentication_details)
        if req_authentication_scheme is not None:
            pulumi.set(__self__, "req_authentication_scheme", req_authentication_scheme)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if request_post_body is not None:
            pulumi.set(__self__, "request_post_body", request_post_body)
        if request_query_params is not None:
            pulumi.set(__self__, "request_query_params", request_query_params)
        if verify_response_codes is not None:
            pulumi.set(__self__, "verify_response_codes", verify_response_codes)
        if verify_response_content is not None:
            pulumi.set(__self__, "verify_response_content", verify_response_content)
        if verify_texts is not None:
            pulumi.set(__self__, "verify_texts", verify_texts)

    @property
    @pulumi.getter(name="configType")
    def config_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of configuration.
        """
        return pulumi.get(self, "config_type")

    @config_type.setter
    def config_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_type", value)

    @property
    @pulumi.getter(name="isCertificateValidationEnabled")
    def is_certificate_validation_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If certificate validation is enabled, then the call will fail in case of certification errors.
        """
        return pulumi.get(self, "is_certificate_validation_enabled")

    @is_certificate_validation_enabled.setter
    def is_certificate_validation_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_certificate_validation_enabled", value)

    @property
    @pulumi.getter(name="isFailureRetried")
    def is_failure_retried(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If isFailureRetried is enabled, then a failed call will be retried.
        """
        return pulumi.get(self, "is_failure_retried")

    @is_failure_retried.setter
    def is_failure_retried(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_failure_retried", value)

    @property
    @pulumi.getter(name="isRedirectionEnabled")
    def is_redirection_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If redirection enabled, then redirects will be allowed while accessing target URL.
        """
        return pulumi.get(self, "is_redirection_enabled")

    @is_redirection_enabled.setter
    def is_redirection_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_redirection_enabled", value)

    @property
    @pulumi.getter(name="reqAuthenticationDetails")
    def req_authentication_details(self) -> Optional[pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsArgs']]:
        """
        (Updatable) Details for request HTTP authentication.
        """
        return pulumi.get(self, "req_authentication_details")

    @req_authentication_details.setter
    def req_authentication_details(self, value: Optional[pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsArgs']]):
        pulumi.set(self, "req_authentication_details", value)

    @property
    @pulumi.getter(name="reqAuthenticationScheme")
    def req_authentication_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Request http authentication scheme.
        """
        return pulumi.get(self, "req_authentication_scheme")

    @req_authentication_scheme.setter
    def req_authentication_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "req_authentication_scheme", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestHeaderArgs']]]]:
        """
        (Updatable) List of request headers. Example: `[{"headerName": "content-type", "headerValue":"json"}]`
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestHeaderArgs']]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Request HTTP method.
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="requestPostBody")
    def request_post_body(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Request post body content.
        """
        return pulumi.get(self, "request_post_body")

    @request_post_body.setter
    def request_post_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_post_body", value)

    @property
    @pulumi.getter(name="requestQueryParams")
    def request_query_params(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestQueryParamArgs']]]]:
        """
        (Updatable) List of request query params. Example: `[{"paramName": "sortOrder", "paramValue": "asc"}]`
        """
        return pulumi.get(self, "request_query_params")

    @request_query_params.setter
    def request_query_params(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationRequestQueryParamArgs']]]]):
        pulumi.set(self, "request_query_params", value)

    @property
    @pulumi.getter(name="verifyResponseCodes")
    def verify_response_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Expected HTTP response codes. For status code range, set values such as 2xx, 3xx.
        """
        return pulumi.get(self, "verify_response_codes")

    @verify_response_codes.setter
    def verify_response_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verify_response_codes", value)

    @property
    @pulumi.getter(name="verifyResponseContent")
    def verify_response_content(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Verify response content against regular expression based string. If response content does not match the verifyResponseContent value, then it will be considered a failure.
        """
        return pulumi.get(self, "verify_response_content")

    @verify_response_content.setter
    def verify_response_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "verify_response_content", value)

    @property
    @pulumi.getter(name="verifyTexts")
    def verify_texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationVerifyTextArgs']]]]:
        """
        (Updatable) Verify all the search strings present in response. If any search string is not present in the response, then it will be considered as a failure.
        """
        return pulumi.get(self, "verify_texts")

    @verify_texts.setter
    def verify_texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationVerifyTextArgs']]]]):
        pulumi.set(self, "verify_texts", value)


@pulumi.input_type
class ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsArgs:
    def __init__(__self__, *,
                 auth_headers: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsAuthHeaderArgs']]]] = None,
                 auth_request_method: Optional[pulumi.Input[str]] = None,
                 auth_request_post_body: Optional[pulumi.Input[str]] = None,
                 auth_token: Optional[pulumi.Input[str]] = None,
                 auth_url: Optional[pulumi.Input[str]] = None,
                 auth_user_name: Optional[pulumi.Input[str]] = None,
                 auth_user_password: Optional[pulumi.Input[str]] = None,
                 oauth_scheme: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsAuthHeaderArgs']]] auth_headers: (Updatable) List of authentication headers. Example: `[{"headerName": "content-type", "headerValue":"json"}]`
        :param pulumi.Input[str] auth_request_method: (Updatable) Request method.
        :param pulumi.Input[str] auth_request_post_body: (Updatable) Request post body.
        :param pulumi.Input[str] auth_token: (Updatable) Authentication token.
        :param pulumi.Input[str] auth_url: (Updatable) URL to get authetication token.
        :param pulumi.Input[str] auth_user_name: (Updatable) Username for authentication.
        :param pulumi.Input[str] auth_user_password: (Updatable) User password for authentication.
        :param pulumi.Input[str] oauth_scheme: (Updatable) Request http oauth scheme.
        """
        if auth_headers is not None:
            pulumi.set(__self__, "auth_headers", auth_headers)
        if auth_request_method is not None:
            pulumi.set(__self__, "auth_request_method", auth_request_method)
        if auth_request_post_body is not None:
            pulumi.set(__self__, "auth_request_post_body", auth_request_post_body)
        if auth_token is not None:
            pulumi.set(__self__, "auth_token", auth_token)
        if auth_url is not None:
            pulumi.set(__self__, "auth_url", auth_url)
        if auth_user_name is not None:
            pulumi.set(__self__, "auth_user_name", auth_user_name)
        if auth_user_password is not None:
            pulumi.set(__self__, "auth_user_password", auth_user_password)
        if oauth_scheme is not None:
            pulumi.set(__self__, "oauth_scheme", oauth_scheme)

    @property
    @pulumi.getter(name="authHeaders")
    def auth_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsAuthHeaderArgs']]]]:
        """
        (Updatable) List of authentication headers. Example: `[{"headerName": "content-type", "headerValue":"json"}]`
        """
        return pulumi.get(self, "auth_headers")

    @auth_headers.setter
    def auth_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsAuthHeaderArgs']]]]):
        pulumi.set(self, "auth_headers", value)

    @property
    @pulumi.getter(name="authRequestMethod")
    def auth_request_method(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Request method.
        """
        return pulumi.get(self, "auth_request_method")

    @auth_request_method.setter
    def auth_request_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_request_method", value)

    @property
    @pulumi.getter(name="authRequestPostBody")
    def auth_request_post_body(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Request post body.
        """
        return pulumi.get(self, "auth_request_post_body")

    @auth_request_post_body.setter
    def auth_request_post_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_request_post_body", value)

    @property
    @pulumi.getter(name="authToken")
    def auth_token(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Authentication token.
        """
        return pulumi.get(self, "auth_token")

    @auth_token.setter
    def auth_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_token", value)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) URL to get authetication token.
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="authUserName")
    def auth_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Username for authentication.
        """
        return pulumi.get(self, "auth_user_name")

    @auth_user_name.setter
    def auth_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_user_name", value)

    @property
    @pulumi.getter(name="authUserPassword")
    def auth_user_password(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) User password for authentication.
        """
        return pulumi.get(self, "auth_user_password")

    @auth_user_password.setter
    def auth_user_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_user_password", value)

    @property
    @pulumi.getter(name="oauthScheme")
    def oauth_scheme(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Request http oauth scheme.
        """
        return pulumi.get(self, "oauth_scheme")

    @oauth_scheme.setter
    def oauth_scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oauth_scheme", value)


@pulumi.input_type
class ApmSyntheticsMonitorConfigurationReqAuthenticationDetailsAuthHeaderArgs:
    def __init__(__self__, *,
                 header_name: Optional[pulumi.Input[str]] = None,
                 header_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_name: (Updatable) Name of the header.
        :param pulumi.Input[str] header_value: (Updatable) Value of the header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the header.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the header.
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_value", value)


@pulumi.input_type
class ApmSyntheticsMonitorConfigurationRequestHeaderArgs:
    def __init__(__self__, *,
                 header_name: Optional[pulumi.Input[str]] = None,
                 header_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] header_name: (Updatable) Name of the header.
        :param pulumi.Input[str] header_value: (Updatable) Value of the header.
        """
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the header.
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_name", value)

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the header.
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_value", value)


@pulumi.input_type
class ApmSyntheticsMonitorConfigurationRequestQueryParamArgs:
    def __init__(__self__, *,
                 param_name: Optional[pulumi.Input[str]] = None,
                 param_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] param_name: (Updatable) Name of the parameter.
        :param pulumi.Input[str] param_value: (Updatable) Value of the parameter.
        """
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if param_value is not None:
            pulumi.set(__self__, "param_value", param_value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the parameter.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the parameter.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "param_value", value)


@pulumi.input_type
class ApmSyntheticsMonitorConfigurationVerifyTextArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] text: (Updatable) Verification text in the response.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Verification text in the response.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)


@pulumi.input_type
class ApmSyntheticsMonitorScriptParameterArgs:
    def __init__(__self__, *,
                 param_name: pulumi.Input[str],
                 param_value: pulumi.Input[str],
                 is_overwritten: Optional[pulumi.Input[bool]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 monitor_script_parameter: Optional[pulumi.Input['ApmSyntheticsMonitorScriptParameterMonitorScriptParameterArgs']] = None):
        """
        :param pulumi.Input[str] param_name: (Updatable) Name of the parameter.
        :param pulumi.Input[str] param_value: (Updatable) Value of the parameter.
        :param pulumi.Input[bool] is_overwritten: If parameter value is default or overwritten.
        :param pulumi.Input[bool] is_secret: Describes if  the parameter value is secret and should be kept confidential. isSecret is specified in either CreateScript or UpdateScript API.
        :param pulumi.Input['ApmSyntheticsMonitorScriptParameterMonitorScriptParameterArgs'] monitor_script_parameter: Details of the script parameter that can be used to overwrite the parameter present in the script.
        """
        pulumi.set(__self__, "param_name", param_name)
        pulumi.set(__self__, "param_value", param_value)
        if is_overwritten is not None:
            pulumi.set(__self__, "is_overwritten", is_overwritten)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if monitor_script_parameter is not None:
            pulumi.set(__self__, "monitor_script_parameter", monitor_script_parameter)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the parameter.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> pulumi.Input[str]:
        """
        (Updatable) Value of the parameter.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "param_value", value)

    @property
    @pulumi.getter(name="isOverwritten")
    def is_overwritten(self) -> Optional[pulumi.Input[bool]]:
        """
        If parameter value is default or overwritten.
        """
        return pulumi.get(self, "is_overwritten")

    @is_overwritten.setter
    def is_overwritten(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_overwritten", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        Describes if  the parameter value is secret and should be kept confidential. isSecret is specified in either CreateScript or UpdateScript API.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="monitorScriptParameter")
    def monitor_script_parameter(self) -> Optional[pulumi.Input['ApmSyntheticsMonitorScriptParameterMonitorScriptParameterArgs']]:
        """
        Details of the script parameter that can be used to overwrite the parameter present in the script.
        """
        return pulumi.get(self, "monitor_script_parameter")

    @monitor_script_parameter.setter
    def monitor_script_parameter(self, value: Optional[pulumi.Input['ApmSyntheticsMonitorScriptParameterMonitorScriptParameterArgs']]):
        pulumi.set(self, "monitor_script_parameter", value)


@pulumi.input_type
class ApmSyntheticsMonitorScriptParameterMonitorScriptParameterArgs:
    def __init__(__self__, *,
                 param_name: Optional[pulumi.Input[str]] = None,
                 param_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] param_name: (Updatable) Name of the parameter.
        :param pulumi.Input[str] param_value: (Updatable) Value of the parameter.
        """
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if param_value is not None:
            pulumi.set(__self__, "param_value", param_value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the parameter.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the parameter.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "param_value", value)


@pulumi.input_type
class ApmSyntheticsScriptMonitorStatusCountMapArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[int]] = None,
                 invalid: Optional[pulumi.Input[int]] = None,
                 total: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] disabled: Number of disabled monitors using the script.
        :param pulumi.Input[int] enabled: Number of enabled monitors using the script.
        :param pulumi.Input[int] invalid: Number of invalid monitors using the script.
        :param pulumi.Input[int] total: Total number of monitors using the script.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if invalid is not None:
            pulumi.set(__self__, "invalid", invalid)
        if total is not None:
            pulumi.set(__self__, "total", total)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[int]]:
        """
        Number of disabled monitors using the script.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[int]]:
        """
        Number of enabled monitors using the script.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def invalid(self) -> Optional[pulumi.Input[int]]:
        """
        Number of invalid monitors using the script.
        """
        return pulumi.get(self, "invalid")

    @invalid.setter
    def invalid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "invalid", value)

    @property
    @pulumi.getter
    def total(self) -> Optional[pulumi.Input[int]]:
        """
        Total number of monitors using the script.
        """
        return pulumi.get(self, "total")

    @total.setter
    def total(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total", value)


@pulumi.input_type
class ApmSyntheticsScriptParameterArgs:
    def __init__(__self__, *,
                 param_name: pulumi.Input[str],
                 is_overwritten: Optional[pulumi.Input[bool]] = None,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 param_value: Optional[pulumi.Input[str]] = None,
                 script_parameter: Optional[pulumi.Input['ApmSyntheticsScriptParameterScriptParameterArgs']] = None):
        """
        :param pulumi.Input[str] param_name: (Updatable) Name of the parameter.
        :param pulumi.Input[bool] is_overwritten: If parameter value is default or overwritten.
        :param pulumi.Input[bool] is_secret: (Updatable) If the parameter value is secret and should be kept confidential, then set isSecret to true.
        :param pulumi.Input[str] param_value: (Updatable) Value of the parameter.
        :param pulumi.Input['ApmSyntheticsScriptParameterScriptParameterArgs'] script_parameter: Details of the script parameters, paramName must be from the script content and these details can be used to overwrite the default parameter present in the script content.
        """
        pulumi.set(__self__, "param_name", param_name)
        if is_overwritten is not None:
            pulumi.set(__self__, "is_overwritten", is_overwritten)
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if param_value is not None:
            pulumi.set(__self__, "param_value", param_value)
        if script_parameter is not None:
            pulumi.set(__self__, "script_parameter", script_parameter)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the parameter.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter(name="isOverwritten")
    def is_overwritten(self) -> Optional[pulumi.Input[bool]]:
        """
        If parameter value is default or overwritten.
        """
        return pulumi.get(self, "is_overwritten")

    @is_overwritten.setter
    def is_overwritten(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_overwritten", value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If the parameter value is secret and should be kept confidential, then set isSecret to true.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the parameter.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "param_value", value)

    @property
    @pulumi.getter(name="scriptParameter")
    def script_parameter(self) -> Optional[pulumi.Input['ApmSyntheticsScriptParameterScriptParameterArgs']]:
        """
        Details of the script parameters, paramName must be from the script content and these details can be used to overwrite the default parameter present in the script content.
        """
        return pulumi.get(self, "script_parameter")

    @script_parameter.setter
    def script_parameter(self, value: Optional[pulumi.Input['ApmSyntheticsScriptParameterScriptParameterArgs']]):
        pulumi.set(self, "script_parameter", value)


@pulumi.input_type
class ApmSyntheticsScriptParameterScriptParameterArgs:
    def __init__(__self__, *,
                 is_secret: Optional[pulumi.Input[bool]] = None,
                 param_name: Optional[pulumi.Input[str]] = None,
                 param_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_secret: (Updatable) If the parameter value is secret and should be kept confidential, then set isSecret to true.
        :param pulumi.Input[str] param_name: (Updatable) Name of the parameter.
        :param pulumi.Input[str] param_value: (Updatable) Value of the parameter.
        """
        if is_secret is not None:
            pulumi.set(__self__, "is_secret", is_secret)
        if param_name is not None:
            pulumi.set(__self__, "param_name", param_name)
        if param_value is not None:
            pulumi.set(__self__, "param_value", param_value)

    @property
    @pulumi.getter(name="isSecret")
    def is_secret(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If the parameter value is secret and should be kept confidential, then set isSecret to true.
        """
        return pulumi.get(self, "is_secret")

    @is_secret.setter
    def is_secret(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secret", value)

    @property
    @pulumi.getter(name="paramName")
    def param_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the parameter.
        """
        return pulumi.get(self, "param_name")

    @param_name.setter
    def param_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "param_name", value)

    @property
    @pulumi.getter(name="paramValue")
    def param_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of the parameter.
        """
        return pulumi.get(self, "param_value")

    @param_value.setter
    def param_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "param_value", value)


@pulumi.input_type
class ArtifactsContainerRepositoryReadmeArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 format: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: (Updatable) Readme content. Avoid entering confidential information.
        :param pulumi.Input[str] format: (Updatable) Readme format. Supported formats are text/plain and text/markdown.
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "format", format)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        (Updatable) Readme content. Avoid entering confidential information.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        (Updatable) Readme format. Supported formats are text/plain and text/markdown.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationAutoScalingResourcesArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is managed by the autoscaling configuration.
        :param pulumi.Input[str] type: The type of action to take.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is managed by the autoscaling configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to take.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyArgs:
    def __init__(__self__, *,
                 policy_type: pulumi.Input[str],
                 capacity: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyCapacityArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 execution_schedule: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyExecutionScheduleArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 resource_action: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyResourceActionArgs']] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleArgs']]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy_type: The type of autoscaling policy.
        :param pulumi.Input['AutoscalingAutoScalingConfigurationPolicyCapacityArgs'] capacity: The capacity requirements of the autoscaling policy.
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input['AutoscalingAutoScalingConfigurationPolicyExecutionScheduleArgs'] execution_schedule: An execution schedule for an autoscaling policy.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is managed by the autoscaling configuration.
        :param pulumi.Input[bool] is_enabled: Whether the autoscaling policy is enabled.
        :param pulumi.Input['AutoscalingAutoScalingConfigurationPolicyResourceActionArgs'] resource_action: An action that can be executed against a resource.
        :param pulumi.Input[str] time_created: The date and time the autoscaling configuration was created, in the format defined by RFC3339.  Example: `2016-08-25T21:10:29.600Z`
        """
        pulumi.set(__self__, "policy_type", policy_type)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if execution_schedule is not None:
            pulumi.set(__self__, "execution_schedule", execution_schedule)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if resource_action is not None:
            pulumi.set(__self__, "resource_action", resource_action)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[str]:
        """
        The type of autoscaling policy.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_type", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyCapacityArgs']]:
        """
        The capacity requirements of the autoscaling policy.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyCapacityArgs']]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="executionSchedule")
    def execution_schedule(self) -> Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyExecutionScheduleArgs']]:
        """
        An execution schedule for an autoscaling policy.
        """
        return pulumi.get(self, "execution_schedule")

    @execution_schedule.setter
    def execution_schedule(self, value: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyExecutionScheduleArgs']]):
        pulumi.set(self, "execution_schedule", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is managed by the autoscaling configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the autoscaling policy is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="resourceAction")
    def resource_action(self) -> Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyResourceActionArgs']]:
        """
        An action that can be executed against a resource.
        """
        return pulumi.get(self, "resource_action")

    @resource_action.setter
    def resource_action(self, value: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyResourceActionArgs']]):
        pulumi.set(self, "resource_action", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the autoscaling configuration was created, in the format defined by RFC3339.  Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyCapacityArgs:
    def __init__(__self__, *,
                 initial: Optional[pulumi.Input[int]] = None,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] initial: For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the instance pool immediately after autoscaling is enabled. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        :param pulumi.Input[int] max: For a threshold-based autoscaling policy, this value is the maximum number of instances the instance pool is allowed to increase to (scale out).
        :param pulumi.Input[int] min: For a threshold-based autoscaling policy, this value is the minimum number of instances the instance pool is allowed to decrease to (scale in).
        """
        if initial is not None:
            pulumi.set(__self__, "initial", initial)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def initial(self) -> Optional[pulumi.Input[int]]:
        """
        For a threshold-based autoscaling policy, this value is the initial number of instances to launch in the instance pool immediately after autoscaling is enabled. After autoscaling retrieves performance metrics, the number of instances is automatically adjusted from this initial number to a number that is based on the limits that you set.
        """
        return pulumi.get(self, "initial")

    @initial.setter
    def initial(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        For a threshold-based autoscaling policy, this value is the maximum number of instances the instance pool is allowed to increase to (scale out).
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        For a threshold-based autoscaling policy, this value is the minimum number of instances the instance pool is allowed to decrease to (scale in).
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyExecutionScheduleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 timezone: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A cron expression that represents the time at which to execute the autoscaling policy.
        :param pulumi.Input[str] timezone: The time zone for the execution schedule.
        :param pulumi.Input[str] type: The type of action to take.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "timezone", timezone)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A cron expression that represents the time at which to execute the autoscaling policy.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def timezone(self) -> pulumi.Input[str]:
        """
        The time zone for the execution schedule.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to take.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyResourceActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 action_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action: The action to take when autoscaling is triggered.
        :param pulumi.Input[str] action_type: The type of resource action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "action_type", action_type)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take when autoscaling is triggered.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        The type of resource action.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyRuleArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 action: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleActionArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleMetricArgs']] = None):
        """
        :param pulumi.Input[str] display_name: A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        :param pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleActionArgs'] action: The action to take when autoscaling is triggered.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is managed by the autoscaling configuration.
        :param pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleMetricArgs'] metric: Metric and threshold details for triggering an autoscaling action.
        """
        pulumi.set(__self__, "display_name", display_name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleActionArgs']]:
        """
        The action to take when autoscaling is triggered.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleActionArgs']]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the resource that is managed by the autoscaling configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleMetricArgs']]:
        """
        Metric and threshold details for triggering an autoscaling action.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleMetricArgs']]):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyRuleActionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: The type of action to take.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of action to take.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyRuleMetricArgs:
    def __init__(__self__, *,
                 metric_type: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleMetricThresholdArgs']] = None):
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_type", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleMetricThresholdArgs']]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['AutoscalingAutoScalingConfigurationPolicyRuleMetricThresholdArgs']]):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class AutoscalingAutoScalingConfigurationPolicyRuleMetricThresholdArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] operator: The comparison operator to use. Options are greater than (`GT`), greater than or equal to (`GTE`), less than (`LT`), and less than or equal to (`LTE`).
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The comparison operator to use. Options are greater than (`GT`), greater than or equal to (`GTE`), less than (`LT`), and less than or equal to (`LTE`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BastionSessionKeyDetailsArgs:
    def __init__(__self__, *,
                 public_key_content: pulumi.Input[str]):
        """
        :param pulumi.Input[str] public_key_content: The public key in OpenSSH format of the SSH key pair for the session. When you connect to the session, you must provide the private key of the same SSH key pair.
        """
        pulumi.set(__self__, "public_key_content", public_key_content)

    @property
    @pulumi.getter(name="publicKeyContent")
    def public_key_content(self) -> pulumi.Input[str]:
        """
        The public key in OpenSSH format of the SSH key pair for the session. When you connect to the session, you must provide the private key of the same SSH key pair.
        """
        return pulumi.get(self, "public_key_content")

    @public_key_content.setter
    def public_key_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key_content", value)


@pulumi.input_type
class BastionSessionTargetResourceDetailsArgs:
    def __init__(__self__, *,
                 session_type: pulumi.Input[str],
                 target_resource_id: pulumi.Input[str],
                 target_resource_display_name: Optional[pulumi.Input[str]] = None,
                 target_resource_operating_system_user_name: Optional[pulumi.Input[str]] = None,
                 target_resource_port: Optional[pulumi.Input[int]] = None,
                 target_resource_private_ip_address: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] session_type: The session type.
        :param pulumi.Input[str] target_resource_id: The unique identifier (OCID) of the target resource (a Compute instance, for example) that the session connects to.
        :param pulumi.Input[str] target_resource_display_name: The display name of the target Compute instance that the session connects to.
        :param pulumi.Input[str] target_resource_operating_system_user_name: The name of the user on the target resource operating system that the session uses for the connection.
        :param pulumi.Input[int] target_resource_port: The port number to connect to on the target resource.
        :param pulumi.Input[str] target_resource_private_ip_address: The private IP address of the target resource that the session connects to.
        """
        pulumi.set(__self__, "session_type", session_type)
        pulumi.set(__self__, "target_resource_id", target_resource_id)
        if target_resource_display_name is not None:
            pulumi.set(__self__, "target_resource_display_name", target_resource_display_name)
        if target_resource_operating_system_user_name is not None:
            pulumi.set(__self__, "target_resource_operating_system_user_name", target_resource_operating_system_user_name)
        if target_resource_port is not None:
            pulumi.set(__self__, "target_resource_port", target_resource_port)
        if target_resource_private_ip_address is not None:
            pulumi.set(__self__, "target_resource_private_ip_address", target_resource_private_ip_address)

    @property
    @pulumi.getter(name="sessionType")
    def session_type(self) -> pulumi.Input[str]:
        """
        The session type.
        """
        return pulumi.get(self, "session_type")

    @session_type.setter
    def session_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "session_type", value)

    @property
    @pulumi.getter(name="targetResourceId")
    def target_resource_id(self) -> pulumi.Input[str]:
        """
        The unique identifier (OCID) of the target resource (a Compute instance, for example) that the session connects to.
        """
        return pulumi.get(self, "target_resource_id")

    @target_resource_id.setter
    def target_resource_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_resource_id", value)

    @property
    @pulumi.getter(name="targetResourceDisplayName")
    def target_resource_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the target Compute instance that the session connects to.
        """
        return pulumi.get(self, "target_resource_display_name")

    @target_resource_display_name.setter
    def target_resource_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_resource_display_name", value)

    @property
    @pulumi.getter(name="targetResourceOperatingSystemUserName")
    def target_resource_operating_system_user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user on the target resource operating system that the session uses for the connection.
        """
        return pulumi.get(self, "target_resource_operating_system_user_name")

    @target_resource_operating_system_user_name.setter
    def target_resource_operating_system_user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_resource_operating_system_user_name", value)

    @property
    @pulumi.getter(name="targetResourcePort")
    def target_resource_port(self) -> Optional[pulumi.Input[int]]:
        """
        The port number to connect to on the target resource.
        """
        return pulumi.get(self, "target_resource_port")

    @target_resource_port.setter
    def target_resource_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_resource_port", value)

    @property
    @pulumi.getter(name="targetResourcePrivateIpAddress")
    def target_resource_private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The private IP address of the target resource that the session connects to.
        """
        return pulumi.get(self, "target_resource_private_ip_address")

    @target_resource_private_ip_address.setter
    def target_resource_private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_resource_private_ip_address", value)


@pulumi.input_type
class BdsAutoScalingConfigurationPolicyArgs:
    def __init__(__self__, *,
                 policy_type: pulumi.Input[str],
                 rules: pulumi.Input[Sequence[pulumi.Input['BdsAutoScalingConfigurationPolicyRuleArgs']]]):
        """
        :param pulumi.Input[str] policy_type: (Updatable) Types of autoscale policies. Options are SCHEDULE-BASED or THRESHOLD-BASED. (Only THRESHOLD-BASED is supported in this release.)
        :param pulumi.Input[Sequence[pulumi.Input['BdsAutoScalingConfigurationPolicyRuleArgs']]] rules: (Updatable) The list of rules for autoscaling. If an action has multiple rules, the last rule in the array will be applied.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Types of autoscale policies. Options are SCHEDULE-BASED or THRESHOLD-BASED. (Only THRESHOLD-BASED is supported in this release.)
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_type", value)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BdsAutoScalingConfigurationPolicyRuleArgs']]]:
        """
        (Updatable) The list of rules for autoscaling. If an action has multiple rules, the last rule in the array will be applied.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BdsAutoScalingConfigurationPolicyRuleArgs']]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class BdsAutoScalingConfigurationPolicyRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 metric: pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricArgs']):
        """
        :param pulumi.Input[str] action: (Updatable) The valid value are CHANGE_SHAPE_SCALE_UP or CHANGE_SHAPE_SCALE_DOWN.
        :param pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricArgs'] metric: (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        (Updatable) The valid value are CHANGE_SHAPE_SCALE_UP or CHANGE_SHAPE_SCALE_DOWN.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricArgs']:
        """
        (Updatable) Metric and threshold details for triggering an autoscale action.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricArgs']):
        pulumi.set(self, "metric", value)


@pulumi.input_type
class BdsAutoScalingConfigurationPolicyRuleMetricArgs:
    def __init__(__self__, *,
                 metric_type: pulumi.Input[str],
                 threshold: pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricThresholdArgs']):
        """
        :param pulumi.Input[str] metric_type: (Updatable) Allowed value is CPU_UTILIZATION.
        :param pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricThresholdArgs'] threshold: (Updatable) An autoscale action is triggered when a performance metric meets or exceeds a threshold.
        """
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Allowed value is CPU_UTILIZATION.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_type", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricThresholdArgs']:
        """
        (Updatable) An autoscale action is triggered when a performance metric meets or exceeds a threshold.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input['BdsAutoScalingConfigurationPolicyRuleMetricThresholdArgs']):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class BdsAutoScalingConfigurationPolicyRuleMetricThresholdArgs:
    def __init__(__self__, *,
                 duration_in_minutes: pulumi.Input[int],
                 operator: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[int] duration_in_minutes: (Updatable) This value is the minimum period of time the metric value meets or exceeds the threshold value before the action is triggered. The value is in minutes.
        :param pulumi.Input[str] operator: (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        :param pulumi.Input[int] value: (Updatable) Integer non-negative value. 0 < value < 100
        """
        pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> pulumi.Input[int]:
        """
        (Updatable) This value is the minimum period of time the metric value meets or exceeds the threshold value before the action is triggered. The value is in minutes.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration_in_minutes", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        (Updatable) The comparison operator to use. Options are greater than (GT) or less than (LT).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        (Updatable) Integer non-negative value. 0 < value < 100
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BdsBdsInstanceCloudSqlDetailsArgs:
    def __init__(__self__, *,
                 block_volume_size_in_gbs: pulumi.Input[str],
                 shape: pulumi.Input[str],
                 ip_address: Optional[pulumi.Input[str]] = None,
                 is_kerberos_mapped_to_database_users: Optional[pulumi.Input[bool]] = None,
                 kerberos_details: Optional[pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceCloudSqlDetailsKerberosDetailArgs']]]] = None):
        """
        :param pulumi.Input[str] block_volume_size_in_gbs: The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        :param pulumi.Input[str] shape: (Updatable) Shape of the node.
        :param pulumi.Input[str] ip_address: IP address of the node.
        :param pulumi.Input[bool] is_kerberos_mapped_to_database_users: Boolean flag specifying whether or not Kerberos principals are mapped to database users.
        :param pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceCloudSqlDetailsKerberosDetailArgs']]] kerberos_details: Details about the Kerberos principals.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "shape", shape)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_kerberos_mapped_to_database_users is not None:
            pulumi.set(__self__, "is_kerberos_mapped_to_database_users", is_kerberos_mapped_to_database_users)
        if kerberos_details is not None:
            pulumi.set(__self__, "kerberos_details", kerberos_details)

    @property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> pulumi.Input[str]:
        """
        The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @block_volume_size_in_gbs.setter
    def block_volume_size_in_gbs(self, value: pulumi.Input[str]):
        pulumi.set(self, "block_volume_size_in_gbs", value)

    @property
    @pulumi.getter
    def shape(self) -> pulumi.Input[str]:
        """
        (Updatable) Shape of the node.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        IP address of the node.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="isKerberosMappedToDatabaseUsers")
    def is_kerberos_mapped_to_database_users(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag specifying whether or not Kerberos principals are mapped to database users.
        """
        return pulumi.get(self, "is_kerberos_mapped_to_database_users")

    @is_kerberos_mapped_to_database_users.setter
    def is_kerberos_mapped_to_database_users(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_kerberos_mapped_to_database_users", value)

    @property
    @pulumi.getter(name="kerberosDetails")
    def kerberos_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceCloudSqlDetailsKerberosDetailArgs']]]]:
        """
        Details about the Kerberos principals.
        """
        return pulumi.get(self, "kerberos_details")

    @kerberos_details.setter
    def kerberos_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceCloudSqlDetailsKerberosDetailArgs']]]]):
        pulumi.set(self, "kerberos_details", value)


@pulumi.input_type
class BdsBdsInstanceCloudSqlDetailsKerberosDetailArgs:
    def __init__(__self__, *,
                 keytab_file: Optional[pulumi.Input[str]] = None,
                 principal_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] keytab_file: Location of the keytab file
        :param pulumi.Input[str] principal_name: Name of the Kerberos principal.
        """
        if keytab_file is not None:
            pulumi.set(__self__, "keytab_file", keytab_file)
        if principal_name is not None:
            pulumi.set(__self__, "principal_name", principal_name)

    @property
    @pulumi.getter(name="keytabFile")
    def keytab_file(self) -> Optional[pulumi.Input[str]]:
        """
        Location of the keytab file
        """
        return pulumi.get(self, "keytab_file")

    @keytab_file.setter
    def keytab_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keytab_file", value)

    @property
    @pulumi.getter(name="principalName")
    def principal_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Kerberos principal.
        """
        return pulumi.get(self, "principal_name")

    @principal_name.setter
    def principal_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "principal_name", value)


@pulumi.input_type
class BdsBdsInstanceClusterDetailsArgs:
    def __init__(__self__, *,
                 ambari_url: Optional[pulumi.Input[str]] = None,
                 bd_cell_version: Optional[pulumi.Input[str]] = None,
                 bda_version: Optional[pulumi.Input[str]] = None,
                 bdm_version: Optional[pulumi.Input[str]] = None,
                 bds_version: Optional[pulumi.Input[str]] = None,
                 big_data_manager_url: Optional[pulumi.Input[str]] = None,
                 cloudera_manager_url: Optional[pulumi.Input[str]] = None,
                 csql_cell_version: Optional[pulumi.Input[str]] = None,
                 db_version: Optional[pulumi.Input[str]] = None,
                 hue_server_url: Optional[pulumi.Input[str]] = None,
                 os_version: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_refreshed: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ambari_url: The URL of Ambari
        :param pulumi.Input[str] bd_cell_version: Cloud SQL cell version.
        :param pulumi.Input[str] bda_version: BDA version installed in the cluster
        :param pulumi.Input[str] bdm_version: Big Data Manager version installed in the cluster.
        :param pulumi.Input[str] bds_version: Big Data Service version installed in the cluster.
        :param pulumi.Input[str] big_data_manager_url: The URL of Big Data Manager.
        :param pulumi.Input[str] cloudera_manager_url: The URL of Cloudera Manager
        :param pulumi.Input[str] csql_cell_version: Big Data SQL version.
        :param pulumi.Input[str] db_version: Cloud SQL query server database version.
        :param pulumi.Input[str] hue_server_url: The URL of the Hue server.
        :param pulumi.Input[str] os_version: Oracle Linux version installed in the cluster.
        :param pulumi.Input[str] time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        :param pulumi.Input[str] time_refreshed: The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        if ambari_url is not None:
            pulumi.set(__self__, "ambari_url", ambari_url)
        if bd_cell_version is not None:
            pulumi.set(__self__, "bd_cell_version", bd_cell_version)
        if bda_version is not None:
            pulumi.set(__self__, "bda_version", bda_version)
        if bdm_version is not None:
            pulumi.set(__self__, "bdm_version", bdm_version)
        if bds_version is not None:
            pulumi.set(__self__, "bds_version", bds_version)
        if big_data_manager_url is not None:
            pulumi.set(__self__, "big_data_manager_url", big_data_manager_url)
        if cloudera_manager_url is not None:
            pulumi.set(__self__, "cloudera_manager_url", cloudera_manager_url)
        if csql_cell_version is not None:
            pulumi.set(__self__, "csql_cell_version", csql_cell_version)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if hue_server_url is not None:
            pulumi.set(__self__, "hue_server_url", hue_server_url)
        if os_version is not None:
            pulumi.set(__self__, "os_version", os_version)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_refreshed is not None:
            pulumi.set(__self__, "time_refreshed", time_refreshed)

    @property
    @pulumi.getter(name="ambariUrl")
    def ambari_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of Ambari
        """
        return pulumi.get(self, "ambari_url")

    @ambari_url.setter
    def ambari_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ambari_url", value)

    @property
    @pulumi.getter(name="bdCellVersion")
    def bd_cell_version(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud SQL cell version.
        """
        return pulumi.get(self, "bd_cell_version")

    @bd_cell_version.setter
    def bd_cell_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bd_cell_version", value)

    @property
    @pulumi.getter(name="bdaVersion")
    def bda_version(self) -> Optional[pulumi.Input[str]]:
        """
        BDA version installed in the cluster
        """
        return pulumi.get(self, "bda_version")

    @bda_version.setter
    def bda_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bda_version", value)

    @property
    @pulumi.getter(name="bdmVersion")
    def bdm_version(self) -> Optional[pulumi.Input[str]]:
        """
        Big Data Manager version installed in the cluster.
        """
        return pulumi.get(self, "bdm_version")

    @bdm_version.setter
    def bdm_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bdm_version", value)

    @property
    @pulumi.getter(name="bdsVersion")
    def bds_version(self) -> Optional[pulumi.Input[str]]:
        """
        Big Data Service version installed in the cluster.
        """
        return pulumi.get(self, "bds_version")

    @bds_version.setter
    def bds_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bds_version", value)

    @property
    @pulumi.getter(name="bigDataManagerUrl")
    def big_data_manager_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of Big Data Manager.
        """
        return pulumi.get(self, "big_data_manager_url")

    @big_data_manager_url.setter
    def big_data_manager_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "big_data_manager_url", value)

    @property
    @pulumi.getter(name="clouderaManagerUrl")
    def cloudera_manager_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of Cloudera Manager
        """
        return pulumi.get(self, "cloudera_manager_url")

    @cloudera_manager_url.setter
    def cloudera_manager_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudera_manager_url", value)

    @property
    @pulumi.getter(name="csqlCellVersion")
    def csql_cell_version(self) -> Optional[pulumi.Input[str]]:
        """
        Big Data SQL version.
        """
        return pulumi.get(self, "csql_cell_version")

    @csql_cell_version.setter
    def csql_cell_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "csql_cell_version", value)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud SQL query server database version.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter(name="hueServerUrl")
    def hue_server_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Hue server.
        """
        return pulumi.get(self, "hue_server_url")

    @hue_server_url.setter
    def hue_server_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hue_server_url", value)

    @property
    @pulumi.getter(name="osVersion")
    def os_version(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Linux version installed in the cluster.
        """
        return pulumi.get(self, "os_version")

    @os_version.setter
    def os_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_version", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeRefreshed")
    def time_refreshed(self) -> Optional[pulumi.Input[str]]:
        """
        The time the cluster was automatically or manually refreshed, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_refreshed")

    @time_refreshed.setter
    def time_refreshed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_refreshed", value)


@pulumi.input_type
class BdsBdsInstanceMasterNodeArgs:
    def __init__(__self__, *,
                 block_volume_size_in_gbs: pulumi.Input[str],
                 number_of_nodes: pulumi.Input[int],
                 shape: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] block_volume_size_in_gbs: The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        :param pulumi.Input[int] number_of_nodes: The number of nodes that form the cluster.
        :param pulumi.Input[str] shape: (Updatable) Shape of the node.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet in which the node will be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> pulumi.Input[str]:
        """
        The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @block_volume_size_in_gbs.setter
    def block_volume_size_in_gbs(self, value: pulumi.Input[str]):
        pulumi.set(self, "block_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> pulumi.Input[int]:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @number_of_nodes.setter
    def number_of_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_nodes", value)

    @property
    @pulumi.getter
    def shape(self) -> pulumi.Input[str]:
        """
        (Updatable) Shape of the node.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The OCID of the subnet in which the node will be created.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class BdsBdsInstanceNetworkConfigArgs:
    def __init__(__self__, *,
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 is_nat_gateway_required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cidr_block: The CIDR IP address block of the VCN.
        :param pulumi.Input[bool] is_nat_gateway_required: A boolean flag whether to configure a NAT gateway.
        """
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if is_nat_gateway_required is not None:
            pulumi.set(__self__, "is_nat_gateway_required", is_nat_gateway_required)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR IP address block of the VCN.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="isNatGatewayRequired")
    def is_nat_gateway_required(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag whether to configure a NAT gateway.
        """
        return pulumi.get(self, "is_nat_gateway_required")

    @is_nat_gateway_required.setter
    def is_nat_gateway_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_nat_gateway_required", value)


@pulumi.input_type
class BdsBdsInstanceNodeArgs:
    def __init__(__self__, *,
                 attached_block_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceNodeAttachedBlockVolumeArgs']]]] = None,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 node_type: Optional[pulumi.Input[str]] = None,
                 shape: Optional[pulumi.Input[str]] = None,
                 ssh_fingerprint: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceNodeAttachedBlockVolumeArgs']]] attached_block_volumes: The list of block volumes attached to a given node.
        :param pulumi.Input[str] availability_domain: The name of the availability domain in which the node is running.
        :param pulumi.Input[str] display_name: (Updatable) Name of the Big Data Service cluster.
        :param pulumi.Input[str] fault_domain: The name of the fault domain in which the node is running.
        :param pulumi.Input[str] hostname: The fully-qualified hostname (FQDN) of the node.
        :param pulumi.Input[str] image_id: The OCID of the image from which the node was created.
        :param pulumi.Input[str] instance_id: The OCID of the underlying Oracle Cloud Infrastructure Compute instance.
        :param pulumi.Input[str] ip_address: IP address of the node.
        :param pulumi.Input[str] node_type: The Big Data Service cluster node type.
        :param pulumi.Input[str] shape: (Updatable) Shape of the node.
        :param pulumi.Input[str] ssh_fingerprint: The fingerprint of the SSH key used for node access.
        :param pulumi.Input[str] state: The state of the cluster.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet in which the node will be created.
        :param pulumi.Input[str] time_created: The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        if attached_block_volumes is not None:
            pulumi.set(__self__, "attached_block_volumes", attached_block_volumes)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if ssh_fingerprint is not None:
            pulumi.set(__self__, "ssh_fingerprint", ssh_fingerprint)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter(name="attachedBlockVolumes")
    def attached_block_volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceNodeAttachedBlockVolumeArgs']]]]:
        """
        The list of block volumes attached to a given node.
        """
        return pulumi.get(self, "attached_block_volumes")

    @attached_block_volumes.setter
    def attached_block_volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BdsBdsInstanceNodeAttachedBlockVolumeArgs']]]]):
        pulumi.set(self, "attached_block_volumes", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the availability domain in which the node is running.
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the Big Data Service cluster.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the fault domain in which the node is running.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The fully-qualified hostname (FQDN) of the node.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the image from which the node was created.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the underlying Oracle Cloud Infrastructure Compute instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        IP address of the node.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Big Data Service cluster node type.
        """
        return pulumi.get(self, "node_type")

    @node_type.setter
    def node_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_type", value)

    @property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Shape of the node.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="sshFingerprint")
    def ssh_fingerprint(self) -> Optional[pulumi.Input[str]]:
        """
        The fingerprint of the SSH key used for node access.
        """
        return pulumi.get(self, "ssh_fingerprint")

    @ssh_fingerprint.setter
    def ssh_fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_fingerprint", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the cluster.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet in which the node will be created.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time the cluster was created, shown as an RFC 3339 formatted datetime string.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


@pulumi.input_type
class BdsBdsInstanceNodeAttachedBlockVolumeArgs:
    def __init__(__self__, *,
                 volume_attachment_id: Optional[pulumi.Input[str]] = None,
                 volume_size_in_gbs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] volume_attachment_id: The OCID of the volume attachment.
        :param pulumi.Input[str] volume_size_in_gbs: The size of the volume in GBs.
        """
        if volume_attachment_id is not None:
            pulumi.set(__self__, "volume_attachment_id", volume_attachment_id)
        if volume_size_in_gbs is not None:
            pulumi.set(__self__, "volume_size_in_gbs", volume_size_in_gbs)

    @property
    @pulumi.getter(name="volumeAttachmentId")
    def volume_attachment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume attachment.
        """
        return pulumi.get(self, "volume_attachment_id")

    @volume_attachment_id.setter
    def volume_attachment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_attachment_id", value)

    @property
    @pulumi.getter(name="volumeSizeInGbs")
    def volume_size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the volume in GBs.
        """
        return pulumi.get(self, "volume_size_in_gbs")

    @volume_size_in_gbs.setter
    def volume_size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_size_in_gbs", value)


@pulumi.input_type
class BdsBdsInstanceUtilNodeArgs:
    def __init__(__self__, *,
                 block_volume_size_in_gbs: pulumi.Input[str],
                 number_of_nodes: pulumi.Input[int],
                 shape: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] block_volume_size_in_gbs: The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        :param pulumi.Input[int] number_of_nodes: The number of nodes that form the cluster.
        :param pulumi.Input[str] shape: (Updatable) Shape of the node.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet in which the node will be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> pulumi.Input[str]:
        """
        The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @block_volume_size_in_gbs.setter
    def block_volume_size_in_gbs(self, value: pulumi.Input[str]):
        pulumi.set(self, "block_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> pulumi.Input[int]:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @number_of_nodes.setter
    def number_of_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_nodes", value)

    @property
    @pulumi.getter
    def shape(self) -> pulumi.Input[str]:
        """
        (Updatable) Shape of the node.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The OCID of the subnet in which the node will be created.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class BdsBdsInstanceWorkerNodeArgs:
    def __init__(__self__, *,
                 block_volume_size_in_gbs: pulumi.Input[str],
                 number_of_nodes: pulumi.Input[int],
                 shape: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] block_volume_size_in_gbs: The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        :param pulumi.Input[int] number_of_nodes: The number of nodes that form the cluster.
        :param pulumi.Input[str] shape: (Updatable) Shape of the node.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet in which the node will be created.
        """
        pulumi.set(__self__, "block_volume_size_in_gbs", block_volume_size_in_gbs)
        pulumi.set(__self__, "number_of_nodes", number_of_nodes)
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="blockVolumeSizeInGbs")
    def block_volume_size_in_gbs(self) -> pulumi.Input[str]:
        """
        The size of block volume in GB to be attached to a given node. All the details needed for attaching the block volume are managed by service itself.
        """
        return pulumi.get(self, "block_volume_size_in_gbs")

    @block_volume_size_in_gbs.setter
    def block_volume_size_in_gbs(self, value: pulumi.Input[str]):
        pulumi.set(self, "block_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="numberOfNodes")
    def number_of_nodes(self) -> pulumi.Input[int]:
        """
        The number of nodes that form the cluster.
        """
        return pulumi.get(self, "number_of_nodes")

    @number_of_nodes.setter
    def number_of_nodes(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_nodes", value)

    @property
    @pulumi.getter
    def shape(self) -> pulumi.Input[str]:
        """
        (Updatable) Shape of the node.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The OCID of the subnet in which the node will be created.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class BlockchainBlockchainPlatformComponentDetailsArgs:
    def __init__(__self__, *,
                 osns: Optional[pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnArgs']]]] = None,
                 peers: Optional[pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnArgs']]] osns: List of OSNs
        :param pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerArgs']]] peers: List of Peers
        """
        if osns is not None:
            pulumi.set(__self__, "osns", osns)
        if peers is not None:
            pulumi.set(__self__, "peers", peers)

    @property
    @pulumi.getter
    def osns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnArgs']]]]:
        """
        List of OSNs
        """
        return pulumi.get(self, "osns")

    @osns.setter
    def osns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnArgs']]]]):
        pulumi.set(self, "osns", value)

    @property
    @pulumi.getter
    def peers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerArgs']]]]:
        """
        List of Peers
        """
        return pulumi.get(self, "peers")

    @peers.setter
    def peers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerArgs']]]]):
        pulumi.set(self, "peers", value)


@pulumi.input_type
class BlockchainBlockchainPlatformComponentDetailsOsnArgs:
    def __init__(__self__, *,
                 ad: Optional[pulumi.Input[str]] = None,
                 ocpu_allocation_param: Optional[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnOcpuAllocationParamArgs']] = None,
                 osn_key: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ad: Availability Domain of peer
        :param pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnOcpuAllocationParamArgs'] ocpu_allocation_param: OCPU allocation parameter
        :param pulumi.Input[str] osn_key: OSN identifier
        :param pulumi.Input[str] state: The current state of the Platform Instance.
        """
        if ad is not None:
            pulumi.set(__self__, "ad", ad)
        if ocpu_allocation_param is not None:
            pulumi.set(__self__, "ocpu_allocation_param", ocpu_allocation_param)
        if osn_key is not None:
            pulumi.set(__self__, "osn_key", osn_key)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def ad(self) -> Optional[pulumi.Input[str]]:
        """
        Availability Domain of peer
        """
        return pulumi.get(self, "ad")

    @ad.setter
    def ad(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ad", value)

    @property
    @pulumi.getter(name="ocpuAllocationParam")
    def ocpu_allocation_param(self) -> Optional[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnOcpuAllocationParamArgs']]:
        """
        OCPU allocation parameter
        """
        return pulumi.get(self, "ocpu_allocation_param")

    @ocpu_allocation_param.setter
    def ocpu_allocation_param(self, value: Optional[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsOsnOcpuAllocationParamArgs']]):
        pulumi.set(self, "ocpu_allocation_param", value)

    @property
    @pulumi.getter(name="osnKey")
    def osn_key(self) -> Optional[pulumi.Input[str]]:
        """
        OSN identifier
        """
        return pulumi.get(self, "osn_key")

    @osn_key.setter
    def osn_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "osn_key", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Platform Instance.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class BlockchainBlockchainPlatformComponentDetailsOsnOcpuAllocationParamArgs:
    def __init__(__self__, *,
                 ocpu_allocation_number: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] ocpu_allocation_number: Number of OCPU allocation
        """
        if ocpu_allocation_number is not None:
            pulumi.set(__self__, "ocpu_allocation_number", ocpu_allocation_number)

    @property
    @pulumi.getter(name="ocpuAllocationNumber")
    def ocpu_allocation_number(self) -> Optional[pulumi.Input[float]]:
        """
        Number of OCPU allocation
        """
        return pulumi.get(self, "ocpu_allocation_number")

    @ocpu_allocation_number.setter
    def ocpu_allocation_number(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpu_allocation_number", value)


@pulumi.input_type
class BlockchainBlockchainPlatformComponentDetailsPeerArgs:
    def __init__(__self__, *,
                 ad: Optional[pulumi.Input[str]] = None,
                 alias: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 ocpu_allocation_param: Optional[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerOcpuAllocationParamArgs']] = None,
                 peer_key: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ad: Availability Domain of peer
        :param pulumi.Input[str] alias: peer alias
        :param pulumi.Input[str] host: Host name of VM
        :param pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerOcpuAllocationParamArgs'] ocpu_allocation_param: OCPU allocation parameter
        :param pulumi.Input[str] peer_key: peer identifier
        :param pulumi.Input[str] role: Peer role
        :param pulumi.Input[str] state: The current state of the Platform Instance.
        """
        if ad is not None:
            pulumi.set(__self__, "ad", ad)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ocpu_allocation_param is not None:
            pulumi.set(__self__, "ocpu_allocation_param", ocpu_allocation_param)
        if peer_key is not None:
            pulumi.set(__self__, "peer_key", peer_key)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def ad(self) -> Optional[pulumi.Input[str]]:
        """
        Availability Domain of peer
        """
        return pulumi.get(self, "ad")

    @ad.setter
    def ad(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ad", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        peer alias
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host name of VM
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ocpuAllocationParam")
    def ocpu_allocation_param(self) -> Optional[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerOcpuAllocationParamArgs']]:
        """
        OCPU allocation parameter
        """
        return pulumi.get(self, "ocpu_allocation_param")

    @ocpu_allocation_param.setter
    def ocpu_allocation_param(self, value: Optional[pulumi.Input['BlockchainBlockchainPlatformComponentDetailsPeerOcpuAllocationParamArgs']]):
        pulumi.set(self, "ocpu_allocation_param", value)

    @property
    @pulumi.getter(name="peerKey")
    def peer_key(self) -> Optional[pulumi.Input[str]]:
        """
        peer identifier
        """
        return pulumi.get(self, "peer_key")

    @peer_key.setter
    def peer_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "peer_key", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Peer role
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Platform Instance.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class BlockchainBlockchainPlatformComponentDetailsPeerOcpuAllocationParamArgs:
    def __init__(__self__, *,
                 ocpu_allocation_number: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] ocpu_allocation_number: Number of OCPU allocation
        """
        if ocpu_allocation_number is not None:
            pulumi.set(__self__, "ocpu_allocation_number", ocpu_allocation_number)

    @property
    @pulumi.getter(name="ocpuAllocationNumber")
    def ocpu_allocation_number(self) -> Optional[pulumi.Input[float]]:
        """
        Number of OCPU allocation
        """
        return pulumi.get(self, "ocpu_allocation_number")

    @ocpu_allocation_number.setter
    def ocpu_allocation_number(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpu_allocation_number", value)


@pulumi.input_type
class BlockchainBlockchainPlatformHostOcpuUtilizationInfoArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 ocpu_capacity_number: Optional[pulumi.Input[float]] = None,
                 ocpu_utilization_number: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] host: Host name of VM
        :param pulumi.Input[float] ocpu_capacity_number: Number of total OCPU capacity on the host
        :param pulumi.Input[float] ocpu_utilization_number: Number of OCPU utilized
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ocpu_capacity_number is not None:
            pulumi.set(__self__, "ocpu_capacity_number", ocpu_capacity_number)
        if ocpu_utilization_number is not None:
            pulumi.set(__self__, "ocpu_utilization_number", ocpu_utilization_number)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Host name of VM
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="ocpuCapacityNumber")
    def ocpu_capacity_number(self) -> Optional[pulumi.Input[float]]:
        """
        Number of total OCPU capacity on the host
        """
        return pulumi.get(self, "ocpu_capacity_number")

    @ocpu_capacity_number.setter
    def ocpu_capacity_number(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpu_capacity_number", value)

    @property
    @pulumi.getter(name="ocpuUtilizationNumber")
    def ocpu_utilization_number(self) -> Optional[pulumi.Input[float]]:
        """
        Number of OCPU utilized
        """
        return pulumi.get(self, "ocpu_utilization_number")

    @ocpu_utilization_number.setter
    def ocpu_utilization_number(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpu_utilization_number", value)


@pulumi.input_type
class BlockchainBlockchainPlatformReplicasArgs:
    def __init__(__self__, *,
                 ca_count: Optional[pulumi.Input[int]] = None,
                 console_count: Optional[pulumi.Input[int]] = None,
                 proxy_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] ca_count: Number of CA replicas
        :param pulumi.Input[int] console_count: Number of console replicas
        :param pulumi.Input[int] proxy_count: Number of REST proxy replicas
        """
        if ca_count is not None:
            pulumi.set(__self__, "ca_count", ca_count)
        if console_count is not None:
            pulumi.set(__self__, "console_count", console_count)
        if proxy_count is not None:
            pulumi.set(__self__, "proxy_count", proxy_count)

    @property
    @pulumi.getter(name="caCount")
    def ca_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of CA replicas
        """
        return pulumi.get(self, "ca_count")

    @ca_count.setter
    def ca_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ca_count", value)

    @property
    @pulumi.getter(name="consoleCount")
    def console_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of console replicas
        """
        return pulumi.get(self, "console_count")

    @console_count.setter
    def console_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "console_count", value)

    @property
    @pulumi.getter(name="proxyCount")
    def proxy_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of REST proxy replicas
        """
        return pulumi.get(self, "proxy_count")

    @proxy_count.setter
    def proxy_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "proxy_count", value)


@pulumi.input_type
class BlockchainOsnOcpuAllocationParamArgs:
    def __init__(__self__, *,
                 ocpu_allocation_number: pulumi.Input[float]):
        """
        :param pulumi.Input[float] ocpu_allocation_number: (Updatable) Number of OCPU allocation
        """
        pulumi.set(__self__, "ocpu_allocation_number", ocpu_allocation_number)

    @property
    @pulumi.getter(name="ocpuAllocationNumber")
    def ocpu_allocation_number(self) -> pulumi.Input[float]:
        """
        (Updatable) Number of OCPU allocation
        """
        return pulumi.get(self, "ocpu_allocation_number")

    @ocpu_allocation_number.setter
    def ocpu_allocation_number(self, value: pulumi.Input[float]):
        pulumi.set(self, "ocpu_allocation_number", value)


@pulumi.input_type
class BlockchainPeerOcpuAllocationParamArgs:
    def __init__(__self__, *,
                 ocpu_allocation_number: pulumi.Input[float]):
        """
        :param pulumi.Input[float] ocpu_allocation_number: (Updatable) Number of OCPU allocation
        """
        pulumi.set(__self__, "ocpu_allocation_number", ocpu_allocation_number)

    @property
    @pulumi.getter(name="ocpuAllocationNumber")
    def ocpu_allocation_number(self) -> pulumi.Input[float]:
        """
        (Updatable) Number of OCPU allocation
        """
        return pulumi.get(self, "ocpu_allocation_number")

    @ocpu_allocation_number.setter
    def ocpu_allocation_number(self, value: pulumi.Input[float]):
        pulumi.set(self, "ocpu_allocation_number", value)


@pulumi.input_type
class CloudGuardDataMaskRuleTargetSelectedArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) Target selection.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Updatable) Types of Targets
        """
        pulumi.set(__self__, "kind", kind)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) Target selection.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Types of Targets
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CloudGuardDetectorRecipeDetectorRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsArgs'],
                 detector_rule_id: pulumi.Input[str],
                 candidate_responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleCandidateResponderRuleArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsArgs'] details: (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        :param pulumi.Input[str] detector_rule_id: (Updatable) DetectorRecipeRule Identifier
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleCandidateResponderRuleArgs']]] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param pulumi.Input[str] description: (Updatable) DetectorRecipe Description
        :param pulumi.Input[str] detector: detector for the rule
        :param pulumi.Input[str] display_name: (Updatable) DetectorRecipe Display Name
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of cloudguard managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for DetectorRecipeDetectorRule
        :param pulumi.Input[str] resource_type: resource type of the configuration to which the rule is applied
        :param pulumi.Input[str] service_type: service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: The current state of the resource.
        :param pulumi.Input[str] time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if candidate_responder_rules is not None:
            pulumi.set(__self__, "candidate_responder_rules", candidate_responder_rules)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsArgs']:
        """
        (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) DetectorRecipeRule Identifier
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleCandidateResponderRuleArgs']]]]:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @candidate_responder_rules.setter
    def candidate_responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleCandidateResponderRuleArgs']]]]):
        pulumi.set(self, "candidate_responder_rules", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorRecipe Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorRecipe Display Name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class CloudGuardDetectorRecipeDetectorRuleCandidateResponderRuleArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_preferred: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) DetectorRecipe Display Name
        :param pulumi.Input[str] id: Ocid for detector recipe
        :param pulumi.Input[bool] is_preferred: Preferred state
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_preferred is not None:
            pulumi.set(__self__, "is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorRecipe Display Name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")

    @is_preferred.setter
    def is_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_preferred", value)


@pulumi.input_type
class CloudGuardDetectorRecipeDetectorRuleDetailsArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 risk_level: pulumi.Input[str],
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Enables the control
        :param pulumi.Input[str] risk_level: (Updatable) The Risk Level
        :param pulumi.Input[str] condition: (Updatable)
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationArgs']]] configurations: (Updatable) Configuration details
        :param pulumi.Input[bool] is_configuration_allowed: configuration allowed or not
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: (Updatable) user defined labels for a detector rule
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "risk_level", risk_level)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> pulumi.Input[str]:
        """
        (Updatable) The Risk Level
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "risk_level", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) Configuration details
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: pulumi.Input[str],
                 name: pulumi.Input[str],
                 data_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique name of the configuration
        :param pulumi.Input[str] name: (Updatable) configuration name
        :param pulumi.Input[str] data_type: (Updatable) configuration data type
        :param pulumi.Input[str] value: (Updatable) configuration value
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]] values: (Updatable) List of configuration values
        """
        pulumi.set(__self__, "config_key", config_key)
        pulumi.set(__self__, "name", name)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]:
        """
        (Updatable) List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CloudGuardDetectorRecipeDetectorRuleDetailsConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: pulumi.Input[str],
                 managed_list_type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] list_type: (Updatable) configuration list item type, either CUSTOM or MANAGED
        :param pulumi.Input[str] managed_list_type: (Updatable) type of the managed list
        :param pulumi.Input[str] value: (Updatable) configuration value
        """
        pulumi.set(__self__, "list_type", list_type)
        pulumi.set(__self__, "managed_list_type", managed_list_type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> pulumi.Input[str]:
        """
        (Updatable) configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> pulumi.Input[str]:
        """
        (Updatable) type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudGuardDetectorRecipeEffectiveDetectorRuleArgs:
    def __init__(__self__, *,
                 candidate_responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsArgs']] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 detector_rule_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]] candidate_responder_rules: List of CandidateResponderRule related to this rule
        :param pulumi.Input[str] description: (Updatable) DetectorRecipe Description
        :param pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsArgs'] details: (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        :param pulumi.Input[str] detector: detector for the rule
        :param pulumi.Input[str] detector_rule_id: (Updatable) DetectorRecipeRule Identifier
        :param pulumi.Input[str] display_name: (Updatable) DetectorRecipe Display Name
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of cloudguard managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for DetectorRecipeDetectorRule
        :param pulumi.Input[str] resource_type: resource type of the configuration to which the rule is applied
        :param pulumi.Input[str] service_type: service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: The current state of the resource.
        :param pulumi.Input[str] time_created: The date and time the detector recipe was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        if candidate_responder_rules is not None:
            pulumi.set(__self__, "candidate_responder_rules", candidate_responder_rules)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if detector_rule_id is not None:
            pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="candidateResponderRules")
    def candidate_responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]]]:
        """
        List of CandidateResponderRule related to this rule
        """
        return pulumi.get(self, "candidate_responder_rules")

    @candidate_responder_rules.setter
    def candidate_responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs']]]]):
        pulumi.set(self, "candidate_responder_rules", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorRecipe Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsArgs']]:
        """
        (Updatable) Details of a Detector Rule to be overriden in Detector Recipe
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsArgs']]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorRecipeRule Identifier
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorRecipe Display Name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for DetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the detector recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class CloudGuardDetectorRecipeEffectiveDetectorRuleCandidateResponderRuleArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_preferred: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) DetectorRecipe Display Name
        :param pulumi.Input[str] id: Ocid for detector recipe
        :param pulumi.Input[bool] is_preferred: Preferred state
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_preferred is not None:
            pulumi.set(__self__, "is_preferred", is_preferred)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorRecipe Display Name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Ocid for detector recipe
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isPreferred")
    def is_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        Preferred state
        """
        return pulumi.get(self, "is_preferred")

    @is_preferred.setter
    def is_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_preferred", value)


@pulumi.input_type
class CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: (Updatable)
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]] configurations: (Updatable) Configuration details
        :param pulumi.Input[bool] is_configuration_allowed: configuration allowed or not
        :param pulumi.Input[bool] is_enabled: (Updatable) Enables the control
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: (Updatable) user defined labels for a detector rule
        :param pulumi.Input[str] risk_level: (Updatable) The Risk Level
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) Configuration details
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables the control
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The Risk Level
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)


@pulumi.input_type
class CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique name of the configuration
        :param pulumi.Input[str] data_type: (Updatable) configuration data type
        :param pulumi.Input[str] name: (Updatable) configuration name
        :param pulumi.Input[str] value: (Updatable) configuration value
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]] values: (Updatable) List of configuration values
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]]]:
        """
        (Updatable) List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CloudGuardDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: Optional[pulumi.Input[str]] = None,
                 managed_list_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] list_type: (Updatable) configuration list item type, either CUSTOM or MANAGED
        :param pulumi.Input[str] managed_list_type: (Updatable) type of the managed list
        :param pulumi.Input[str] value: (Updatable) configuration value
        """
        if list_type is not None:
            pulumi.set(__self__, "list_type", list_type)
        if managed_list_type is not None:
            pulumi.set(__self__, "managed_list_type", managed_list_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudGuardResponderRecipeEffectiveResponderRuleArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 responder_rule_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) Compartment Identifier
        :param pulumi.Input[str] description: (Updatable) ResponderRecipe Description
        :param pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsArgs'] details: (Updatable) Details of UpdateResponderRuleDetails.
        :param pulumi.Input[str] display_name: (Updatable) ResponderRecipe Display Name
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of Policy
        :param pulumi.Input[str] responder_rule_id: (Updatable) ResponderRecipeRule Identifier
        :param pulumi.Input[str] state: The current state of the Example.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported Execution Modes
        :param pulumi.Input[str] time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of Responder
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if responder_rule_id is not None:
            pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) ResponderRecipe Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsArgs']]:
        """
        (Updatable) Details of UpdateResponderRuleDetails.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsArgs']]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) ResponderRecipe Display Name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) ResponderRecipeRule Identifier
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Example.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CloudGuardResponderRecipeEffectiveResponderRuleDetailsArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]] configurations: ResponderRule configurations
        :param pulumi.Input[bool] is_enabled: (Updatable) Identifies state for ResponderRule
        :param pulumi.Input[str] mode: Execution Mode for ResponderRule
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]]]:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class CloudGuardResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_key: Unique name of the configuration
        :param pulumi.Input[str] name: configuration name
        :param pulumi.Input[str] value: configuration value
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudGuardResponderRecipeResponderRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsArgs'],
                 responder_rule_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsArgs'] details: (Updatable) Details of UpdateResponderRuleDetails.
        :param pulumi.Input[str] responder_rule_id: (Updatable) ResponderRecipeRule Identifier
        :param pulumi.Input[str] compartment_id: (Updatable) Compartment Identifier
        :param pulumi.Input[str] description: (Updatable) ResponderRecipe Description
        :param pulumi.Input[str] display_name: (Updatable) ResponderRecipe Display Name
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of Policy
        :param pulumi.Input[str] state: The current state of the Example.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported Execution Modes
        :param pulumi.Input[str] time_created: The date and time the responder recipe was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the responder recipe was updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of Responder
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsArgs']:
        """
        (Updatable) Details of UpdateResponderRuleDetails.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) ResponderRecipeRule Identifier
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Compartment Identifier
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) ResponderRecipe Description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) ResponderRecipe Display Name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Example.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the responder recipe was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CloudGuardResponderRecipeResponderRuleDetailsArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsConfigurationArgs']]]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Identifies state for ResponderRule
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsConfigurationArgs']]] configurations: ResponderRule configurations
        :param pulumi.Input[str] mode: Execution Mode for ResponderRule
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsConfigurationArgs']]]]:
        """
        ResponderRule configurations
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardResponderRecipeResponderRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class CloudGuardResponderRecipeResponderRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_key: Unique name of the configuration
        :param pulumi.Input[str] name: configuration name
        :param pulumi.Input[str] value: configuration value
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeArgs:
    def __init__(__self__, *,
                 detector_recipe_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 detector_rules: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleArgs']]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 effective_detector_rules: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detector_recipe_id: Identifier for DetectorRecipe.
        :param pulumi.Input[str] compartment_id: (Updatable) compartment associated with condition
        :param pulumi.Input[str] description: The target description.
        :param pulumi.Input[str] detector: detector for the rule
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleArgs']]] detector_rules: (Updatable) Overrides to be applied to Detector Rule associated with the target
        :param pulumi.Input[str] display_name: (Updatable) DetectorTemplate Identifier
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]] effective_detector_rules: List of effective detector rules for the detector type for recipe after applying defaults
        :param pulumi.Input[str] id: Unique identifier of TargetResponderRecipe that is immutable on creation
        :param pulumi.Input[str] owner: Owner of ResponderRecipe
        :param pulumi.Input[str] state: (Updatable) The current state of the DetectorRule.
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        pulumi.set(__self__, "detector_recipe_id", detector_recipe_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if detector_rules is not None:
            pulumi.set(__self__, "detector_rules", detector_rules)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if effective_detector_rules is not None:
            pulumi.set(__self__, "effective_detector_rules", effective_detector_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="detectorRecipeId")
    def detector_recipe_id(self) -> pulumi.Input[str]:
        """
        Identifier for DetectorRecipe.
        """
        return pulumi.get(self, "detector_recipe_id")

    @detector_recipe_id.setter
    def detector_recipe_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "detector_recipe_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="detectorRules")
    def detector_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleArgs']]]]:
        """
        (Updatable) Overrides to be applied to Detector Rule associated with the target
        """
        return pulumi.get(self, "detector_rules")

    @detector_rules.setter
    def detector_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleArgs']]]]):
        pulumi.set(self, "detector_rules", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorTemplate Identifier
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="effectiveDetectorRules")
    def effective_detector_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]]]:
        """
        List of effective detector rules for the detector type for recipe after applying defaults
        """
        return pulumi.get(self, "effective_detector_rules")

    @effective_detector_rules.setter
    def effective_detector_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleArgs']]]]):
        pulumi.set(self, "effective_detector_rules", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of TargetResponderRecipe that is immutable on creation
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeDetectorRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsArgs'],
                 detector_rule_id: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsArgs'] details: (Updatable) Details of ResponderRule.
        :param pulumi.Input[str] detector_rule_id: (Updatable) Identifier for DetectorRule.
        :param pulumi.Input[str] description: The target description.
        :param pulumi.Input[str] detector: detector for the rule
        :param pulumi.Input[str] display_name: (Updatable) DetectorTemplate Identifier
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of cloudguard managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param pulumi.Input[str] resource_type: resource type of the configuration to which the rule is applied
        :param pulumi.Input[str] service_type: service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: (Updatable) The current state of the DetectorRule.
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsArgs']:
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Identifier for DetectorRule.
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorTemplate Identifier
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsArgs:
    def __init__(__self__, *,
                 condition_groups: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]] condition_groups: (Updatable) Condition group corresponding to each compartment
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]] configurations: (Updatable) Configurations associated with the ResponderRule
        :param pulumi.Input[bool] is_configuration_allowed: configuration allowed or not
        :param pulumi.Input[bool] is_enabled: Identifies state for ResponderRule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: user defined labels for a detector rule
        :param pulumi.Input[str] risk_level: The Risk Level
        """
        if condition_groups is not None:
            pulumi.set(__self__, "condition_groups", condition_groups)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]]]:
        """
        (Updatable) Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @condition_groups.setter
    def condition_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs']]]]):
        pulumi.set(self, "condition_groups", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConditionGroupArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 condition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) compartment associated with condition
        :param pulumi.Input[str] condition: (Updatable)
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        (Updatable)
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique name of the configuration
        :param pulumi.Input[str] data_type: configuration data type
        :param pulumi.Input[str] name: (Updatable) configuration name
        :param pulumi.Input[str] value: (Updatable) configuration value
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]] values: List of configuration values
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeDetectorRuleDetailsConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: Optional[pulumi.Input[str]] = None,
                 managed_list_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] list_type: configuration list item type, either CUSTOM or MANAGED
        :param pulumi.Input[str] managed_list_type: type of the managed list
        :param pulumi.Input[str] value: (Updatable) configuration value
        """
        if list_type is not None:
            pulumi.set(__self__, "list_type", list_type)
        if managed_list_type is not None:
            pulumi.set(__self__, "managed_list_type", managed_list_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[pulumi.Input[str]]:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsArgs']] = None,
                 detector: Optional[pulumi.Input[str]] = None,
                 detector_rule_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 managed_list_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendation: Optional[pulumi.Input[str]] = None,
                 resource_type: Optional[pulumi.Input[str]] = None,
                 service_type: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: The target description.
        :param pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsArgs'] details: (Updatable) Details of ResponderRule.
        :param pulumi.Input[str] detector: detector for the rule
        :param pulumi.Input[str] detector_rule_id: (Updatable) Identifier for DetectorRule.
        :param pulumi.Input[str] display_name: (Updatable) DetectorTemplate Identifier
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] managed_list_types: List of cloudguard managed list types related to this rule
        :param pulumi.Input[str] recommendation: Recommendation for TargetDetectorRecipeDetectorRule
        :param pulumi.Input[str] resource_type: resource type of the configuration to which the rule is applied
        :param pulumi.Input[str] service_type: service type of the configuration to which the rule is applied
        :param pulumi.Input[str] state: (Updatable) The current state of the DetectorRule.
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if detector is not None:
            pulumi.set(__self__, "detector", detector)
        if detector_rule_id is not None:
            pulumi.set(__self__, "detector_rule_id", detector_rule_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if managed_list_types is not None:
            pulumi.set(__self__, "managed_list_types", managed_list_types)
        if recommendation is not None:
            pulumi.set(__self__, "recommendation", recommendation)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsArgs']]:
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsArgs']]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def detector(self) -> Optional[pulumi.Input[str]]:
        """
        detector for the rule
        """
        return pulumi.get(self, "detector")

    @detector.setter
    def detector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector", value)

    @property
    @pulumi.getter(name="detectorRuleId")
    def detector_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Identifier for DetectorRule.
        """
        return pulumi.get(self, "detector_rule_id")

    @detector_rule_id.setter
    def detector_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detector_rule_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorTemplate Identifier
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="managedListTypes")
    def managed_list_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of cloudguard managed list types related to this rule
        """
        return pulumi.get(self, "managed_list_types")

    @managed_list_types.setter
    def managed_list_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "managed_list_types", value)

    @property
    @pulumi.getter
    def recommendation(self) -> Optional[pulumi.Input[str]]:
        """
        Recommendation for TargetDetectorRecipeDetectorRule
        """
        return pulumi.get(self, "recommendation")

    @recommendation.setter
    def recommendation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation", value)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[str]]:
        """
        resource type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[pulumi.Input[str]]:
        """
        service type of the configuration to which the rule is applied
        """
        return pulumi.get(self, "service_type")

    @service_type.setter
    def service_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_type", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsArgs:
    def __init__(__self__, *,
                 condition_groups: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConditionGroupArgs']]]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]]] = None,
                 is_configuration_allowed: Optional[pulumi.Input[bool]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 risk_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConditionGroupArgs']]] condition_groups: (Updatable) Condition group corresponding to each compartment
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]] configurations: (Updatable) Configurations associated with the ResponderRule
        :param pulumi.Input[bool] is_configuration_allowed: configuration allowed or not
        :param pulumi.Input[bool] is_enabled: Identifies state for ResponderRule
        :param pulumi.Input[Sequence[pulumi.Input[str]]] labels: user defined labels for a detector rule
        :param pulumi.Input[str] risk_level: The Risk Level
        """
        if condition_groups is not None:
            pulumi.set(__self__, "condition_groups", condition_groups)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_configuration_allowed is not None:
            pulumi.set(__self__, "is_configuration_allowed", is_configuration_allowed)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if risk_level is not None:
            pulumi.set(__self__, "risk_level", risk_level)

    @property
    @pulumi.getter(name="conditionGroups")
    def condition_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConditionGroupArgs']]]]:
        """
        (Updatable) Condition group corresponding to each compartment
        """
        return pulumi.get(self, "condition_groups")

    @condition_groups.setter
    def condition_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConditionGroupArgs']]]]):
        pulumi.set(self, "condition_groups", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isConfigurationAllowed")
    def is_configuration_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        configuration allowed or not
        """
        return pulumi.get(self, "is_configuration_allowed")

    @is_configuration_allowed.setter
    def is_configuration_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_configuration_allowed", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        user defined labels for a detector rule
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="riskLevel")
    def risk_level(self) -> Optional[pulumi.Input[str]]:
        """
        The Risk Level
        """
        return pulumi.get(self, "risk_level")

    @risk_level.setter
    def risk_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "risk_level", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConditionGroupArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 condition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) compartment associated with condition
        :param pulumi.Input[str] condition: (Updatable)
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]]] = None):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique name of the configuration
        :param pulumi.Input[str] data_type: configuration data type
        :param pulumi.Input[str] name: (Updatable) configuration name
        :param pulumi.Input[str] value: (Updatable) configuration value
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]] values: List of configuration values
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        configuration data type
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]]]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class CloudGuardTargetTargetDetectorRecipeEffectiveDetectorRuleDetailsConfigurationValueArgs:
    def __init__(__self__, *,
                 list_type: Optional[pulumi.Input[str]] = None,
                 managed_list_type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] list_type: configuration list item type, either CUSTOM or MANAGED
        :param pulumi.Input[str] managed_list_type: type of the managed list
        :param pulumi.Input[str] value: (Updatable) configuration value
        """
        if list_type is not None:
            pulumi.set(__self__, "list_type", list_type)
        if managed_list_type is not None:
            pulumi.set(__self__, "managed_list_type", managed_list_type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="listType")
    def list_type(self) -> Optional[pulumi.Input[str]]:
        """
        configuration list item type, either CUSTOM or MANAGED
        """
        return pulumi.get(self, "list_type")

    @list_type.setter
    def list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "list_type", value)

    @property
    @pulumi.getter(name="managedListType")
    def managed_list_type(self) -> Optional[pulumi.Input[str]]:
        """
        type of the managed list
        """
        return pulumi.get(self, "managed_list_type")

    @managed_list_type.setter
    def managed_list_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "managed_list_type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudGuardTargetTargetResponderRecipeArgs:
    def __init__(__self__, *,
                 responder_recipe_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 effective_responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 responder_rules: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleArgs']]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] responder_recipe_id: Identifier for ResponderRecipe.
        :param pulumi.Input[str] compartment_id: (Updatable) compartment associated with condition
        :param pulumi.Input[str] description: The target description.
        :param pulumi.Input[str] display_name: (Updatable) DetectorTemplate Identifier
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleArgs']]] effective_responder_rules: List of responder rules associated with the recipe after applying all defaults
        :param pulumi.Input[str] id: Unique identifier of TargetResponderRecipe that is immutable on creation
        :param pulumi.Input[str] owner: Owner of ResponderRecipe
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleArgs']]] responder_rules: (Updatable) Override responder rules associated with reponder recipe in a target.
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was updated. Format defined by RFC3339.
        """
        pulumi.set(__self__, "responder_recipe_id", responder_recipe_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if effective_responder_rules is not None:
            pulumi.set(__self__, "effective_responder_rules", effective_responder_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if responder_rules is not None:
            pulumi.set(__self__, "responder_rules", responder_rules)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="responderRecipeId")
    def responder_recipe_id(self) -> pulumi.Input[str]:
        """
        Identifier for ResponderRecipe.
        """
        return pulumi.get(self, "responder_recipe_id")

    @responder_recipe_id.setter
    def responder_recipe_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "responder_recipe_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorTemplate Identifier
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="effectiveResponderRules")
    def effective_responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleArgs']]]]:
        """
        List of responder rules associated with the recipe after applying all defaults
        """
        return pulumi.get(self, "effective_responder_rules")

    @effective_responder_rules.setter
    def effective_responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleArgs']]]]):
        pulumi.set(self, "effective_responder_rules", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of TargetResponderRecipe that is immutable on creation
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of ResponderRecipe
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="responderRules")
    def responder_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleArgs']]]]:
        """
        (Updatable) Override responder rules associated with reponder recipe in a target.
        """
        return pulumi.get(self, "responder_rules")

    @responder_rules.setter
    def responder_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleArgs']]]]):
        pulumi.set(self, "responder_rules", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 responder_rule_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) compartment associated with condition
        :param pulumi.Input[str] description: The target description.
        :param pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsArgs'] details: (Updatable) Details of ResponderRule.
        :param pulumi.Input[str] display_name: (Updatable) DetectorTemplate Identifier
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of Policy
        :param pulumi.Input[str] responder_rule_id: (Updatable) Identifier for ResponderRule.
        :param pulumi.Input[str] state: (Updatable) The current state of the DetectorRule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported Execution Modes
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of Responder
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if responder_rule_id is not None:
            pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsArgs']]:
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsArgs']]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorTemplate Identifier
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Identifier for ResponderRule.
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: (Updatable)
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]] configurations: (Updatable) Configurations associated with the ResponderRule
        :param pulumi.Input[bool] is_enabled: Identifies state for ResponderRule
        :param pulumi.Input[str] mode: (Updatable) Execution Mode for ResponderRule
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class CloudGuardTargetTargetResponderRecipeEffectiveResponderRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique name of the configuration
        :param pulumi.Input[str] name: (Updatable) configuration name
        :param pulumi.Input[str] value: (Updatable) configuration value
        """
        if config_key is not None:
            pulumi.set(__self__, "config_key", config_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudGuardTargetTargetResponderRecipeResponderRuleArgs:
    def __init__(__self__, *,
                 details: pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsArgs'],
                 responder_rule_id: pulumi.Input[str],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 supported_modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsArgs'] details: (Updatable) Details of ResponderRule.
        :param pulumi.Input[str] responder_rule_id: (Updatable) Identifier for ResponderRule.
        :param pulumi.Input[str] compartment_id: (Updatable) compartment associated with condition
        :param pulumi.Input[str] description: The target description.
        :param pulumi.Input[str] display_name: (Updatable) DetectorTemplate Identifier
        :param pulumi.Input[str] lifecycle_details: A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] policies: List of Policy
        :param pulumi.Input[str] state: (Updatable) The current state of the DetectorRule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_modes: Supported Execution Modes
        :param pulumi.Input[str] time_created: The date and time the target was created. Format defined by RFC3339.
        :param pulumi.Input[str] time_updated: The date and time the target was updated. Format defined by RFC3339.
        :param pulumi.Input[str] type: Type of Responder
        """
        pulumi.set(__self__, "details", details)
        pulumi.set(__self__, "responder_rule_id", responder_rule_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if supported_modes is not None:
            pulumi.set(__self__, "supported_modes", supported_modes)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def details(self) -> pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsArgs']:
        """
        (Updatable) Details of ResponderRule.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsArgs']):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter(name="responderRuleId")
    def responder_rule_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Identifier for ResponderRule.
        """
        return pulumi.get(self, "responder_rule_id")

    @responder_rule_id.setter
    def responder_rule_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "responder_rule_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) compartment associated with condition
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The target description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DetectorTemplate Identifier
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        A message describing the current state in more detail. For example, can be used to provide actionable information for a resource in Failed state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Policy
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the DetectorRule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="supportedModes")
    def supported_modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Supported Execution Modes
        """
        return pulumi.get(self, "supported_modes")

    @supported_modes.setter
    def supported_modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_modes", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was created. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the target was updated. Format defined by RFC3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Responder
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CloudGuardTargetTargetResponderRecipeResponderRuleDetailsArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] condition: (Updatable)
        :param pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]] configurations: (Updatable) Configurations associated with the ResponderRule
        :param pulumi.Input[bool] is_enabled: Identifies state for ResponderRule
        :param pulumi.Input[str] mode: (Updatable) Execution Mode for ResponderRule
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]]]:
        """
        (Updatable) Configurations associated with the ResponderRule
        """
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudGuardTargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs']]]]):
        pulumi.set(self, "configurations", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Identifies state for ResponderRule
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Execution Mode for ResponderRule
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class CloudGuardTargetTargetResponderRecipeResponderRuleDetailsConfigurationArgs:
    def __init__(__self__, *,
                 config_key: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] config_key: (Updatable) Unique name of the configuration
        :param pulumi.Input[str] name: (Updatable) configuration name
        :param pulumi.Input[str] value: (Updatable) configuration value
        """
        pulumi.set(__self__, "config_key", config_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="configKey")
    def config_key(self) -> pulumi.Input[str]:
        """
        (Updatable) Unique name of the configuration
        """
        return pulumi.get(self, "config_key")

    @config_key.setter
    def config_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) configuration value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ContainerengineClusterEndpointConfigArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 is_public_ip_enabled: Optional[pulumi.Input[bool]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] subnet_id: The OCID of the regional subnet in which to place the Cluster endpoint.
        :param pulumi.Input[bool] is_public_ip_enabled: Whether the cluster should be assigned a public IP address. Defaults to false. If set to true on a private subnet, the cluster provisioning will fail.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: A list of the OCIDs of the network security groups (NSGs) to apply to the cluster endpoint. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/NetworkSecurityGroup/).
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if is_public_ip_enabled is not None:
            pulumi.set(__self__, "is_public_ip_enabled", is_public_ip_enabled)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The OCID of the regional subnet in which to place the Cluster endpoint.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="isPublicIpEnabled")
    def is_public_ip_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the cluster should be assigned a public IP address. Defaults to false. If set to true on a private subnet, the cluster provisioning will fail.
        """
        return pulumi.get(self, "is_public_ip_enabled")

    @is_public_ip_enabled.setter
    def is_public_ip_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_public_ip_enabled", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the OCIDs of the network security groups (NSGs) to apply to the cluster endpoint. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)


@pulumi.input_type
class ContainerengineClusterEndpointsArgs:
    def __init__(__self__, *,
                 kubernetes: Optional[pulumi.Input[str]] = None,
                 private_endpoint: Optional[pulumi.Input[str]] = None,
                 public_endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kubernetes: The non-native networking Kubernetes API server endpoint.
        :param pulumi.Input[str] private_endpoint: The private native networking Kubernetes API server endpoint.
        :param pulumi.Input[str] public_endpoint: The public native networking Kubernetes API server endpoint, if one was requested.
        """
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)
        if private_endpoint is not None:
            pulumi.set(__self__, "private_endpoint", private_endpoint)
        if public_endpoint is not None:
            pulumi.set(__self__, "public_endpoint", public_endpoint)

    @property
    @pulumi.getter
    def kubernetes(self) -> Optional[pulumi.Input[str]]:
        """
        The non-native networking Kubernetes API server endpoint.
        """
        return pulumi.get(self, "kubernetes")

    @kubernetes.setter
    def kubernetes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes", value)

    @property
    @pulumi.getter(name="privateEndpoint")
    def private_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The private native networking Kubernetes API server endpoint.
        """
        return pulumi.get(self, "private_endpoint")

    @private_endpoint.setter
    def private_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_endpoint", value)

    @property
    @pulumi.getter(name="publicEndpoint")
    def public_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        The public native networking Kubernetes API server endpoint, if one was requested.
        """
        return pulumi.get(self, "public_endpoint")

    @public_endpoint.setter
    def public_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_endpoint", value)


@pulumi.input_type
class ContainerengineClusterImagePolicyConfigArgs:
    def __init__(__self__, *,
                 is_policy_enabled: Optional[pulumi.Input[bool]] = None,
                 key_details: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerengineClusterImagePolicyConfigKeyDetailArgs']]]] = None):
        """
        :param pulumi.Input[bool] is_policy_enabled: (Updatable) Whether the image verification policy is enabled. Defaults to false. If set to true, the images will be verified against the policy at runtime.
        :param pulumi.Input[Sequence[pulumi.Input['ContainerengineClusterImagePolicyConfigKeyDetailArgs']]] key_details: (Updatable) A list of KMS key details.
        """
        if is_policy_enabled is not None:
            pulumi.set(__self__, "is_policy_enabled", is_policy_enabled)
        if key_details is not None:
            pulumi.set(__self__, "key_details", key_details)

    @property
    @pulumi.getter(name="isPolicyEnabled")
    def is_policy_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the image verification policy is enabled. Defaults to false. If set to true, the images will be verified against the policy at runtime.
        """
        return pulumi.get(self, "is_policy_enabled")

    @is_policy_enabled.setter
    def is_policy_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_policy_enabled", value)

    @property
    @pulumi.getter(name="keyDetails")
    def key_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContainerengineClusterImagePolicyConfigKeyDetailArgs']]]]:
        """
        (Updatable) A list of KMS key details.
        """
        return pulumi.get(self, "key_details")

    @key_details.setter
    def key_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContainerengineClusterImagePolicyConfigKeyDetailArgs']]]]):
        pulumi.set(self, "key_details", value)


@pulumi.input_type
class ContainerengineClusterImagePolicyConfigKeyDetailArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_id: The OCID of the KMS key to be used as the master encryption key for Kubernetes secret encryption. When used, `kubernetesVersion` must be at least `v1.13.0`.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the KMS key to be used as the master encryption key for Kubernetes secret encryption. When used, `kubernetesVersion` must be at least `v1.13.0`.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class ContainerengineClusterMetadataArgs:
    def __init__(__self__, *,
                 created_by_user_id: Optional[pulumi.Input[str]] = None,
                 created_by_work_request_id: Optional[pulumi.Input[str]] = None,
                 deleted_by_user_id: Optional[pulumi.Input[str]] = None,
                 deleted_by_work_request_id: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_deleted: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None,
                 updated_by_user_id: Optional[pulumi.Input[str]] = None,
                 updated_by_work_request_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_by_user_id: The user who created the cluster.
        :param pulumi.Input[str] created_by_work_request_id: The OCID of the work request which created the cluster.
        :param pulumi.Input[str] deleted_by_user_id: The user who deleted the cluster.
        :param pulumi.Input[str] deleted_by_work_request_id: The OCID of the work request which deleted the cluster.
        :param pulumi.Input[str] time_created: The time the cluster was created.
        :param pulumi.Input[str] time_deleted: The time the cluster was deleted.
        :param pulumi.Input[str] time_updated: The time the cluster was updated.
        :param pulumi.Input[str] updated_by_user_id: The user who updated the cluster.
        :param pulumi.Input[str] updated_by_work_request_id: The OCID of the work request which updated the cluster.
        """
        if created_by_user_id is not None:
            pulumi.set(__self__, "created_by_user_id", created_by_user_id)
        if created_by_work_request_id is not None:
            pulumi.set(__self__, "created_by_work_request_id", created_by_work_request_id)
        if deleted_by_user_id is not None:
            pulumi.set(__self__, "deleted_by_user_id", deleted_by_user_id)
        if deleted_by_work_request_id is not None:
            pulumi.set(__self__, "deleted_by_work_request_id", deleted_by_work_request_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_deleted is not None:
            pulumi.set(__self__, "time_deleted", time_deleted)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)
        if updated_by_user_id is not None:
            pulumi.set(__self__, "updated_by_user_id", updated_by_user_id)
        if updated_by_work_request_id is not None:
            pulumi.set(__self__, "updated_by_work_request_id", updated_by_work_request_id)

    @property
    @pulumi.getter(name="createdByUserId")
    def created_by_user_id(self) -> Optional[pulumi.Input[str]]:
        """
        The user who created the cluster.
        """
        return pulumi.get(self, "created_by_user_id")

    @created_by_user_id.setter
    def created_by_user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_by_user_id", value)

    @property
    @pulumi.getter(name="createdByWorkRequestId")
    def created_by_work_request_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the work request which created the cluster.
        """
        return pulumi.get(self, "created_by_work_request_id")

    @created_by_work_request_id.setter
    def created_by_work_request_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_by_work_request_id", value)

    @property
    @pulumi.getter(name="deletedByUserId")
    def deleted_by_user_id(self) -> Optional[pulumi.Input[str]]:
        """
        The user who deleted the cluster.
        """
        return pulumi.get(self, "deleted_by_user_id")

    @deleted_by_user_id.setter
    def deleted_by_user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deleted_by_user_id", value)

    @property
    @pulumi.getter(name="deletedByWorkRequestId")
    def deleted_by_work_request_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the work request which deleted the cluster.
        """
        return pulumi.get(self, "deleted_by_work_request_id")

    @deleted_by_work_request_id.setter
    def deleted_by_work_request_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deleted_by_work_request_id", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The time the cluster was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeDeleted")
    def time_deleted(self) -> Optional[pulumi.Input[str]]:
        """
        The time the cluster was deleted.
        """
        return pulumi.get(self, "time_deleted")

    @time_deleted.setter
    def time_deleted(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_deleted", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time the cluster was updated.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)

    @property
    @pulumi.getter(name="updatedByUserId")
    def updated_by_user_id(self) -> Optional[pulumi.Input[str]]:
        """
        The user who updated the cluster.
        """
        return pulumi.get(self, "updated_by_user_id")

    @updated_by_user_id.setter
    def updated_by_user_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_by_user_id", value)

    @property
    @pulumi.getter(name="updatedByWorkRequestId")
    def updated_by_work_request_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the work request which updated the cluster.
        """
        return pulumi.get(self, "updated_by_work_request_id")

    @updated_by_work_request_id.setter
    def updated_by_work_request_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_by_work_request_id", value)


@pulumi.input_type
class ContainerengineClusterOptionsArgs:
    def __init__(__self__, *,
                 add_ons: Optional[pulumi.Input['ContainerengineClusterOptionsAddOnsArgs']] = None,
                 admission_controller_options: Optional[pulumi.Input['ContainerengineClusterOptionsAdmissionControllerOptionsArgs']] = None,
                 kubernetes_network_config: Optional[pulumi.Input['ContainerengineClusterOptionsKubernetesNetworkConfigArgs']] = None,
                 service_lb_subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['ContainerengineClusterOptionsAddOnsArgs'] add_ons: Configurable cluster add-ons
        :param pulumi.Input['ContainerengineClusterOptionsAdmissionControllerOptionsArgs'] admission_controller_options: (Updatable) Configurable cluster admission controllers
        :param pulumi.Input['ContainerengineClusterOptionsKubernetesNetworkConfigArgs'] kubernetes_network_config: Network configuration for Kubernetes.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_lb_subnet_ids: The OCIDs of the subnets used for Kubernetes services load balancers.
        """
        if add_ons is not None:
            pulumi.set(__self__, "add_ons", add_ons)
        if admission_controller_options is not None:
            pulumi.set(__self__, "admission_controller_options", admission_controller_options)
        if kubernetes_network_config is not None:
            pulumi.set(__self__, "kubernetes_network_config", kubernetes_network_config)
        if service_lb_subnet_ids is not None:
            pulumi.set(__self__, "service_lb_subnet_ids", service_lb_subnet_ids)

    @property
    @pulumi.getter(name="addOns")
    def add_ons(self) -> Optional[pulumi.Input['ContainerengineClusterOptionsAddOnsArgs']]:
        """
        Configurable cluster add-ons
        """
        return pulumi.get(self, "add_ons")

    @add_ons.setter
    def add_ons(self, value: Optional[pulumi.Input['ContainerengineClusterOptionsAddOnsArgs']]):
        pulumi.set(self, "add_ons", value)

    @property
    @pulumi.getter(name="admissionControllerOptions")
    def admission_controller_options(self) -> Optional[pulumi.Input['ContainerengineClusterOptionsAdmissionControllerOptionsArgs']]:
        """
        (Updatable) Configurable cluster admission controllers
        """
        return pulumi.get(self, "admission_controller_options")

    @admission_controller_options.setter
    def admission_controller_options(self, value: Optional[pulumi.Input['ContainerengineClusterOptionsAdmissionControllerOptionsArgs']]):
        pulumi.set(self, "admission_controller_options", value)

    @property
    @pulumi.getter(name="kubernetesNetworkConfig")
    def kubernetes_network_config(self) -> Optional[pulumi.Input['ContainerengineClusterOptionsKubernetesNetworkConfigArgs']]:
        """
        Network configuration for Kubernetes.
        """
        return pulumi.get(self, "kubernetes_network_config")

    @kubernetes_network_config.setter
    def kubernetes_network_config(self, value: Optional[pulumi.Input['ContainerengineClusterOptionsKubernetesNetworkConfigArgs']]):
        pulumi.set(self, "kubernetes_network_config", value)

    @property
    @pulumi.getter(name="serviceLbSubnetIds")
    def service_lb_subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The OCIDs of the subnets used for Kubernetes services load balancers.
        """
        return pulumi.get(self, "service_lb_subnet_ids")

    @service_lb_subnet_ids.setter
    def service_lb_subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_lb_subnet_ids", value)


@pulumi.input_type
class ContainerengineClusterOptionsAddOnsArgs:
    def __init__(__self__, *,
                 is_kubernetes_dashboard_enabled: Optional[pulumi.Input[bool]] = None,
                 is_tiller_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_kubernetes_dashboard_enabled: Whether or not to enable the Kubernetes Dashboard add-on.
        :param pulumi.Input[bool] is_tiller_enabled: Whether or not to enable the Tiller add-on.
        """
        if is_kubernetes_dashboard_enabled is not None:
            pulumi.set(__self__, "is_kubernetes_dashboard_enabled", is_kubernetes_dashboard_enabled)
        if is_tiller_enabled is not None:
            pulumi.set(__self__, "is_tiller_enabled", is_tiller_enabled)

    @property
    @pulumi.getter(name="isKubernetesDashboardEnabled")
    def is_kubernetes_dashboard_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to enable the Kubernetes Dashboard add-on.
        """
        return pulumi.get(self, "is_kubernetes_dashboard_enabled")

    @is_kubernetes_dashboard_enabled.setter
    def is_kubernetes_dashboard_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_kubernetes_dashboard_enabled", value)

    @property
    @pulumi.getter(name="isTillerEnabled")
    def is_tiller_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not to enable the Tiller add-on.
        """
        return pulumi.get(self, "is_tiller_enabled")

    @is_tiller_enabled.setter
    def is_tiller_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_tiller_enabled", value)


@pulumi.input_type
class ContainerengineClusterOptionsAdmissionControllerOptionsArgs:
    def __init__(__self__, *,
                 is_pod_security_policy_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_pod_security_policy_enabled: (Updatable) Whether or not to enable the Pod Security Policy admission controller.
        """
        if is_pod_security_policy_enabled is not None:
            pulumi.set(__self__, "is_pod_security_policy_enabled", is_pod_security_policy_enabled)

    @property
    @pulumi.getter(name="isPodSecurityPolicyEnabled")
    def is_pod_security_policy_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether or not to enable the Pod Security Policy admission controller.
        """
        return pulumi.get(self, "is_pod_security_policy_enabled")

    @is_pod_security_policy_enabled.setter
    def is_pod_security_policy_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pod_security_policy_enabled", value)


@pulumi.input_type
class ContainerengineClusterOptionsKubernetesNetworkConfigArgs:
    def __init__(__self__, *,
                 pods_cidr: Optional[pulumi.Input[str]] = None,
                 services_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] pods_cidr: The CIDR block for Kubernetes pods.
        :param pulumi.Input[str] services_cidr: The CIDR block for Kubernetes services.
        """
        if pods_cidr is not None:
            pulumi.set(__self__, "pods_cidr", pods_cidr)
        if services_cidr is not None:
            pulumi.set(__self__, "services_cidr", services_cidr)

    @property
    @pulumi.getter(name="podsCidr")
    def pods_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block for Kubernetes pods.
        """
        return pulumi.get(self, "pods_cidr")

    @pods_cidr.setter
    def pods_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pods_cidr", value)

    @property
    @pulumi.getter(name="servicesCidr")
    def services_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The CIDR block for Kubernetes services.
        """
        return pulumi.get(self, "services_cidr")

    @services_cidr.setter
    def services_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_cidr", value)


@pulumi.input_type
class ContainerengineNodePoolInitialNodeLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: (Updatable) The key of the pair.
        :param pulumi.Input[str] value: (Updatable) The value of the pair.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The key of the pair.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The value of the pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ContainerengineNodePoolNodeArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 error: Optional[pulumi.Input['ContainerengineNodePoolNodeErrorArgs']] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_pool_id: Optional[pulumi.Input[str]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 public_ip: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain in which to place nodes. Example: `Uocm:PHX-AD-1`
        :param pulumi.Input['ContainerengineNodePoolNodeErrorArgs'] error: An error that may be associated with the node.
        :param pulumi.Input[str] fault_domain: The fault domain of this node.
        :param pulumi.Input[str] id: The OCID of the compute instance backing this node.
        :param pulumi.Input[str] kubernetes_version: (Updatable) The version of Kubernetes to install on the nodes in the node pool.
        :param pulumi.Input[str] lifecycle_details: Details about the state of the node.
        :param pulumi.Input[str] name: (Updatable) The name of the node pool. Avoid entering confidential information.
        :param pulumi.Input[str] node_pool_id: The OCID of the node pool to which this node belongs.
        :param pulumi.Input[str] private_ip: The private IP address of this node.
        :param pulumi.Input[str] public_ip: The public IP address of this node.
        :param pulumi.Input[str] state: The state of the node.
        :param pulumi.Input[str] subnet_id: (Updatable) The OCID of the subnet in which to place nodes.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_pool_id is not None:
            pulumi.set(__self__, "node_pool_id", node_pool_id)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if public_ip is not None:
            pulumi.set(__self__, "public_ip", public_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The availability domain in which to place nodes. Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ContainerengineNodePoolNodeErrorArgs']]:
        """
        An error that may be associated with the node.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ContainerengineNodePoolNodeErrorArgs']]):
        pulumi.set(self, "error", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The fault domain of this node.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compute instance backing this node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The version of Kubernetes to install on the nodes in the node pool.
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Details about the state of the node.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the node pool. Avoid entering confidential information.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodePoolId")
    def node_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the node pool to which this node belongs.
        """
        return pulumi.get(self, "node_pool_id")

    @node_pool_id.setter
    def node_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_pool_id", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The private IP address of this node.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The public IP address of this node.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the node.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the subnet in which to place nodes.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class ContainerengineNodePoolNodeConfigDetailsArgs:
    def __init__(__self__, *,
                 placement_configs: pulumi.Input[Sequence[pulumi.Input['ContainerengineNodePoolNodeConfigDetailsPlacementConfigArgs']]],
                 size: pulumi.Input[int],
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ContainerengineNodePoolNodeConfigDetailsPlacementConfigArgs']]] placement_configs: (Updatable) The placement configurations for the node pool. Provide one placement configuration for each availability domain in which you intend to launch a node.
        :param pulumi.Input[int] size: (Updatable) The number of nodes that should be in the node pool.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) The OCIDs of the Network Security Group(s) to associate nodes for this node pool with. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/NetworkSecurityGroup/).
        """
        pulumi.set(__self__, "placement_configs", placement_configs)
        pulumi.set(__self__, "size", size)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)

    @property
    @pulumi.getter(name="placementConfigs")
    def placement_configs(self) -> pulumi.Input[Sequence[pulumi.Input['ContainerengineNodePoolNodeConfigDetailsPlacementConfigArgs']]]:
        """
        (Updatable) The placement configurations for the node pool. Provide one placement configuration for each availability domain in which you intend to launch a node.
        """
        return pulumi.get(self, "placement_configs")

    @placement_configs.setter
    def placement_configs(self, value: pulumi.Input[Sequence[pulumi.Input['ContainerengineNodePoolNodeConfigDetailsPlacementConfigArgs']]]):
        pulumi.set(self, "placement_configs", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        (Updatable) The number of nodes that should be in the node pool.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The OCIDs of the Network Security Group(s) to associate nodes for this node pool with. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)


@pulumi.input_type
class ContainerengineNodePoolNodeConfigDetailsPlacementConfigArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 subnet_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain in which to place nodes. Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] subnet_id: (Updatable) The OCID of the subnet in which to place nodes.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain in which to place nodes. Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the subnet in which to place nodes.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class ContainerengineNodePoolNodeErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] code: A short error code that defines the upstream error, meant for programmatic parsing. See [API Errors](https://docs.cloud.oracle.com/iaas/Content/API/References/apierrors.htm).
        :param pulumi.Input[str] message: A human-readable error string of the upstream error.
        :param pulumi.Input[str] status: The status of the HTTP response encountered in the upstream error.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[str]]:
        """
        A short error code that defines the upstream error, meant for programmatic parsing. See [API Errors](https://docs.cloud.oracle.com/iaas/Content/API/References/apierrors.htm).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human-readable error string of the upstream error.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the HTTP response encountered in the upstream error.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class ContainerengineNodePoolNodeShapeConfigArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] memory_in_gbs: (Updatable) The total amount of memory available to each node, in gigabytes.
        :param pulumi.Input[float] ocpus: (Updatable) The total number of OCPUs available to each node in the node pool. See [here](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/20160918/Shape/) for details.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total amount of memory available to each node, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total number of OCPUs available to each node in the node pool. See [here](https://docs.cloud.oracle.com/en-us/iaas/api/#/en/iaas/20160918/Shape/) for details.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)


@pulumi.input_type
class ContainerengineNodePoolNodeSourceArgs:
    def __init__(__self__, *,
                 image_id: Optional[pulumi.Input[str]] = None,
                 source_name: Optional[pulumi.Input[str]] = None,
                 source_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_id: (Updatable) The OCID of the image used to boot the node.
        :param pulumi.Input[str] source_name: The user-friendly name of the entity corresponding to the OCID.
        :param pulumi.Input[str] source_type: (Updatable) The source type for the node. Use `IMAGE` when specifying an OCID of an image.
        """
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the image used to boot the node.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user-friendly name of the entity corresponding to the OCID.
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_name", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The source type for the node. Use `IMAGE` when specifying an OCID of an image.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)


@pulumi.input_type
class ContainerengineNodePoolNodeSourceDetailsArgs:
    def __init__(__self__, *,
                 image_id: pulumi.Input[str],
                 source_type: pulumi.Input[str],
                 boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image_id: (Updatable) The OCID of the image used to boot the node.
        :param pulumi.Input[str] source_type: (Updatable) The source type for the node. Use `IMAGE` when specifying an OCID of an image.
        :param pulumi.Input[str] boot_volume_size_in_gbs: (Updatable) The size of the boot volume in GBs. Minimum value is 50 GB. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/Block/Concepts/bootvolumes.htm) for max custom boot volume sizing and OS-specific requirements.
        """
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "source_type", source_type)
        if boot_volume_size_in_gbs is not None:
            pulumi.set(__self__, "boot_volume_size_in_gbs", boot_volume_size_in_gbs)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the image used to boot the node.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The source type for the node. Use `IMAGE` when specifying an OCID of an image.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bootVolumeSizeInGbs")
    def boot_volume_size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The size of the boot volume in GBs. Minimum value is 50 GB. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/Block/Concepts/bootvolumes.htm) for max custom boot volume sizing and OS-specific requirements.
        """
        return pulumi.get(self, "boot_volume_size_in_gbs")

    @boot_volume_size_in_gbs.setter
    def boot_volume_size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_size_in_gbs", value)


@pulumi.input_type
class CoreBootVolumeBackupSourceDetailsArgs:
    def __init__(__self__, *,
                 boot_volume_backup_id: pulumi.Input[str],
                 region: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: The region of the volume backup source.
        :param pulumi.Input[str] kms_key_id: The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        pulumi.set(__self__, "boot_volume_backup_id", boot_volume_backup_id)
        pulumi.set(__self__, "region", region)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="bootVolumeBackupId")
    def boot_volume_backup_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "boot_volume_backup_id")

    @boot_volume_backup_id.setter
    def boot_volume_backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "boot_volume_backup_id", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the volume backup source.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class CoreBootVolumeBootVolumeReplicaArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 boot_volume_replica_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain of the boot volume replica.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] boot_volume_replica_id: The boot volume replica's Oracle ID (OCID).
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        if boot_volume_replica_id is not None:
            pulumi.set(__self__, "boot_volume_replica_id", boot_volume_replica_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain of the boot volume replica.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="bootVolumeReplicaId")
    def boot_volume_replica_id(self) -> Optional[pulumi.Input[str]]:
        """
        The boot volume replica's Oracle ID (OCID).
        """
        return pulumi.get(self, "boot_volume_replica_id")

    @boot_volume_replica_id.setter
    def boot_volume_replica_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_replica_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class CoreBootVolumeSourceDetailsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The OCID of the boot volume replica.
        :param pulumi.Input[str] type: The type can be one of these values: `bootVolume`, `bootVolumeBackup`, `bootVolumeReplica`
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The OCID of the boot volume replica.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `bootVolume`, `bootVolumeBackup`, `bootVolumeReplica`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class CoreClusterNetworkInstancePoolArgs:
    def __init__(__self__, *,
                 instance_configuration_id: pulumi.Input[str],
                 size: pulumi.Input[int],
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolLoadBalancerArgs']]]] = None,
                 placement_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationArgs']]]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_configuration_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance configuration associated with the instance pool.
        :param pulumi.Input[int] size: (Updatable) The number of instances that should be in the instance pool.
        :param pulumi.Input[str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the instance pool.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        :param pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolLoadBalancerArgs']]] load_balancers: The load balancers attached to the instance pool.
        :param pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationArgs']]] placement_configurations: The placement configurations for the instance pool.
        :param pulumi.Input[str] state: The current state of the cluster network.
        :param pulumi.Input[str] time_created: The date and time the resource was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        pulumi.set(__self__, "instance_configuration_id", instance_configuration_id)
        pulumi.set(__self__, "size", size)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)
        if placement_configurations is not None:
            pulumi.set(__self__, "placement_configurations", placement_configurations)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter(name="instanceConfigurationId")
    def instance_configuration_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance configuration associated with the instance pool.
        """
        return pulumi.get(self, "instance_configuration_id")

    @instance_configuration_id.setter
    def instance_configuration_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_configuration_id", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[int]:
        """
        (Updatable) The number of instances that should be in the instance pool.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[int]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the instance pool.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolLoadBalancerArgs']]]]:
        """
        The load balancers attached to the instance pool.
        """
        return pulumi.get(self, "load_balancers")

    @load_balancers.setter
    def load_balancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolLoadBalancerArgs']]]]):
        pulumi.set(self, "load_balancers", value)

    @property
    @pulumi.getter(name="placementConfigurations")
    def placement_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationArgs']]]]:
        """
        The placement configurations for the instance pool.
        """
        return pulumi.get(self, "placement_configurations")

    @placement_configurations.setter
    def placement_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationArgs']]]]):
        pulumi.set(self, "placement_configurations", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cluster network.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the resource was created, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).  Example: `2016-08-25T21:10:29.600Z`
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


@pulumi.input_type
class CoreClusterNetworkInstancePoolLoadBalancerArgs:
    def __init__(__self__, *,
                 backend_set_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 vnic_selection: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_set_name: The name of the backend set on the load balancer.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        :param pulumi.Input[str] instance_pool_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        :param pulumi.Input[str] load_balancer_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attached to the instance pool.
        :param pulumi.Input[int] port: The port value used for the backends.
        :param pulumi.Input[str] state: The current state of the cluster network.
        :param pulumi.Input[str] vnic_selection: Indicates which VNIC on each instance in the instance pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        """
        if backend_set_name is not None:
            pulumi.set(__self__, "backend_set_name", backend_set_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if load_balancer_id is not None:
            pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if vnic_selection is not None:
            pulumi.set(__self__, "vnic_selection", vnic_selection)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the backend set on the load balancer.
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_set_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attached to the instance pool.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port value used for the backends.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cluster network.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="vnicSelection")
    def vnic_selection(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates which VNIC on each instance in the instance pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        """
        return pulumi.get(self, "vnic_selection")

    @vnic_selection.setter
    def vnic_selection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnic_selection", value)


@pulumi.input_type
class CoreClusterNetworkInstancePoolPlacementConfigurationArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 fault_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 primary_subnet_id: Optional[pulumi.Input[str]] = None,
                 secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fault_domains: The fault domains to place instances.
        :param pulumi.Input[str] primary_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances.
        :param pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]] secondary_vnic_subnets: The set of secondary VNIC data for instances in the pool.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fault_domains is not None:
            pulumi.set(__self__, "fault_domains", fault_domains)
        if primary_subnet_id is not None:
            pulumi.set(__self__, "primary_subnet_id", primary_subnet_id)
        if secondary_vnic_subnets is not None:
            pulumi.set(__self__, "secondary_vnic_subnets", secondary_vnic_subnets)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The fault domains to place instances.
        """
        return pulumi.get(self, "fault_domains")

    @fault_domains.setter
    def fault_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fault_domains", value)

    @property
    @pulumi.getter(name="primarySubnetId")
    def primary_subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances.
        """
        return pulumi.get(self, "primary_subnet_id")

    @primary_subnet_id.setter
    def primary_subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_subnet_id", value)

    @property
    @pulumi.getter(name="secondaryVnicSubnets")
    def secondary_vnic_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]:
        """
        The set of secondary VNIC data for instances in the pool.
        """
        return pulumi.get(self, "secondary_vnic_subnets")

    @secondary_vnic_subnets.setter
    def secondary_vnic_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]):
        pulumi.set(self, "secondary_vnic_subnets", value)


@pulumi.input_type
class CoreClusterNetworkInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        :param pulumi.Input[str] subnet_id: The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class CoreClusterNetworkPlacementConfigurationArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 primary_subnet_id: pulumi.Input[str],
                 secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] primary_subnet_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances.
        :param pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]] secondary_vnic_subnets: The set of secondary VNIC data for instances in the pool.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "primary_subnet_id", primary_subnet_id)
        if secondary_vnic_subnets is not None:
            pulumi.set(__self__, "secondary_vnic_subnets", secondary_vnic_subnets)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="primarySubnetId")
    def primary_subnet_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances.
        """
        return pulumi.get(self, "primary_subnet_id")

    @primary_subnet_id.setter
    def primary_subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_subnet_id", value)

    @property
    @pulumi.getter(name="secondaryVnicSubnets")
    def secondary_vnic_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]]]:
        """
        The set of secondary VNIC data for instances in the pool.
        """
        return pulumi.get(self, "secondary_vnic_subnets")

    @secondary_vnic_subnets.setter
    def secondary_vnic_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs']]]]):
        pulumi.set(self, "secondary_vnic_subnets", value)


@pulumi.input_type
class CoreClusterNetworkPlacementConfigurationSecondaryVnicSubnetArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        :param pulumi.Input[str] display_name: The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class CoreComputeCapacityReservationInstanceReservationConfigArgs:
    def __init__(__self__, *,
                 instance_shape: pulumi.Input[str],
                 reserved_count: pulumi.Input[str],
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 instance_shape_config: Optional[pulumi.Input['CoreComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs']] = None,
                 used_count: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] instance_shape: (Updatable) The shape requested when launching instances using reserved capacity. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance. You can list all available shapes by calling [ListComputeCapacityReservationInstanceShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/computeCapacityReservationInstanceShapes/ListComputeCapacityReservationInstanceShapes).
        :param pulumi.Input[str] reserved_count: (Updatable) The amount of capacity to reserve in this reservation configuration.
        :param pulumi.Input[str] fault_domain: (Updatable) The fault domain to use for instances created using this reservation configuration. For more information, see [Fault Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm#fault). If you do not specify the fault domain, the capacity is available for an instance that does not specify a fault domain. To change the fault domain for a reservation, delete the reservation and create a new one in the preferred fault domain.
        :param pulumi.Input['CoreComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs'] instance_shape_config: (Updatable) The shape configuration requested when launching instances in a compute capacity reservation.
        :param pulumi.Input[str] used_count: The amount of capacity in use out of the total capacity reserved in this reservation configuration.
        """
        pulumi.set(__self__, "instance_shape", instance_shape)
        pulumi.set(__self__, "reserved_count", reserved_count)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if instance_shape_config is not None:
            pulumi.set(__self__, "instance_shape_config", instance_shape_config)
        if used_count is not None:
            pulumi.set(__self__, "used_count", used_count)

    @property
    @pulumi.getter(name="instanceShape")
    def instance_shape(self) -> pulumi.Input[str]:
        """
        (Updatable) The shape requested when launching instances using reserved capacity. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance. You can list all available shapes by calling [ListComputeCapacityReservationInstanceShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/computeCapacityReservationInstanceShapes/ListComputeCapacityReservationInstanceShapes).
        """
        return pulumi.get(self, "instance_shape")

    @instance_shape.setter
    def instance_shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_shape", value)

    @property
    @pulumi.getter(name="reservedCount")
    def reserved_count(self) -> pulumi.Input[str]:
        """
        (Updatable) The amount of capacity to reserve in this reservation configuration.
        """
        return pulumi.get(self, "reserved_count")

    @reserved_count.setter
    def reserved_count(self, value: pulumi.Input[str]):
        pulumi.set(self, "reserved_count", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The fault domain to use for instances created using this reservation configuration. For more information, see [Fault Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm#fault). If you do not specify the fault domain, the capacity is available for an instance that does not specify a fault domain. To change the fault domain for a reservation, delete the reservation and create a new one in the preferred fault domain.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter(name="instanceShapeConfig")
    def instance_shape_config(self) -> Optional[pulumi.Input['CoreComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs']]:
        """
        (Updatable) The shape configuration requested when launching instances in a compute capacity reservation.
        """
        return pulumi.get(self, "instance_shape_config")

    @instance_shape_config.setter
    def instance_shape_config(self, value: Optional[pulumi.Input['CoreComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs']]):
        pulumi.set(self, "instance_shape_config", value)

    @property
    @pulumi.getter(name="usedCount")
    def used_count(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of capacity in use out of the total capacity reserved in this reservation configuration.
        """
        return pulumi.get(self, "used_count")

    @used_count.setter
    def used_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "used_count", value)


@pulumi.input_type
class CoreComputeCapacityReservationInstanceReservationConfigInstanceShapeConfigArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] memory_in_gbs: (Updatable) The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[float] ocpus: (Updatable) The total number of OCPUs available to the instance.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)


@pulumi.input_type
class CoreDefaultDhcpOptionsOptionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 custom_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search_domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "type", type)
        if custom_dns_servers is not None:
            pulumi.set(__self__, "custom_dns_servers", custom_dns_servers)
        if search_domain_names is not None:
            pulumi.set(__self__, "search_domain_names", search_domain_names)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="customDnsServers")
    def custom_dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "custom_dns_servers")

    @custom_dns_servers.setter
    def custom_dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_dns_servers", value)

    @property
    @pulumi.getter(name="searchDomainNames")
    def search_domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "search_domain_names")

    @search_domain_names.setter
    def search_domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_domain_names", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_type", value)


@pulumi.input_type
class CoreDefaultRouteTableRouteRuleArgs:
    def __init__(__self__, *,
                 network_entity_id: pulumi.Input[str],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 destination: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "network_entity_id", network_entity_id)
        if cidr_block is not None:
            warnings.warn("""The 'cidr_block' field has been deprecated. Please use 'destination' instead.""", DeprecationWarning)
            pulumi.log.warn("""cidr_block is deprecated: The 'cidr_block' field has been deprecated. Please use 'destination' instead.""")
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)

    @property
    @pulumi.getter(name="networkEntityId")
    def network_entity_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "network_entity_id")

    @network_entity_id.setter
    def network_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_entity_id", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)


@pulumi.input_type
class CoreDefaultSecurityListEgressSecurityRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleIcmpOptionsArgs']] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleUdpOptionsArgs']] = None):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if icmp_options is not None:
            pulumi.set(__self__, "icmp_options", icmp_options)
        if stateless is not None:
            pulumi.set(__self__, "stateless", stateless)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if udp_options is not None:
            pulumi.set(__self__, "udp_options", udp_options)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleIcmpOptionsArgs']]:
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleTcpOptionsArgs']]:
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleUdpOptionsArgs']]:
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class CoreDefaultSecurityListEgressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class CoreDefaultSecurityListEgressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreDefaultSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreDefaultSecurityListEgressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreDefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreDefaultSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreDefaultSecurityListIngressSecurityRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleIcmpOptionsArgs']] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleUdpOptionsArgs']] = None):
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_options is not None:
            pulumi.set(__self__, "icmp_options", icmp_options)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if stateless is not None:
            pulumi.set(__self__, "stateless", stateless)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if udp_options is not None:
            pulumi.set(__self__, "udp_options", udp_options)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleIcmpOptionsArgs']]:
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleTcpOptionsArgs']]:
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleUdpOptionsArgs']]:
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class CoreDefaultSecurityListIngressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class CoreDefaultSecurityListIngressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreDefaultSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreDefaultSecurityListIngressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreDefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreDefaultSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreDhcpOptionsOptionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 custom_dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search_domain_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) The specific DHCP option. Either `DomainNameServer` (for [DhcpDnsOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpDnsOption/)) or `SearchDomain` (for [DhcpSearchDomainOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpSearchDomainOption/)).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_dns_servers: (Updatable) If you set `serverType` to `CustomDnsServer`, specify the IP address of at least one DNS server of your choice (three maximum).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_domain_names: (Updatable) A single search domain name according to [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). During a DNS query, the OS will append this search domain name to the value being queried.
        :param pulumi.Input[str] server_type: (Updatable) 
               * **VcnLocal:** Reserved for future use.
               * **VcnLocalPlusInternet:** Also referred to as "Internet and VCN Resolver". Instances can resolve internet hostnames (no internet gateway is required), and can resolve hostnames of instances in the VCN. This is the default value in the default set of DHCP options in the VCN. For the Internet and VCN Resolver to work across the VCN, there must also be a DNS label set for the VCN, a DNS label set for each subnet, and a hostname for each instance. The Internet and VCN Resolver also enables reverse DNS lookup, which lets you determine the hostname corresponding to the private IP address. For more information, see [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/dns.htm).
               * **CustomDnsServer:** Instances use a DNS server of your choice (three maximum).
        """
        pulumi.set(__self__, "type", type)
        if custom_dns_servers is not None:
            pulumi.set(__self__, "custom_dns_servers", custom_dns_servers)
        if search_domain_names is not None:
            pulumi.set(__self__, "search_domain_names", search_domain_names)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The specific DHCP option. Either `DomainNameServer` (for [DhcpDnsOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpDnsOption/)) or `SearchDomain` (for [DhcpSearchDomainOption](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/DhcpSearchDomainOption/)).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="customDnsServers")
    def custom_dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) If you set `serverType` to `CustomDnsServer`, specify the IP address of at least one DNS server of your choice (three maximum).
        """
        return pulumi.get(self, "custom_dns_servers")

    @custom_dns_servers.setter
    def custom_dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_dns_servers", value)

    @property
    @pulumi.getter(name="searchDomainNames")
    def search_domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A single search domain name according to [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). During a DNS query, the OS will append this search domain name to the value being queried.
        """
        return pulumi.get(self, "search_domain_names")

    @search_domain_names.setter
    def search_domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_domain_names", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) 
        * **VcnLocal:** Reserved for future use.
        * **VcnLocalPlusInternet:** Also referred to as "Internet and VCN Resolver". Instances can resolve internet hostnames (no internet gateway is required), and can resolve hostnames of instances in the VCN. This is the default value in the default set of DHCP options in the VCN. For the Internet and VCN Resolver to work across the VCN, there must also be a DNS label set for the VCN, a DNS label set for each subnet, and a hostname for each instance. The Internet and VCN Resolver also enables reverse DNS lookup, which lets you determine the hostname corresponding to the private IP address. For more information, see [DNS in Your Virtual Cloud Network](https://docs.cloud.oracle.com/iaas/Content/Network/Concepts/dns.htm).
        * **CustomDnsServer:** Instances use a DNS server of your choice (three maximum).
        """
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_type", value)


@pulumi.input_type
class CoreDrgAttachmentManagementNetworkDetailsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 ipsec_connection_id: Optional[pulumi.Input[str]] = None,
                 route_table_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: -(Required) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        :param pulumi.Input[str] type: The type can be one of these values: `IPSEC_TUNNEL`, `REMOTE_PEERING_CONNECTION`, `VIRTUAL_CIRCUIT`
               * `route_table_id`(Optional)(Updatable) - The OCID of the route table the DRG attachment is using.
        :param pulumi.Input[str] ipsec_connection_id: The IPSec connection that contains the attached IPSec tunnel.
        :param pulumi.Input[str] route_table_id: (Updatable)- The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the route table the DRG attachment is using.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if ipsec_connection_id is not None:
            pulumi.set(__self__, "ipsec_connection_id", ipsec_connection_id)
        if route_table_id is not None:
            pulumi.set(__self__, "route_table_id", route_table_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        -(Required) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `IPSEC_TUNNEL`, `REMOTE_PEERING_CONNECTION`, `VIRTUAL_CIRCUIT`
        * `route_table_id`(Optional)(Updatable) - The OCID of the route table the DRG attachment is using.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="ipsecConnectionId")
    def ipsec_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The IPSec connection that contains the attached IPSec tunnel.
        """
        return pulumi.get(self, "ipsec_connection_id")

    @ipsec_connection_id.setter
    def ipsec_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_connection_id", value)

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)- The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the route table the DRG attachment is using.
        """
        return pulumi.get(self, "route_table_id")

    @route_table_id.setter
    def route_table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_id", value)


@pulumi.input_type
class CoreDrgAttachmentNetworkDetailsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 ipsec_connection_id: Optional[pulumi.Input[str]] = None,
                 route_table_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        :param pulumi.Input[str] type: (Updatable) The type can be one of these values: `IPSEC_TUNNEL`, `REMOTE_PEERING_CONNECTION`, `VCN`, `VIRTUAL_CIRCUIT`
        :param pulumi.Input[str] ipsec_connection_id: The IPSec connection that contains the attached IPSec tunnel.
        :param pulumi.Input[str] route_table_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the route table used by the DRG attachment.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if ipsec_connection_id is not None:
            pulumi.set(__self__, "ipsec_connection_id", ipsec_connection_id)
        if route_table_id is not None:
            pulumi.set(__self__, "route_table_id", route_table_id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network attached to the DRG.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type can be one of these values: `IPSEC_TUNNEL`, `REMOTE_PEERING_CONNECTION`, `VCN`, `VIRTUAL_CIRCUIT`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="ipsecConnectionId")
    def ipsec_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The IPSec connection that contains the attached IPSec tunnel.
        """
        return pulumi.get(self, "ipsec_connection_id")

    @ipsec_connection_id.setter
    def ipsec_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_connection_id", value)

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the route table used by the DRG attachment.
        """
        return pulumi.get(self, "route_table_id")

    @route_table_id.setter
    def route_table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_id", value)


@pulumi.input_type
class CoreDrgAttachmentsListDrgAllAttachmentArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The Oracle-assigned ID of the DRG attachment
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle-assigned ID of the DRG attachment
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class CoreDrgDefaultDrgRouteTablesArgs:
    def __init__(__self__, *,
                 ipsec_tunnel: Optional[pulumi.Input[str]] = None,
                 remote_peering_connection: Optional[pulumi.Input[str]] = None,
                 vcn: Optional[pulumi.Input[str]] = None,
                 virtual_circuit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ipsec_tunnel: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table assigned to DRG attachments of type IPSEC_TUNNEL on creation.
        :param pulumi.Input[str] remote_peering_connection: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type REMOTE_PEERING_CONNECTION on creation.
        :param pulumi.Input[str] vcn: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type VCN on creation.
        :param pulumi.Input[str] virtual_circuit: The OCID of the default DRG route table to be assigned to DRG attachments of type VIRTUAL_CIRCUIT on creation.
        """
        if ipsec_tunnel is not None:
            pulumi.set(__self__, "ipsec_tunnel", ipsec_tunnel)
        if remote_peering_connection is not None:
            pulumi.set(__self__, "remote_peering_connection", remote_peering_connection)
        if vcn is not None:
            pulumi.set(__self__, "vcn", vcn)
        if virtual_circuit is not None:
            pulumi.set(__self__, "virtual_circuit", virtual_circuit)

    @property
    @pulumi.getter(name="ipsecTunnel")
    def ipsec_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table assigned to DRG attachments of type IPSEC_TUNNEL on creation.
        """
        return pulumi.get(self, "ipsec_tunnel")

    @ipsec_tunnel.setter
    def ipsec_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_tunnel", value)

    @property
    @pulumi.getter(name="remotePeeringConnection")
    def remote_peering_connection(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type REMOTE_PEERING_CONNECTION on creation.
        """
        return pulumi.get(self, "remote_peering_connection")

    @remote_peering_connection.setter
    def remote_peering_connection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_peering_connection", value)

    @property
    @pulumi.getter
    def vcn(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the default DRG route table to be assigned to DRG attachments of type VCN on creation.
        """
        return pulumi.get(self, "vcn")

    @vcn.setter
    def vcn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcn", value)

    @property
    @pulumi.getter(name="virtualCircuit")
    def virtual_circuit(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the default DRG route table to be assigned to DRG attachments of type VIRTUAL_CIRCUIT on creation.
        """
        return pulumi.get(self, "virtual_circuit")

    @virtual_circuit.setter
    def virtual_circuit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_circuit", value)


@pulumi.input_type
class CoreDrgRouteDistributionStatementMatchCriteriaArgs:
    def __init__(__self__, *,
                 attachment_type: Optional[pulumi.Input[str]] = None,
                 drg_attachment_id: Optional[pulumi.Input[str]] = None,
                 match_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attachment_type: The type of the network resource to be included in this match. A match for a network type implies that all DRG attachments of that type insert routes into the table.
        :param pulumi.Input[str] drg_attachment_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG attachment.
        :param pulumi.Input[str] match_type: (Updatable) The type of the match criteria for a route distribution statement.
        """
        if attachment_type is not None:
            pulumi.set(__self__, "attachment_type", attachment_type)
        if drg_attachment_id is not None:
            pulumi.set(__self__, "drg_attachment_id", drg_attachment_id)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter(name="attachmentType")
    def attachment_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the network resource to be included in this match. A match for a network type implies that all DRG attachments of that type insert routes into the table.
        """
        return pulumi.get(self, "attachment_type")

    @attachment_type.setter
    def attachment_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attachment_type", value)

    @property
    @pulumi.getter(name="drgAttachmentId")
    def drg_attachment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the DRG attachment.
        """
        return pulumi.get(self, "drg_attachment_id")

    @drg_attachment_id.setter
    def drg_attachment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drg_attachment_id", value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of the match criteria for a route distribution statement.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)


@pulumi.input_type
class CoreImageAgentFeaturesArgs:
    def __init__(__self__, *,
                 is_management_supported: Optional[pulumi.Input[bool]] = None,
                 is_monitoring_supported: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_management_supported: This attribute is not used.
        :param pulumi.Input[bool] is_monitoring_supported: This attribute is not used.
        """
        if is_management_supported is not None:
            pulumi.set(__self__, "is_management_supported", is_management_supported)
        if is_monitoring_supported is not None:
            pulumi.set(__self__, "is_monitoring_supported", is_monitoring_supported)

    @property
    @pulumi.getter(name="isManagementSupported")
    def is_management_supported(self) -> Optional[pulumi.Input[bool]]:
        """
        This attribute is not used.
        """
        return pulumi.get(self, "is_management_supported")

    @is_management_supported.setter
    def is_management_supported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_management_supported", value)

    @property
    @pulumi.getter(name="isMonitoringSupported")
    def is_monitoring_supported(self) -> Optional[pulumi.Input[bool]]:
        """
        This attribute is not used.
        """
        return pulumi.get(self, "is_monitoring_supported")

    @is_monitoring_supported.setter
    def is_monitoring_supported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monitoring_supported", value)


@pulumi.input_type
class CoreImageImageSourceDetailsArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 namespace_name: Optional[pulumi.Input[str]] = None,
                 object_name: Optional[pulumi.Input[str]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 operating_system_version: Optional[pulumi.Input[str]] = None,
                 source_image_type: Optional[pulumi.Input[str]] = None,
                 source_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: The source type for the image. Use `objectStorageTuple` when specifying the namespace, bucket name, and object name. Use `objectStorageUri` when specifying the Object Storage URL.
        :param pulumi.Input[str] bucket_name: The Object Storage bucket for the image.
        :param pulumi.Input[str] namespace_name: The Object Storage namespace for the image.
        :param pulumi.Input[str] object_name: The Object Storage name for the image.
        :param pulumi.Input[str] operating_system: The image's operating system.  Example: `Oracle Linux`
        :param pulumi.Input[str] operating_system_version: The image's operating system version.  Example: `7.2`
        :param pulumi.Input[str] source_image_type: The format of the image to be imported.  Only monolithic images are supported. This attribute is not used for exported Oracle images with the Oracle Cloud Infrastructure image format. Allowed values are:
               * `QCOW2`
               * `VMDK`
        :param pulumi.Input[str] source_uri: The Object Storage URL for the image.
        """
        pulumi.set(__self__, "source_type", source_type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if namespace_name is not None:
            pulumi.set(__self__, "namespace_name", namespace_name)
        if object_name is not None:
            pulumi.set(__self__, "object_name", object_name)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if operating_system_version is not None:
            pulumi.set(__self__, "operating_system_version", operating_system_version)
        if source_image_type is not None:
            pulumi.set(__self__, "source_image_type", source_image_type)
        if source_uri is not None:
            pulumi.set(__self__, "source_uri", source_uri)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The source type for the image. Use `objectStorageTuple` when specifying the namespace, bucket name, and object name. Use `objectStorageUri` when specifying the Object Storage URL.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage bucket for the image.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="namespaceName")
    def namespace_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage namespace for the image.
        """
        return pulumi.get(self, "namespace_name")

    @namespace_name.setter
    def namespace_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_name", value)

    @property
    @pulumi.getter(name="objectName")
    def object_name(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage name for the image.
        """
        return pulumi.get(self, "object_name")

    @object_name.setter
    def object_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_name", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system.  Example: `Oracle Linux`
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="operatingSystemVersion")
    def operating_system_version(self) -> Optional[pulumi.Input[str]]:
        """
        The image's operating system version.  Example: `7.2`
        """
        return pulumi.get(self, "operating_system_version")

    @operating_system_version.setter
    def operating_system_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system_version", value)

    @property
    @pulumi.getter(name="sourceImageType")
    def source_image_type(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the image to be imported.  Only monolithic images are supported. This attribute is not used for exported Oracle images with the Oracle Cloud Infrastructure image format. Allowed values are:
        * `QCOW2`
        * `VMDK`
        """
        return pulumi.get(self, "source_image_type")

    @source_image_type.setter
    def source_image_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_image_type", value)

    @property
    @pulumi.getter(name="sourceUri")
    def source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Object Storage URL for the image.
        """
        return pulumi.get(self, "source_uri")

    @source_uri.setter
    def source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_uri", value)


@pulumi.input_type
class CoreImageLaunchOptionsArgs:
    def __init__(__self__, *,
                 boot_volume_type: Optional[pulumi.Input[str]] = None,
                 firmware: Optional[pulumi.Input[str]] = None,
                 is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 network_type: Optional[pulumi.Input[str]] = None,
                 remote_data_volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_volume_type: Emulation type for the boot volume.
        :param pulumi.Input[str] firmware: Firmware used to boot VM. Select the option that matches your operating system.
        :param pulumi.Input[bool] is_consistent_volume_naming_enabled: Whether to enable consistent volume naming feature. Defaults to false.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/LaunchInstanceDetails).
        :param pulumi.Input[str] network_type: Emulation type for the physical network interface card (NIC).
        :param pulumi.Input[str] remote_data_volume_type: Emulation type for volume.
        """
        if boot_volume_type is not None:
            pulumi.set(__self__, "boot_volume_type", boot_volume_type)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if is_consistent_volume_naming_enabled is not None:
            pulumi.set(__self__, "is_consistent_volume_naming_enabled", is_consistent_volume_naming_enabled)
        if is_pv_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if remote_data_volume_type is not None:
            pulumi.set(__self__, "remote_data_volume_type", remote_data_volume_type)

    @property
    @pulumi.getter(name="bootVolumeType")
    def boot_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the boot volume.
        """
        return pulumi.get(self, "boot_volume_type")

    @boot_volume_type.setter
    def boot_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_type", value)

    @property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[str]]:
        """
        Firmware used to boot VM. Select the option that matches your operating system.
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firmware", value)

    @property
    @pulumi.getter(name="isConsistentVolumeNamingEnabled")
    def is_consistent_volume_naming_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable consistent volume naming feature. Defaults to false.
        """
        return pulumi.get(self, "is_consistent_volume_naming_enabled")

    @is_consistent_volume_naming_enabled.setter
    def is_consistent_volume_naming_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_consistent_volume_naming_enabled", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/LaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the physical network interface card (NIC).
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="remoteDataVolumeType")
    def remote_data_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for volume.
        """
        return pulumi.get(self, "remote_data_volume_type")

    @remote_data_volume_type.setter
    def remote_data_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_data_volume_type", value)


@pulumi.input_type
class CoreInstanceAgentConfigArgs:
    def __init__(__self__, *,
                 are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
                 is_management_disabled: Optional[pulumi.Input[bool]] = None,
                 is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
                 plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceAgentConfigPluginsConfigArgs']]]] = None):
        """
        :param pulumi.Input[bool] are_all_plugins_disabled: (Updatable) Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.
        :param pulumi.Input[bool] is_management_disabled: (Updatable) Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).
        :param pulumi.Input[bool] is_monitoring_disabled: (Updatable) Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).
        :param pulumi.Input[Sequence[pulumi.Input['CoreInstanceAgentConfigPluginsConfigArgs']]] plugins_configs: (Updatable) The configuration of plugins associated with this instance.
        """
        if are_all_plugins_disabled is not None:
            pulumi.set(__self__, "are_all_plugins_disabled", are_all_plugins_disabled)
        if is_management_disabled is not None:
            pulumi.set(__self__, "is_management_disabled", is_management_disabled)
        if is_monitoring_disabled is not None:
            pulumi.set(__self__, "is_monitoring_disabled", is_monitoring_disabled)
        if plugins_configs is not None:
            pulumi.set(__self__, "plugins_configs", plugins_configs)

    @property
    @pulumi.getter(name="areAllPluginsDisabled")
    def are_all_plugins_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.
        """
        return pulumi.get(self, "are_all_plugins_disabled")

    @are_all_plugins_disabled.setter
    def are_all_plugins_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_all_plugins_disabled", value)

    @property
    @pulumi.getter(name="isManagementDisabled")
    def is_management_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).
        """
        return pulumi.get(self, "is_management_disabled")

    @is_management_disabled.setter
    def is_management_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_management_disabled", value)

    @property
    @pulumi.getter(name="isMonitoringDisabled")
    def is_monitoring_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).
        """
        return pulumi.get(self, "is_monitoring_disabled")

    @is_monitoring_disabled.setter
    def is_monitoring_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monitoring_disabled", value)

    @property
    @pulumi.getter(name="pluginsConfigs")
    def plugins_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceAgentConfigPluginsConfigArgs']]]]:
        """
        (Updatable) The configuration of plugins associated with this instance.
        """
        return pulumi.get(self, "plugins_configs")

    @plugins_configs.setter
    def plugins_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceAgentConfigPluginsConfigArgs']]]]):
        pulumi.set(self, "plugins_configs", value)


@pulumi.input_type
class CoreInstanceAgentConfigPluginsConfigArgs:
    def __init__(__self__, *,
                 desired_state: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] desired_state: (Updatable) Whether the plugin should be enabled or disabled.
        :param pulumi.Input[str] name: (Updatable) The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        pulumi.set(__self__, "desired_state", desired_state)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> pulumi.Input[str]:
        """
        (Updatable) Whether the plugin should be enabled or disabled.
        """
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: pulumi.Input[str]):
        pulumi.set(self, "desired_state", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CoreInstanceAvailabilityConfigArgs:
    def __init__(__self__, *,
                 is_live_migration_preferred: Optional[pulumi.Input[bool]] = None,
                 recovery_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_live_migration_preferred: (Updatable) Whether live migration is preferred for infrastructure maintenance.  If null preference is specified, live migration will be preferred for infrastructure maintenance for applicable instances.
        :param pulumi.Input[str] recovery_action: (Updatable) The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        if is_live_migration_preferred is not None:
            pulumi.set(__self__, "is_live_migration_preferred", is_live_migration_preferred)
        if recovery_action is not None:
            pulumi.set(__self__, "recovery_action", recovery_action)

    @property
    @pulumi.getter(name="isLiveMigrationPreferred")
    def is_live_migration_preferred(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether live migration is preferred for infrastructure maintenance.  If null preference is specified, live migration will be preferred for infrastructure maintenance for applicable instances.
        """
        return pulumi.get(self, "is_live_migration_preferred")

    @is_live_migration_preferred.setter
    def is_live_migration_preferred(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_live_migration_preferred", value)

    @property
    @pulumi.getter(name="recoveryAction")
    def recovery_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        return pulumi.get(self, "recovery_action")

    @recovery_action.setter
    def recovery_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_action", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[str],
                 block_volumes: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeArgs']]]] = None,
                 launch_details: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsArgs']] = None,
                 secondary_vnics: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsSecondaryVnicArgs']]]] = None):
        """
        :param pulumi.Input[str] instance_type: The type of instance details. Supported instanceType is compute
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsArgs'] launch_details: Instance launch details for creating an instance from an instance configuration. Use the `sourceDetails` parameter to specify whether a boot volume or an image should be used to launch a new instance.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        if block_volumes is not None:
            pulumi.set(__self__, "block_volumes", block_volumes)
        if launch_details is not None:
            pulumi.set(__self__, "launch_details", launch_details)
        if secondary_vnics is not None:
            pulumi.set(__self__, "secondary_vnics", secondary_vnics)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The type of instance details. Supported instanceType is compute
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="blockVolumes")
    def block_volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeArgs']]]]:
        return pulumi.get(self, "block_volumes")

    @block_volumes.setter
    def block_volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeArgs']]]]):
        pulumi.set(self, "block_volumes", value)

    @property
    @pulumi.getter(name="launchDetails")
    def launch_details(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsArgs']]:
        """
        Instance launch details for creating an instance from an instance configuration. Use the `sourceDetails` parameter to specify whether a boot volume or an image should be used to launch a new instance.
        """
        return pulumi.get(self, "launch_details")

    @launch_details.setter
    def launch_details(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsArgs']]):
        pulumi.set(self, "launch_details", value)

    @property
    @pulumi.getter(name="secondaryVnics")
    def secondary_vnics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsSecondaryVnicArgs']]]]:
        return pulumi.get(self, "secondary_vnics")

    @secondary_vnics.setter
    def secondary_vnics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsSecondaryVnicArgs']]]]):
        pulumi.set(self, "secondary_vnics", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsBlockVolumeArgs:
    def __init__(__self__, *,
                 attach_details: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs']] = None,
                 create_details: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs']] = None,
                 volume_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs'] attach_details: Volume attachmentDetails. Please see [AttachVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/AttachVolumeDetails/)
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs'] create_details: Creates a new block volume. Please see [CreateVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVolumeDetails/)
        :param pulumi.Input[str] volume_id: The OCID of the volume.
        """
        if attach_details is not None:
            pulumi.set(__self__, "attach_details", attach_details)
        if create_details is not None:
            pulumi.set(__self__, "create_details", create_details)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)

    @property
    @pulumi.getter(name="attachDetails")
    def attach_details(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs']]:
        """
        Volume attachmentDetails. Please see [AttachVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/AttachVolumeDetails/)
        """
        return pulumi.get(self, "attach_details")

    @attach_details.setter
    def attach_details(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs']]):
        pulumi.set(self, "attach_details", value)

    @property
    @pulumi.getter(name="createDetails")
    def create_details(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs']]:
        """
        Creates a new block volume. Please see [CreateVolumeDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVolumeDetails/)
        """
        return pulumi.get(self, "create_details")

    @create_details.setter
    def create_details(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs']]):
        pulumi.set(self, "create_details", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsBlockVolumeAttachDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 device: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 is_read_only: Optional[pulumi.Input[bool]] = None,
                 is_shareable: Optional[pulumi.Input[bool]] = None,
                 use_chap: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] device: The device name.
        :param pulumi.Input[str] display_name: A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[bool] is_read_only: Whether the attachment should be created in read-only mode.
        :param pulumi.Input[bool] is_shareable: Whether the attachment should be created in shareable mode. If an attachment is created in shareable mode, then other instances can attach the same volume, provided that they also create their attachments in shareable mode. Only certain volume types can be attached in shareable mode. Defaults to false if not specified.
        :param pulumi.Input[bool] use_chap: Whether to use CHAP authentication for the volume attachment. Defaults to false.
        """
        pulumi.set(__self__, "type", type)
        if device is not None:
            pulumi.set(__self__, "device", device)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if is_pv_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if is_read_only is not None:
            pulumi.set(__self__, "is_read_only", is_read_only)
        if is_shareable is not None:
            pulumi.set(__self__, "is_shareable", is_shareable)
        if use_chap is not None:
            pulumi.set(__self__, "use_chap", use_chap)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def device(self) -> Optional[pulumi.Input[str]]:
        """
        The device name.
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the attachment should be created in read-only mode.
        """
        return pulumi.get(self, "is_read_only")

    @is_read_only.setter
    def is_read_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_read_only", value)

    @property
    @pulumi.getter(name="isShareable")
    def is_shareable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the attachment should be created in shareable mode. If an attachment is created in shareable mode, then other instances can attach the same volume, provided that they also create their attachments in shareable mode. Only certain volume types can be attached in shareable mode. Defaults to false if not specified.
        """
        return pulumi.get(self, "is_shareable")

    @is_shareable.setter
    def is_shareable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_shareable", value)

    @property
    @pulumi.getter(name="useChap")
    def use_chap(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use CHAP authentication for the volume attachment. Defaults to false.
        """
        return pulumi.get(self, "use_chap")

    @use_chap.setter
    def use_chap(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_chap", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 backup_policy_id: Optional[pulumi.Input[str]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 size_in_gbs: Optional[pulumi.Input[str]] = None,
                 source_details: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs']] = None,
                 vpus_per_gb: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] backup_policy_id: If provided, specifies the ID of the volume backup policy to assign to the newly created volume. If omitted, no policy will be assigned.
        :param pulumi.Input[str] compartment_id: The OCID of the compartment.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] kms_key_id: The OCID of the Key Management key to assign as the master encryption key for the volume.
        :param pulumi.Input[str] size_in_gbs: The size of the volume in GBs.
        :param pulumi.Input[str] vpus_per_gb: The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Elastic Performance](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeelasticperformance.htm) for more information.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if backup_policy_id is not None:
            pulumi.set(__self__, "backup_policy_id", backup_policy_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if size_in_gbs is not None:
            pulumi.set(__self__, "size_in_gbs", size_in_gbs)
        if source_details is not None:
            pulumi.set(__self__, "source_details", source_details)
        if vpus_per_gb is not None:
            pulumi.set(__self__, "vpus_per_gb", vpus_per_gb)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="backupPolicyId")
    def backup_policy_id(self) -> Optional[pulumi.Input[str]]:
        """
        If provided, specifies the ID of the volume backup policy to assign to the newly created volume. If omitted, no policy will be assigned.
        """
        return pulumi.get(self, "backup_policy_id")

    @backup_policy_id.setter
    def backup_policy_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_policy_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Key Management key to assign as the master encryption key for the volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="sizeInGbs")
    def size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the volume in GBs.
        """
        return pulumi.get(self, "size_in_gbs")

    @size_in_gbs.setter
    def size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size_in_gbs", value)

    @property
    @pulumi.getter(name="sourceDetails")
    def source_details(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs']]:
        return pulumi.get(self, "source_details")

    @source_details.setter
    def source_details(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs']]):
        pulumi.set(self, "source_details", value)

    @property
    @pulumi.getter(name="vpusPerGb")
    def vpus_per_gb(self) -> Optional[pulumi.Input[str]]:
        """
        The number of volume performance units (VPUs) that will be applied to this volume per GB, representing the Block Volume service's elastic performance options. See [Block Volume Elastic Performance](https://docs.cloud.oracle.com/iaas/Content/Block/Concepts/blockvolumeelasticperformance.htm) for more information.
        """
        return pulumi.get(self, "vpus_per_gb")

    @vpus_per_gb.setter
    def vpus_per_gb(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpus_per_gb", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsBlockVolumeCreateDetailsSourceDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] id: The OCID of the volume backup.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume backup.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsArgs:
    def __init__(__self__, *,
                 agent_config: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs']] = None,
                 availability_config: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs']] = None,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 capacity_reservation_id: Optional[pulumi.Input[str]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 create_vnic_details: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs']] = None,
                 dedicated_vm_host_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 extended_metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 instance_options: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs']] = None,
                 ipxe_script: Optional[pulumi.Input[str]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 launch_mode: Optional[pulumi.Input[str]] = None,
                 launch_options: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs']] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 platform_config: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs']] = None,
                 preemptible_instance_config: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs']] = None,
                 preferred_maintenance_action: Optional[pulumi.Input[str]] = None,
                 shape: Optional[pulumi.Input[str]] = None,
                 shape_config: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs']] = None,
                 source_details: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs']] = None):
        """
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs'] agent_config: Configuration options for the Oracle Cloud Agent software running on the instance.
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs'] availability_config: Options for defining the availabiity of a VM instance after a maintenance event that impacts the underlying hardware.
        :param pulumi.Input[str] availability_domain: The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] capacity_reservation_id: The OCID of the compute capacity reservation this instance is launched under.
        :param pulumi.Input[str] compartment_id: The OCID of the compartment.
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs'] create_vnic_details: Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        :param pulumi.Input[str] dedicated_vm_host_id: The OCID of dedicated VM host.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        :param pulumi.Input[Mapping[str, Any]] extended_metadata: Additional metadata key/value pairs that you provide. They serve the same purpose and functionality as fields in the `metadata` object.
        :param pulumi.Input[str] fault_domain: A fault domain is a grouping of hardware and infrastructure within an availability domain. Each availability domain contains three fault domains. Fault domains let you distribute your instances so that they are not on the same physical hardware within a single availability domain. A hardware failure or Compute hardware maintenance that affects one fault domain does not affect instances in other fault domains.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs'] instance_options: Optional mutable instance options. As a part of Instance Metadata Service Security Header, This allows user to disable the legacy imds endpoints.
        :param pulumi.Input[str] ipxe_script: This is an advanced option.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[str] launch_mode: Specifies the configuration mode for launching virtual machine (VM) instances. The configuration modes are:
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs'] launch_options: Options for tuning the compatibility and performance of VM shapes. The values that you specify override any default values.
        :param pulumi.Input[Mapping[str, Any]] metadata: Custom metadata key/value pairs that you provide, such as the SSH public key required to connect to the instance.
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs'] platform_config: The platform configuration requested for the instance.
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs'] preemptible_instance_config: Configuration options for preemptible instances.
        :param pulumi.Input[str] preferred_maintenance_action: The preferred maintenance action for an instance. The default is LIVE_MIGRATE, if live migration is supported.
        :param pulumi.Input[str] shape: The shape of an instance. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance.
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs'] shape_config: The shape configuration requested for the instance.
        """
        if agent_config is not None:
            pulumi.set(__self__, "agent_config", agent_config)
        if availability_config is not None:
            pulumi.set(__self__, "availability_config", availability_config)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if create_vnic_details is not None:
            pulumi.set(__self__, "create_vnic_details", create_vnic_details)
        if dedicated_vm_host_id is not None:
            pulumi.set(__self__, "dedicated_vm_host_id", dedicated_vm_host_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if extended_metadata is not None:
            pulumi.set(__self__, "extended_metadata", extended_metadata)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if instance_options is not None:
            pulumi.set(__self__, "instance_options", instance_options)
        if ipxe_script is not None:
            pulumi.set(__self__, "ipxe_script", ipxe_script)
        if is_pv_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if launch_mode is not None:
            pulumi.set(__self__, "launch_mode", launch_mode)
        if launch_options is not None:
            pulumi.set(__self__, "launch_options", launch_options)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if platform_config is not None:
            pulumi.set(__self__, "platform_config", platform_config)
        if preemptible_instance_config is not None:
            pulumi.set(__self__, "preemptible_instance_config", preemptible_instance_config)
        if preferred_maintenance_action is not None:
            pulumi.set(__self__, "preferred_maintenance_action", preferred_maintenance_action)
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if shape_config is not None:
            pulumi.set(__self__, "shape_config", shape_config)
        if source_details is not None:
            pulumi.set(__self__, "source_details", source_details)

    @property
    @pulumi.getter(name="agentConfig")
    def agent_config(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs']]:
        """
        Configuration options for the Oracle Cloud Agent software running on the instance.
        """
        return pulumi.get(self, "agent_config")

    @agent_config.setter
    def agent_config(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs']]):
        pulumi.set(self, "agent_config", value)

    @property
    @pulumi.getter(name="availabilityConfig")
    def availability_config(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs']]:
        """
        Options for defining the availabiity of a VM instance after a maintenance event that impacts the underlying hardware.
        """
        return pulumi.get(self, "availability_config")

    @availability_config.setter
    def availability_config(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs']]):
        pulumi.set(self, "availability_config", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of the instance.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compute capacity reservation this instance is launched under.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capacity_reservation_id", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="createVnicDetails")
    def create_vnic_details(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs']]:
        """
        Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        """
        return pulumi.get(self, "create_vnic_details")

    @create_vnic_details.setter
    def create_vnic_details(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs']]):
        pulumi.set(self, "create_vnic_details", value)

    @property
    @pulumi.getter(name="dedicatedVmHostId")
    def dedicated_vm_host_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of dedicated VM host.
        """
        return pulumi.get(self, "dedicated_vm_host_id")

    @dedicated_vm_host_id.setter
    def dedicated_vm_host_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dedicated_vm_host_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="extendedMetadata")
    def extended_metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Additional metadata key/value pairs that you provide. They serve the same purpose and functionality as fields in the `metadata` object.
        """
        return pulumi.get(self, "extended_metadata")

    @extended_metadata.setter
    def extended_metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "extended_metadata", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        A fault domain is a grouping of hardware and infrastructure within an availability domain. Each availability domain contains three fault domains. Fault domains let you distribute your instances so that they are not on the same physical hardware within a single availability domain. A hardware failure or Compute hardware maintenance that affects one fault domain does not affect instances in other fault domains.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="instanceOptions")
    def instance_options(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs']]:
        """
        Optional mutable instance options. As a part of Instance Metadata Service Security Header, This allows user to disable the legacy imds endpoints.
        """
        return pulumi.get(self, "instance_options")

    @instance_options.setter
    def instance_options(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs']]):
        pulumi.set(self, "instance_options", value)

    @property
    @pulumi.getter(name="ipxeScript")
    def ipxe_script(self) -> Optional[pulumi.Input[str]]:
        """
        This is an advanced option.
        """
        return pulumi.get(self, "ipxe_script")

    @ipxe_script.setter
    def ipxe_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipxe_script", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="launchMode")
    def launch_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the configuration mode for launching virtual machine (VM) instances. The configuration modes are:
        """
        return pulumi.get(self, "launch_mode")

    @launch_mode.setter
    def launch_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_mode", value)

    @property
    @pulumi.getter(name="launchOptions")
    def launch_options(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs']]:
        """
        Options for tuning the compatibility and performance of VM shapes. The values that you specify override any default values.
        """
        return pulumi.get(self, "launch_options")

    @launch_options.setter
    def launch_options(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs']]):
        pulumi.set(self, "launch_options", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Custom metadata key/value pairs that you provide, such as the SSH public key required to connect to the instance.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="platformConfig")
    def platform_config(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs']]:
        """
        The platform configuration requested for the instance.
        """
        return pulumi.get(self, "platform_config")

    @platform_config.setter
    def platform_config(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs']]):
        pulumi.set(self, "platform_config", value)

    @property
    @pulumi.getter(name="preemptibleInstanceConfig")
    def preemptible_instance_config(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs']]:
        """
        Configuration options for preemptible instances.
        """
        return pulumi.get(self, "preemptible_instance_config")

    @preemptible_instance_config.setter
    def preemptible_instance_config(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs']]):
        pulumi.set(self, "preemptible_instance_config", value)

    @property
    @pulumi.getter(name="preferredMaintenanceAction")
    def preferred_maintenance_action(self) -> Optional[pulumi.Input[str]]:
        """
        The preferred maintenance action for an instance. The default is LIVE_MIGRATE, if live migration is supported.
        """
        return pulumi.get(self, "preferred_maintenance_action")

    @preferred_maintenance_action.setter
    def preferred_maintenance_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preferred_maintenance_action", value)

    @property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input[str]]:
        """
        The shape of an instance. The shape determines the number of CPUs, amount of memory, and other resources allocated to the instance.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="shapeConfig")
    def shape_config(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs']]:
        """
        The shape configuration requested for the instance.
        """
        return pulumi.get(self, "shape_config")

    @shape_config.setter
    def shape_config(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs']]):
        pulumi.set(self, "shape_config", value)

    @property
    @pulumi.getter(name="sourceDetails")
    def source_details(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs']]:
        return pulumi.get(self, "source_details")

    @source_details.setter
    def source_details(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs']]):
        pulumi.set(self, "source_details", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigArgs:
    def __init__(__self__, *,
                 are_all_plugins_disabled: Optional[pulumi.Input[bool]] = None,
                 is_management_disabled: Optional[pulumi.Input[bool]] = None,
                 is_monitoring_disabled: Optional[pulumi.Input[bool]] = None,
                 plugins_configs: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]]] = None):
        """
        :param pulumi.Input[bool] are_all_plugins_disabled: Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.
        :param pulumi.Input[bool] is_management_disabled: Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).
        :param pulumi.Input[bool] is_monitoring_disabled: Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).
        :param pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]] plugins_configs: The configuration of plugins associated with this instance.
        """
        if are_all_plugins_disabled is not None:
            pulumi.set(__self__, "are_all_plugins_disabled", are_all_plugins_disabled)
        if is_management_disabled is not None:
            pulumi.set(__self__, "is_management_disabled", is_management_disabled)
        if is_monitoring_disabled is not None:
            pulumi.set(__self__, "is_monitoring_disabled", is_monitoring_disabled)
        if plugins_configs is not None:
            pulumi.set(__self__, "plugins_configs", plugins_configs)

    @property
    @pulumi.getter(name="areAllPluginsDisabled")
    def are_all_plugins_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can run all the available plugins. This includes the management and monitoring plugins.
        """
        return pulumi.get(self, "are_all_plugins_disabled")

    @are_all_plugins_disabled.setter
    def are_all_plugins_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_all_plugins_disabled", value)

    @property
    @pulumi.getter(name="isManagementDisabled")
    def is_management_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can run all the available management plugins. Default value is false (management plugins are enabled).
        """
        return pulumi.get(self, "is_management_disabled")

    @is_management_disabled.setter
    def is_management_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_management_disabled", value)

    @property
    @pulumi.getter(name="isMonitoringDisabled")
    def is_monitoring_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Oracle Cloud Agent can gather performance metrics and monitor the instance using the monitoring plugins. Default value is false (monitoring plugins are enabled).
        """
        return pulumi.get(self, "is_monitoring_disabled")

    @is_monitoring_disabled.setter
    def is_monitoring_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_monitoring_disabled", value)

    @property
    @pulumi.getter(name="pluginsConfigs")
    def plugins_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]]]:
        """
        The configuration of plugins associated with this instance.
        """
        return pulumi.get(self, "plugins_configs")

    @plugins_configs.setter
    def plugins_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs']]]]):
        pulumi.set(self, "plugins_configs", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsAgentConfigPluginsConfigArgs:
    def __init__(__self__, *,
                 desired_state: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] desired_state: Whether the plugin should be enabled or disabled.
        :param pulumi.Input[str] name: The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        pulumi.set(__self__, "desired_state", desired_state)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="desiredState")
    def desired_state(self) -> pulumi.Input[str]:
        """
        Whether the plugin should be enabled or disabled.
        """
        return pulumi.get(self, "desired_state")

    @desired_state.setter
    def desired_state(self, value: pulumi.Input[str]):
        pulumi.set(self, "desired_state", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsAvailabilityConfigArgs:
    def __init__(__self__, *,
                 recovery_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] recovery_action: The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        if recovery_action is not None:
            pulumi.set(__self__, "recovery_action", recovery_action)

    @property
    @pulumi.getter(name="recoveryAction")
    def recovery_action(self) -> Optional[pulumi.Input[str]]:
        """
        The lifecycle state for an instance when it is recovered after infrastructure maintenance.
        """
        return pulumi.get(self, "recovery_action")

    @recovery_action.setter
    def recovery_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recovery_action", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] assign_public_ip: Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] skip_source_dest_check: Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        if assign_private_dns_record is not None:
            pulumi.set(__self__, "assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if hostname_label is not None:
            pulumi.set(__self__, "hostname_label", hostname_label)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if skip_source_dest_check is not None:
            pulumi.set(__self__, "skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsInstanceOptionsArgs:
    def __init__(__self__, *,
                 are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] are_legacy_imds_endpoints_disabled: Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        if are_legacy_imds_endpoints_disabled is not None:
            pulumi.set(__self__, "are_legacy_imds_endpoints_disabled", are_legacy_imds_endpoints_disabled)

    @property
    @pulumi.getter(name="areLegacyImdsEndpointsDisabled")
    def are_legacy_imds_endpoints_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        return pulumi.get(self, "are_legacy_imds_endpoints_disabled")

    @are_legacy_imds_endpoints_disabled.setter
    def are_legacy_imds_endpoints_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_legacy_imds_endpoints_disabled", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsLaunchOptionsArgs:
    def __init__(__self__, *,
                 boot_volume_type: Optional[pulumi.Input[str]] = None,
                 firmware: Optional[pulumi.Input[str]] = None,
                 is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 network_type: Optional[pulumi.Input[str]] = None,
                 remote_data_volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_volume_type: Emulation type for the boot volume.
        :param pulumi.Input[str] firmware: Firmware used to boot VM. Select the option that matches your operating system.
        :param pulumi.Input[bool] is_consistent_volume_naming_enabled: Whether to enable consistent volume naming feature. Defaults to false.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        :param pulumi.Input[str] network_type: Emulation type for the physical network interface card (NIC).
        :param pulumi.Input[str] remote_data_volume_type: Emulation type for volume.
        """
        if boot_volume_type is not None:
            pulumi.set(__self__, "boot_volume_type", boot_volume_type)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if is_consistent_volume_naming_enabled is not None:
            pulumi.set(__self__, "is_consistent_volume_naming_enabled", is_consistent_volume_naming_enabled)
        if is_pv_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if remote_data_volume_type is not None:
            pulumi.set(__self__, "remote_data_volume_type", remote_data_volume_type)

    @property
    @pulumi.getter(name="bootVolumeType")
    def boot_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the boot volume.
        """
        return pulumi.get(self, "boot_volume_type")

    @boot_volume_type.setter
    def boot_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_type", value)

    @property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[str]]:
        """
        Firmware used to boot VM. Select the option that matches your operating system.
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firmware", value)

    @property
    @pulumi.getter(name="isConsistentVolumeNamingEnabled")
    def is_consistent_volume_naming_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable consistent volume naming feature. Defaults to false.
        """
        return pulumi.get(self, "is_consistent_volume_naming_enabled")

    @is_consistent_volume_naming_enabled.setter
    def is_consistent_volume_naming_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_consistent_volume_naming_enabled", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Deprecated. Instead use `isPvEncryptionInTransitEnabled` in [InstanceConfigurationLaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/datatypes/InstanceConfigurationLaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for the physical network interface card (NIC).
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="remoteDataVolumeType")
    def remote_data_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for volume.
        """
        return pulumi.get(self, "remote_data_volume_type")

    @remote_data_volume_type.setter
    def remote_data_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_data_volume_type", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsPlatformConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 numa_nodes_per_socket: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] numa_nodes_per_socket: The number of NUMA nodes per socket.
        """
        pulumi.set(__self__, "type", type)
        if numa_nodes_per_socket is not None:
            pulumi.set(__self__, "numa_nodes_per_socket", numa_nodes_per_socket)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="numaNodesPerSocket")
    def numa_nodes_per_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The number of NUMA nodes per socket.
        """
        return pulumi.get(self, "numa_nodes_per_socket")

    @numa_nodes_per_socket.setter
    def numa_nodes_per_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "numa_nodes_per_socket", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigArgs:
    def __init__(__self__, *,
                 preemption_action: pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']):
        """
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs'] preemption_action: The action to run when the preemptible instance is interrupted for eviction.
        """
        pulumi.set(__self__, "preemption_action", preemption_action)

    @property
    @pulumi.getter(name="preemptionAction")
    def preemption_action(self) -> pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']:
        """
        The action to run when the preemptible instance is interrupted for eviction.
        """
        return pulumi.get(self, "preemption_action")

    @preemption_action.setter
    def preemption_action(self, value: pulumi.Input['CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs']):
        pulumi.set(self, "preemption_action", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsPreemptibleInstanceConfigPreemptionActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_boot_volume: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] preserve_boot_volume: Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        pulumi.set(__self__, "type", type)
        if preserve_boot_volume is not None:
            pulumi.set(__self__, "preserve_boot_volume", preserve_boot_volume)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveBootVolume")
    def preserve_boot_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        return pulumi.get(self, "preserve_boot_volume")

    @preserve_boot_volume.setter
    def preserve_boot_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_boot_volume", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsShapeConfigArgs:
    def __init__(__self__, *,
                 baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] baseline_ocpu_utilization: The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
        :param pulumi.Input[float] memory_in_gbs: The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[float] ocpus: The total number of OCPUs available to the instance.
        """
        if baseline_ocpu_utilization is not None:
            pulumi.set(__self__, "baseline_ocpu_utilization", baseline_ocpu_utilization)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @property
    @pulumi.getter(name="baselineOcpuUtilization")
    def baseline_ocpu_utilization(self) -> Optional[pulumi.Input[str]]:
        """
        The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
        """
        return pulumi.get(self, "baseline_ocpu_utilization")

    @baseline_ocpu_utilization.setter
    def baseline_ocpu_utilization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baseline_ocpu_utilization", value)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsLaunchDetailsSourceDetailsArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 boot_volume_id: Optional[pulumi.Input[str]] = None,
                 boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        :param pulumi.Input[str] boot_volume_id: The OCID of the boot volume used to boot the instance.
        :param pulumi.Input[str] boot_volume_size_in_gbs: The size of the boot volume in GBs. The minimum value is 50 GB and the maximum value is 32,768 GB (32 TB).
        :param pulumi.Input[str] image_id: The OCID of the image used to boot the instance.
        """
        pulumi.set(__self__, "source_type", source_type)
        if boot_volume_id is not None:
            pulumi.set(__self__, "boot_volume_id", boot_volume_id)
        if boot_volume_size_in_gbs is not None:
            pulumi.set(__self__, "boot_volume_size_in_gbs", boot_volume_size_in_gbs)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bootVolumeId")
    def boot_volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the boot volume used to boot the instance.
        """
        return pulumi.get(self, "boot_volume_id")

    @boot_volume_id.setter
    def boot_volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_id", value)

    @property
    @pulumi.getter(name="bootVolumeSizeInGbs")
    def boot_volume_size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        The size of the boot volume in GBs. The minimum value is 50 GB and the maximum value is 32,768 GB (32 TB).
        """
        return pulumi.get(self, "boot_volume_size_in_gbs")

    @boot_volume_size_in_gbs.setter
    def boot_volume_size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the image used to boot the instance.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsSecondaryVnicArgs:
    def __init__(__self__, *,
                 create_vnic_details: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 nic_index: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['CoreInstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs'] create_vnic_details: Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        :param pulumi.Input[str] display_name: A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        :param pulumi.Input[int] nic_index: Which physical network interface card (NIC) the VNIC will use. Defaults to 0. Certain bare metal instance shapes have two active physical NICs (0 and 1). If you add a secondary VNIC to one of these instances, you can specify which NIC the VNIC will use. For more information, see [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingVNICs.htm).
        """
        if create_vnic_details is not None:
            pulumi.set(__self__, "create_vnic_details", create_vnic_details)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if nic_index is not None:
            pulumi.set(__self__, "nic_index", nic_index)

    @property
    @pulumi.getter(name="createVnicDetails")
    def create_vnic_details(self) -> Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs']]:
        """
        Contains the properties of the VNIC for an instance configuration. See [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) and [Instance Configurations](https://docs.cloud.oracle.com/iaas/Content/Compute/Concepts/instancemanagement.htm#config) for more information.
        """
        return pulumi.get(self, "create_vnic_details")

    @create_vnic_details.setter
    def create_vnic_details(self, value: Optional[pulumi.Input['CoreInstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs']]):
        pulumi.set(self, "create_vnic_details", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="nicIndex")
    def nic_index(self) -> Optional[pulumi.Input[int]]:
        """
        Which physical network interface card (NIC) the VNIC will use. Defaults to 0. Certain bare metal instance shapes have two active physical NICs (0 and 1). If you add a secondary VNIC to one of these instances, you can specify which NIC the VNIC will use. For more information, see [Virtual Network Interface Cards (VNICs)](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingVNICs.htm).
        """
        return pulumi.get(self, "nic_index")

    @nic_index.setter
    def nic_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nic_index", value)


@pulumi.input_type
class CoreInstanceConfigurationInstanceDetailsSecondaryVnicCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[bool]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] assign_public_ip: Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[bool] skip_source_dest_check: Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        if assign_private_dns_record is not None:
            pulumi.set(__self__, "assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if hostname_label is not None:
            pulumi.set(__self__, "hostname_label", hostname_label)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if skip_source_dest_check is not None:
            pulumi.set(__self__, "skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a private DNS record. See the `assignPrivateDnsRecord` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a public IP address. See the `assignPublicIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname for the VNIC's primary private IP. See the `hostnameLabel` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. See the `privateIp` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the source/destination check is disabled on the VNIC. See the `skipSourceDestCheck` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet to create the VNIC in. See the `subnetId` attribute of [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/) for more information.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class CoreInstanceCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a DNS record. If set to false, no DNS record registion for the VNIC; if set to true, DNS record will be registered. The default value is true.  Example: `true`
        :param pulumi.Input[str] assign_public_ip: (Updatable) Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My bare metal instance`
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: Deprecated. Instead use `hostnameLabel` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). If you provide both, the values must match.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
        :param pulumi.Input[bool] skip_source_dest_check: (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).
        :param pulumi.Input[str] subnet_id: Deprecated. Instead use `subnetId` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). At least one of them is required; if you provide both, the values must match.
        :param pulumi.Input[str] vlan_id: Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the OCID of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        if assign_private_dns_record is not None:
            pulumi.set(__self__, "assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if hostname_label is not None:
            pulumi.set(__self__, "hostname_label", hostname_label)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if skip_source_dest_check is not None:
            pulumi.set(__self__, "skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a DNS record. If set to false, no DNS record registion for the VNIC; if set to true, DNS record will be registered. The default value is true.  Example: `true`
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.  Example: `My bare metal instance`
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated. Instead use `hostnameLabel` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). If you provide both, the values must match.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        Deprecated. Instead use `subnetId` in [CreateVnicDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/CreateVnicDetails/). At least one of them is required; if you provide both, the values must match.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        """
        Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the OCID of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class CoreInstanceInstanceOptionsArgs:
    def __init__(__self__, *,
                 are_legacy_imds_endpoints_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] are_legacy_imds_endpoints_disabled: (Updatable) Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        if are_legacy_imds_endpoints_disabled is not None:
            pulumi.set(__self__, "are_legacy_imds_endpoints_disabled", are_legacy_imds_endpoints_disabled)

    @property
    @pulumi.getter(name="areLegacyImdsEndpointsDisabled")
    def are_legacy_imds_endpoints_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to disable the legacy (/v1) instance metadata service endpoints. Customers who have migrated to /v2 should set this to true for added security. Default is false.
        """
        return pulumi.get(self, "are_legacy_imds_endpoints_disabled")

    @are_legacy_imds_endpoints_disabled.setter
    def are_legacy_imds_endpoints_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_legacy_imds_endpoints_disabled", value)


@pulumi.input_type
class CoreInstanceLaunchOptionsArgs:
    def __init__(__self__, *,
                 boot_volume_type: Optional[pulumi.Input[str]] = None,
                 firmware: Optional[pulumi.Input[str]] = None,
                 is_consistent_volume_naming_enabled: Optional[pulumi.Input[bool]] = None,
                 is_pv_encryption_in_transit_enabled: Optional[pulumi.Input[bool]] = None,
                 network_type: Optional[pulumi.Input[str]] = None,
                 remote_data_volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot_volume_type: (Updatable) Emulation type for the boot volume.
        :param pulumi.Input[str] firmware: Firmware used to boot VM. Select the option that matches your operating system.
        :param pulumi.Input[bool] is_consistent_volume_naming_enabled: Whether to enable consistent volume naming feature. Defaults to false.
        :param pulumi.Input[bool] is_pv_encryption_in_transit_enabled: (Updatable) Use this for update operation only. This field is  Deprecated during create. For create use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/datatypes/LaunchInstanceDetails).
        :param pulumi.Input[str] network_type: (Updatable) Emulation type for the physical network interface card (NIC).
        :param pulumi.Input[str] remote_data_volume_type: Emulation type for volume.
        """
        if boot_volume_type is not None:
            pulumi.set(__self__, "boot_volume_type", boot_volume_type)
        if firmware is not None:
            pulumi.set(__self__, "firmware", firmware)
        if is_consistent_volume_naming_enabled is not None:
            pulumi.set(__self__, "is_consistent_volume_naming_enabled", is_consistent_volume_naming_enabled)
        if is_pv_encryption_in_transit_enabled is not None:
            pulumi.set(__self__, "is_pv_encryption_in_transit_enabled", is_pv_encryption_in_transit_enabled)
        if network_type is not None:
            pulumi.set(__self__, "network_type", network_type)
        if remote_data_volume_type is not None:
            pulumi.set(__self__, "remote_data_volume_type", remote_data_volume_type)

    @property
    @pulumi.getter(name="bootVolumeType")
    def boot_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Emulation type for the boot volume.
        """
        return pulumi.get(self, "boot_volume_type")

    @boot_volume_type.setter
    def boot_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_type", value)

    @property
    @pulumi.getter
    def firmware(self) -> Optional[pulumi.Input[str]]:
        """
        Firmware used to boot VM. Select the option that matches your operating system.
        """
        return pulumi.get(self, "firmware")

    @firmware.setter
    def firmware(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firmware", value)

    @property
    @pulumi.getter(name="isConsistentVolumeNamingEnabled")
    def is_consistent_volume_naming_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable consistent volume naming feature. Defaults to false.
        """
        return pulumi.get(self, "is_consistent_volume_naming_enabled")

    @is_consistent_volume_naming_enabled.setter
    def is_consistent_volume_naming_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_consistent_volume_naming_enabled", value)

    @property
    @pulumi.getter(name="isPvEncryptionInTransitEnabled")
    def is_pv_encryption_in_transit_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Use this for update operation only. This field is  Deprecated during create. For create use `isPvEncryptionInTransitEnabled` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/datatypes/LaunchInstanceDetails).
        """
        return pulumi.get(self, "is_pv_encryption_in_transit_enabled")

    @is_pv_encryption_in_transit_enabled.setter
    def is_pv_encryption_in_transit_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_pv_encryption_in_transit_enabled", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Emulation type for the physical network interface card (NIC).
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter(name="remoteDataVolumeType")
    def remote_data_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Emulation type for volume.
        """
        return pulumi.get(self, "remote_data_volume_type")

    @remote_data_volume_type.setter
    def remote_data_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_data_volume_type", value)


@pulumi.input_type
class CoreInstancePlatformConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 numa_nodes_per_socket: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[str] numa_nodes_per_socket: The number of NUMA nodes per socket (NPS).
        """
        pulumi.set(__self__, "type", type)
        if numa_nodes_per_socket is not None:
            pulumi.set(__self__, "numa_nodes_per_socket", numa_nodes_per_socket)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="numaNodesPerSocket")
    def numa_nodes_per_socket(self) -> Optional[pulumi.Input[str]]:
        """
        The number of NUMA nodes per socket (NPS).
        """
        return pulumi.get(self, "numa_nodes_per_socket")

    @numa_nodes_per_socket.setter
    def numa_nodes_per_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "numa_nodes_per_socket", value)


@pulumi.input_type
class CoreInstancePoolInstanceLoadBalancerBackendArgs:
    def __init__(__self__, *,
                 backend_health_status: Optional[pulumi.Input[str]] = None,
                 backend_name: Optional[pulumi.Input[str]] = None,
                 backend_set_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_health_status: The health of the backend as observed by the load balancer.
        :param pulumi.Input[str] backend_name: The name of the backend in the backend set.
        :param pulumi.Input[str] backend_set_name: The name of the backend set on the load balancer.
        :param pulumi.Input[str] load_balancer_id: The OCID of the load balancer attached to the instance pool.
        :param pulumi.Input[str] state: The lifecycle state of the instance. Refer to `lifecycleState` in the [Instance](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Instance) resource.
        """
        if backend_health_status is not None:
            pulumi.set(__self__, "backend_health_status", backend_health_status)
        if backend_name is not None:
            pulumi.set(__self__, "backend_name", backend_name)
        if backend_set_name is not None:
            pulumi.set(__self__, "backend_set_name", backend_set_name)
        if load_balancer_id is not None:
            pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="backendHealthStatus")
    def backend_health_status(self) -> Optional[pulumi.Input[str]]:
        """
        The health of the backend as observed by the load balancer.
        """
        return pulumi.get(self, "backend_health_status")

    @backend_health_status.setter
    def backend_health_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_health_status", value)

    @property
    @pulumi.getter(name="backendName")
    def backend_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the backend in the backend set.
        """
        return pulumi.get(self, "backend_name")

    @backend_name.setter
    def backend_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_name", value)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the backend set on the load balancer.
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_set_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the load balancer attached to the instance pool.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The lifecycle state of the instance. Refer to `lifecycleState` in the [Instance](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Instance) resource.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class CoreInstancePoolLoadBalancerArgs:
    def __init__(__self__, *,
                 backend_set_name: pulumi.Input[str],
                 load_balancer_id: pulumi.Input[str],
                 port: pulumi.Input[int],
                 vnic_selection: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 instance_pool_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backend_set_name: The name of the backend set on the load balancer to add instances to.
        :param pulumi.Input[str] load_balancer_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer to attach to the instance pool.
        :param pulumi.Input[int] port: The port value to use when creating the backend set.
        :param pulumi.Input[str] vnic_selection: Indicates which VNIC on each instance in the pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        :param pulumi.Input[str] instance_pool_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        :param pulumi.Input[str] state: (Updatable) The target state for the instance pool update operation (ignored at create time and should not be set). Could be set to RUNNING or STOPPED.
        """
        pulumi.set(__self__, "backend_set_name", backend_set_name)
        pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "vnic_selection", vnic_selection)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if instance_pool_id is not None:
            pulumi.set(__self__, "instance_pool_id", instance_pool_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> pulumi.Input[str]:
        """
        The name of the backend set on the load balancer to add instances to.
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_set_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> pulumi.Input[str]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer to attach to the instance pool.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port value to use when creating the backend set.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="vnicSelection")
    def vnic_selection(self) -> pulumi.Input[str]:
        """
        Indicates which VNIC on each instance in the pool should be used to associate with the load balancer. Possible values are "PrimaryVnic" or the displayName of one of the secondary VNICs on the instance configuration that is associated with the instance pool.
        """
        return pulumi.get(self, "vnic_selection")

    @vnic_selection.setter
    def vnic_selection(self, value: pulumi.Input[str]):
        pulumi.set(self, "vnic_selection", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the load balancer attachment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="instancePoolId")
    def instance_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the instance pool of the load balancer attachment.
        """
        return pulumi.get(self, "instance_pool_id")

    @instance_pool_id.setter
    def instance_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_pool_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target state for the instance pool update operation (ignored at create time and should not be set). Could be set to RUNNING or STOPPED.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class CoreInstancePoolPlacementConfigurationArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 primary_subnet_id: pulumi.Input[str],
                 fault_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 secondary_vnic_subnets: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] primary_subnet_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fault_domains: (Updatable) The fault domains to place instances.
        :param pulumi.Input[Sequence[pulumi.Input['CoreInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]] secondary_vnic_subnets: (Updatable) The set of secondary VNIC data for instances in the pool.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        pulumi.set(__self__, "primary_subnet_id", primary_subnet_id)
        if fault_domains is not None:
            pulumi.set(__self__, "fault_domains", fault_domains)
        if secondary_vnic_subnets is not None:
            pulumi.set(__self__, "secondary_vnic_subnets", secondary_vnic_subnets)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain to place instances.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="primarySubnetId")
    def primary_subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the primary subnet to place instances.
        """
        return pulumi.get(self, "primary_subnet_id")

    @primary_subnet_id.setter
    def primary_subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_subnet_id", value)

    @property
    @pulumi.getter(name="faultDomains")
    def fault_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The fault domains to place instances.
        """
        return pulumi.get(self, "fault_domains")

    @fault_domains.setter
    def fault_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fault_domains", value)

    @property
    @pulumi.getter(name="secondaryVnicSubnets")
    def secondary_vnic_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]:
        """
        (Updatable) The set of secondary VNIC data for instances in the pool.
        """
        return pulumi.get(self, "secondary_vnic_subnets")

    @secondary_vnic_subnets.setter
    def secondary_vnic_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CoreInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs']]]]):
        pulumi.set(self, "secondary_vnic_subnets", value)


@pulumi.input_type
class CoreInstancePoolPlacementConfigurationSecondaryVnicSubnetArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: (Updatable) The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        :param pulumi.Input[str] display_name: (Updatable) The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The subnet [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) for the secondary VNIC.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The display name of the VNIC. This is also use to match against the instance configuration defined secondary VNIC.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class CoreInstancePreemptibleInstanceConfigArgs:
    def __init__(__self__, *,
                 preemption_action: pulumi.Input['CoreInstancePreemptibleInstanceConfigPreemptionActionArgs']):
        """
        :param pulumi.Input['CoreInstancePreemptibleInstanceConfigPreemptionActionArgs'] preemption_action: The action to run when the preemptible instance is interrupted for eviction.
        """
        pulumi.set(__self__, "preemption_action", preemption_action)

    @property
    @pulumi.getter(name="preemptionAction")
    def preemption_action(self) -> pulumi.Input['CoreInstancePreemptibleInstanceConfigPreemptionActionArgs']:
        """
        The action to run when the preemptible instance is interrupted for eviction.
        """
        return pulumi.get(self, "preemption_action")

    @preemption_action.setter
    def preemption_action(self, value: pulumi.Input['CoreInstancePreemptibleInstanceConfigPreemptionActionArgs']):
        pulumi.set(self, "preemption_action", value)


@pulumi.input_type
class CoreInstancePreemptibleInstanceConfigPreemptionActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 preserve_boot_volume: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The type of action to run when the instance is interrupted for eviction.
        :param pulumi.Input[bool] preserve_boot_volume: Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        pulumi.set(__self__, "type", type)
        if preserve_boot_volume is not None:
            pulumi.set(__self__, "preserve_boot_volume", preserve_boot_volume)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of action to run when the instance is interrupted for eviction.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="preserveBootVolume")
    def preserve_boot_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to preserve the boot volume that was used to launch the preemptible instance when the instance is terminated. Defaults to false if not specified.
        """
        return pulumi.get(self, "preserve_boot_volume")

    @preserve_boot_volume.setter
    def preserve_boot_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_boot_volume", value)


@pulumi.input_type
class CoreInstanceShapeConfigArgs:
    def __init__(__self__, *,
                 baseline_ocpu_utilization: Optional[pulumi.Input[str]] = None,
                 gpu_description: Optional[pulumi.Input[str]] = None,
                 gpus: Optional[pulumi.Input[int]] = None,
                 local_disk_description: Optional[pulumi.Input[str]] = None,
                 local_disks: Optional[pulumi.Input[int]] = None,
                 local_disks_total_size_in_gbs: Optional[pulumi.Input[float]] = None,
                 max_vnic_attachments: Optional[pulumi.Input[int]] = None,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 networking_bandwidth_in_gbps: Optional[pulumi.Input[float]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None,
                 processor_description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] baseline_ocpu_utilization: (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
        :param pulumi.Input[str] gpu_description: A short description of the instance's graphics processing unit (GPU).
        :param pulumi.Input[int] gpus: The number of GPUs available to the instance.
        :param pulumi.Input[str] local_disk_description: A short description of the local disks available to this instance.
        :param pulumi.Input[int] local_disks: The number of local disks available to the instance.
        :param pulumi.Input[float] local_disks_total_size_in_gbs: The aggregate size of all local disks, in gigabytes.
        :param pulumi.Input[int] max_vnic_attachments: The maximum number of VNIC attachments for the instance.
        :param pulumi.Input[float] memory_in_gbs: (Updatable) The total amount of memory available to the instance, in gigabytes.
        :param pulumi.Input[float] networking_bandwidth_in_gbps: The networking bandwidth available to the instance, in gigabits per second.
        :param pulumi.Input[float] ocpus: (Updatable) The total number of OCPUs available to the instance.
        :param pulumi.Input[str] processor_description: A short description of the instance's processor (CPU).
        """
        if baseline_ocpu_utilization is not None:
            pulumi.set(__self__, "baseline_ocpu_utilization", baseline_ocpu_utilization)
        if gpu_description is not None:
            pulumi.set(__self__, "gpu_description", gpu_description)
        if gpus is not None:
            pulumi.set(__self__, "gpus", gpus)
        if local_disk_description is not None:
            pulumi.set(__self__, "local_disk_description", local_disk_description)
        if local_disks is not None:
            pulumi.set(__self__, "local_disks", local_disks)
        if local_disks_total_size_in_gbs is not None:
            pulumi.set(__self__, "local_disks_total_size_in_gbs", local_disks_total_size_in_gbs)
        if max_vnic_attachments is not None:
            pulumi.set(__self__, "max_vnic_attachments", max_vnic_attachments)
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if networking_bandwidth_in_gbps is not None:
            pulumi.set(__self__, "networking_bandwidth_in_gbps", networking_bandwidth_in_gbps)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)
        if processor_description is not None:
            pulumi.set(__self__, "processor_description", processor_description)

    @property
    @pulumi.getter(name="baselineOcpuUtilization")
    def baseline_ocpu_utilization(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The baseline OCPU utilization for a subcore burstable VM instance. Leave this attribute blank for a non-burstable instance, or explicitly specify non-burstable with `BASELINE_1_1`.
        """
        return pulumi.get(self, "baseline_ocpu_utilization")

    @baseline_ocpu_utilization.setter
    def baseline_ocpu_utilization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baseline_ocpu_utilization", value)

    @property
    @pulumi.getter(name="gpuDescription")
    def gpu_description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the instance's graphics processing unit (GPU).
        """
        return pulumi.get(self, "gpu_description")

    @gpu_description.setter
    def gpu_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gpu_description", value)

    @property
    @pulumi.getter
    def gpus(self) -> Optional[pulumi.Input[int]]:
        """
        The number of GPUs available to the instance.
        """
        return pulumi.get(self, "gpus")

    @gpus.setter
    def gpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gpus", value)

    @property
    @pulumi.getter(name="localDiskDescription")
    def local_disk_description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the local disks available to this instance.
        """
        return pulumi.get(self, "local_disk_description")

    @local_disk_description.setter
    def local_disk_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_disk_description", value)

    @property
    @pulumi.getter(name="localDisks")
    def local_disks(self) -> Optional[pulumi.Input[int]]:
        """
        The number of local disks available to the instance.
        """
        return pulumi.get(self, "local_disks")

    @local_disks.setter
    def local_disks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_disks", value)

    @property
    @pulumi.getter(name="localDisksTotalSizeInGbs")
    def local_disks_total_size_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        The aggregate size of all local disks, in gigabytes.
        """
        return pulumi.get(self, "local_disks_total_size_in_gbs")

    @local_disks_total_size_in_gbs.setter
    def local_disks_total_size_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "local_disks_total_size_in_gbs", value)

    @property
    @pulumi.getter(name="maxVnicAttachments")
    def max_vnic_attachments(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of VNIC attachments for the instance.
        """
        return pulumi.get(self, "max_vnic_attachments")

    @max_vnic_attachments.setter
    def max_vnic_attachments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_vnic_attachments", value)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total amount of memory available to the instance, in gigabytes.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter(name="networkingBandwidthInGbps")
    def networking_bandwidth_in_gbps(self) -> Optional[pulumi.Input[float]]:
        """
        The networking bandwidth available to the instance, in gigabits per second.
        """
        return pulumi.get(self, "networking_bandwidth_in_gbps")

    @networking_bandwidth_in_gbps.setter
    def networking_bandwidth_in_gbps(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "networking_bandwidth_in_gbps", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The total number of OCPUs available to the instance.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)

    @property
    @pulumi.getter(name="processorDescription")
    def processor_description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of the instance's processor (CPU).
        """
        return pulumi.get(self, "processor_description")

    @processor_description.setter
    def processor_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "processor_description", value)


@pulumi.input_type
class CoreInstanceSourceDetailsArgs:
    def __init__(__self__, *,
                 source_id: pulumi.Input[str],
                 source_type: pulumi.Input[str],
                 boot_volume_size_in_gbs: Optional[pulumi.Input[str]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_id: The OCID of an image or a boot volume to use, depending on the value of `source_type`.
        :param pulumi.Input[str] source_type: The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        :param pulumi.Input[str] boot_volume_size_in_gbs: (Updatable) The size of the boot volume in GBs. Minimum value is 50 GB and maximum value is 32,768 GB (32 TB).
        :param pulumi.Input[str] kms_key_id: The OCID of the Key Management key to assign as the master encryption key for the boot volume.
        """
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_type", source_type)
        if boot_volume_size_in_gbs is not None:
            pulumi.set(__self__, "boot_volume_size_in_gbs", boot_volume_size_in_gbs)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> pulumi.Input[str]:
        """
        The OCID of an image or a boot volume to use, depending on the value of `source_type`.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The source type for the instance. Use `image` when specifying the image OCID. Use `bootVolume` when specifying the boot volume OCID.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="bootVolumeSizeInGbs")
    def boot_volume_size_in_gbs(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The size of the boot volume in GBs. Minimum value is 50 GB and maximum value is 32,768 GB (32 TB).
        """
        return pulumi.get(self, "boot_volume_size_in_gbs")

    @boot_volume_size_in_gbs.setter
    def boot_volume_size_in_gbs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot_volume_size_in_gbs", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Key Management key to assign as the master encryption key for the boot volume.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class CoreIpsecConnectionTunnelManagementBgpSessionInfoArgs:
    def __init__(__self__, *,
                 bgp_state: Optional[pulumi.Input[str]] = None,
                 customer_bgp_asn: Optional[pulumi.Input[str]] = None,
                 customer_interface_ip: Optional[pulumi.Input[str]] = None,
                 oracle_bgp_asn: Optional[pulumi.Input[str]] = None,
                 oracle_interface_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bgp_state: the state of the BGP.
        :param pulumi.Input[str] customer_bgp_asn: If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this ASN is required and used for the tunnel's BGP session. This is the ASN of the network on the CPE end of the BGP session. Can be a 2-byte or 4-byte ASN. Uses "asplain" format.
        :param pulumi.Input[str] customer_interface_ip: The IP address for the CPE end of the inside tunnel interface.
        :param pulumi.Input[str] oracle_bgp_asn: This is the value of the Oracle Bgp ASN in asplain format, as a string. Example: 1587232876 (4 byte ASN) or 12345 (2 byte ASN)
        :param pulumi.Input[str] oracle_interface_ip: The IP address for the Oracle end of the inside tunnel interface.
        """
        if bgp_state is not None:
            pulumi.set(__self__, "bgp_state", bgp_state)
        if customer_bgp_asn is not None:
            pulumi.set(__self__, "customer_bgp_asn", customer_bgp_asn)
        if customer_interface_ip is not None:
            pulumi.set(__self__, "customer_interface_ip", customer_interface_ip)
        if oracle_bgp_asn is not None:
            pulumi.set(__self__, "oracle_bgp_asn", oracle_bgp_asn)
        if oracle_interface_ip is not None:
            pulumi.set(__self__, "oracle_interface_ip", oracle_interface_ip)

    @property
    @pulumi.getter(name="bgpState")
    def bgp_state(self) -> Optional[pulumi.Input[str]]:
        """
        the state of the BGP.
        """
        return pulumi.get(self, "bgp_state")

    @bgp_state.setter
    def bgp_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgp_state", value)

    @property
    @pulumi.getter(name="customerBgpAsn")
    def customer_bgp_asn(self) -> Optional[pulumi.Input[str]]:
        """
        If the tunnel's `routing` attribute is set to `BGP` (see [IPSecConnectionTunnel](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/20160918/IPSecConnectionTunnel/)), this ASN is required and used for the tunnel's BGP session. This is the ASN of the network on the CPE end of the BGP session. Can be a 2-byte or 4-byte ASN. Uses "asplain" format.
        """
        return pulumi.get(self, "customer_bgp_asn")

    @customer_bgp_asn.setter
    def customer_bgp_asn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_bgp_asn", value)

    @property
    @pulumi.getter(name="customerInterfaceIp")
    def customer_interface_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address for the CPE end of the inside tunnel interface.
        """
        return pulumi.get(self, "customer_interface_ip")

    @customer_interface_ip.setter
    def customer_interface_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_interface_ip", value)

    @property
    @pulumi.getter(name="oracleBgpAsn")
    def oracle_bgp_asn(self) -> Optional[pulumi.Input[str]]:
        """
        This is the value of the Oracle Bgp ASN in asplain format, as a string. Example: 1587232876 (4 byte ASN) or 12345 (2 byte ASN)
        """
        return pulumi.get(self, "oracle_bgp_asn")

    @oracle_bgp_asn.setter
    def oracle_bgp_asn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_bgp_asn", value)

    @property
    @pulumi.getter(name="oracleInterfaceIp")
    def oracle_interface_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address for the Oracle end of the inside tunnel interface.
        """
        return pulumi.get(self, "oracle_interface_ip")

    @oracle_interface_ip.setter
    def oracle_interface_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_interface_ip", value)


@pulumi.input_type
class CoreIpsecConnectionTunnelManagementEncryptionDomainConfigArgs:
    def __init__(__self__, *,
                 cpe_traffic_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 oracle_traffic_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cpe_traffic_selectors: Lists IPv4 or IPv6-enabled subnets in your on-premises network.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oracle_traffic_selectors: Lists IPv4 or IPv6-enabled subnets in your Oracle tenancy.
        """
        if cpe_traffic_selectors is not None:
            pulumi.set(__self__, "cpe_traffic_selectors", cpe_traffic_selectors)
        if oracle_traffic_selectors is not None:
            pulumi.set(__self__, "oracle_traffic_selectors", oracle_traffic_selectors)

    @property
    @pulumi.getter(name="cpeTrafficSelectors")
    def cpe_traffic_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Lists IPv4 or IPv6-enabled subnets in your on-premises network.
        """
        return pulumi.get(self, "cpe_traffic_selectors")

    @cpe_traffic_selectors.setter
    def cpe_traffic_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cpe_traffic_selectors", value)

    @property
    @pulumi.getter(name="oracleTrafficSelectors")
    def oracle_traffic_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Lists IPv4 or IPv6-enabled subnets in your Oracle tenancy.
        """
        return pulumi.get(self, "oracle_traffic_selectors")

    @oracle_traffic_selectors.setter
    def oracle_traffic_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oracle_traffic_selectors", value)


@pulumi.input_type
class CoreNetworkSecurityGroupSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] type: The ICMP type.
        :param pulumi.Input[int] code: The ICMP code (optional).
        """
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        """
        The ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The ICMP code (optional).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class CoreNetworkSecurityGroupSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 destination_port_range: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs']] = None,
                 source_port_range: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs']]:
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs']]):
        pulumi.set(self, "destination_port_range", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreNetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreNetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreNetworkSecurityGroupSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 destination_port_range: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs']] = None,
                 source_port_range: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs']]:
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs']]):
        pulumi.set(self, "destination_port_range", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreNetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreNetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreNetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: The minimum port number, which must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        The maximum port number, which must not be less than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        The minimum port number, which must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreRouteTableRouteRuleArgs:
    def __init__(__self__, *,
                 network_entity_id: pulumi.Input[str],
                 cidr_block: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 destination: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] network_entity_id: (Updatable) The OCID for the route rule's target. For information about the type of targets you can specify, see [Route Tables](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm).
        :param pulumi.Input[str] cidr_block: (Updatable) Deprecated. Instead use `destination` and `destinationType`. Requests that include both `cidrBlock` and `destination` will be rejected.
        :param pulumi.Input[str] description: (Updatable) An optional description of your choice for the rule.
        :param pulumi.Input[str] destination: (Updatable) Conceptually, this is the range of IP addresses used for matching when routing traffic. Required if you provide a `destinationType`.
        :param pulumi.Input[str] destination_type: (Updatable) Type of destination for the rule. Required if you provide a `destination`.
               * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
               * `SERVICE_CIDR_BLOCK`: If the rule's `destination` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic destined for a particular `Service` through a service gateway).
        """
        pulumi.set(__self__, "network_entity_id", network_entity_id)
        if cidr_block is not None:
            warnings.warn("""The 'cidr_block' field has been deprecated. Please use 'destination' instead.""", DeprecationWarning)
            pulumi.log.warn("""cidr_block is deprecated: The 'cidr_block' field has been deprecated. Please use 'destination' instead.""")
        if cidr_block is not None:
            pulumi.set(__self__, "cidr_block", cidr_block)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)

    @property
    @pulumi.getter(name="networkEntityId")
    def network_entity_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID for the route rule's target. For information about the type of targets you can specify, see [Route Tables](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm).
        """
        return pulumi.get(self, "network_entity_id")

    @network_entity_id.setter
    def network_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_entity_id", value)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deprecated. Instead use `destination` and `destinationType`. Requests that include both `cidrBlock` and `destination` will be rejected.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An optional description of your choice for the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Conceptually, this is the range of IP addresses used for matching when routing traffic. Required if you provide a `destinationType`.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of destination for the rule. Required if you provide a `destination`.
        * `CIDR_BLOCK`: If the rule's `destination` is an IP address range in CIDR notation.
        * `SERVICE_CIDR_BLOCK`: If the rule's `destination` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic destined for a particular `Service` through a service gateway).
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)


@pulumi.input_type
class CoreSecurityListEgressSecurityRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 destination_type: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleIcmpOptionsArgs']] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsArgs']] = None):
        """
        :param pulumi.Input[str] destination: (Updatable) Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
        :param pulumi.Input[str] protocol: (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        :param pulumi.Input[str] description: (Updatable) An optional description of your choice for the rule.
        :param pulumi.Input[str] destination_type: (Updatable) Type of destination for the rule. The default is `CIDR_BLOCK`.
        :param pulumi.Input['CoreSecurityListEgressSecurityRuleIcmpOptionsArgs'] icmp_options: (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
               * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
               * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
        :param pulumi.Input[bool] stateless: (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        :param pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsArgs'] tcp_options: (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        :param pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsArgs'] udp_options: (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "protocol", protocol)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_type is not None:
            pulumi.set(__self__, "destination_type", destination_type)
        if icmp_options is not None:
            pulumi.set(__self__, "icmp_options", icmp_options)
        if stateless is not None:
            pulumi.set(__self__, "stateless", stateless)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if udp_options is not None:
            pulumi.set(__self__, "udp_options", udp_options)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        (Updatable) Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An optional description of your choice for the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="destinationType")
    def destination_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of destination for the rule. The default is `CIDR_BLOCK`.
        """
        return pulumi.get(self, "destination_type")

    @destination_type.setter
    def destination_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_type", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleIcmpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
        * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
        * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
        """
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        """
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class CoreSecurityListEgressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] type: (Updatable) The ICMP type.
        :param pulumi.Input[int] code: (Updatable) The ICMP code (optional).
        """
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        """
        (Updatable) The ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The ICMP code (optional).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class CoreSecurityListEgressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        :param pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreSecurityListEgressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreSecurityListEgressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        :param pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreSecurityListEgressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreSecurityListIngressSecurityRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 source: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 icmp_options: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleIcmpOptionsArgs']] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 stateless: Optional[pulumi.Input[bool]] = None,
                 tcp_options: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsArgs']] = None,
                 udp_options: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsArgs']] = None):
        """
        :param pulumi.Input[str] protocol: (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        :param pulumi.Input[str] source: (Updatable) Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
        :param pulumi.Input[str] description: (Updatable) An optional description of your choice for the rule.
        :param pulumi.Input['CoreSecurityListIngressSecurityRuleIcmpOptionsArgs'] icmp_options: (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
               * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
               * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
        :param pulumi.Input[str] source_type: (Updatable) Type of source for the rule. The default is `CIDR_BLOCK`.
               * `CIDR_BLOCK`: If the rule's `source` is an IP address range in CIDR notation.
               * `SERVICE_CIDR_BLOCK`: If the rule's `source` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic coming from a particular `Service` through a service gateway).
        :param pulumi.Input[bool] stateless: (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        :param pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsArgs'] tcp_options: (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        :param pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsArgs'] udp_options: (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if icmp_options is not None:
            pulumi.set(__self__, "icmp_options", icmp_options)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if stateless is not None:
            pulumi.set(__self__, "stateless", stateless)
        if tcp_options is not None:
            pulumi.set(__self__, "tcp_options", tcp_options)
        if udp_options is not None:
            pulumi.set(__self__, "udp_options", udp_options)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        (Updatable) Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) An optional description of your choice for the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleIcmpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
        * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
        * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
        """
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleIcmpOptionsArgs']]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of source for the rule. The default is `CIDR_BLOCK`.
        * `CIDR_BLOCK`: If the rule's `source` is an IP address range in CIDR notation.
        * `SERVICE_CIDR_BLOCK`: If the rule's `source` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic coming from a particular `Service` through a service gateway).
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def stateless(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if ingress traffic allows TCP destination port 80, there should be an egress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
        """
        return pulumi.get(self, "stateless")

    @stateless.setter
    def stateless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stateless", value)

    @property
    @pulumi.getter(name="tcpOptions")
    def tcp_options(self) -> Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "tcp_options")

    @tcp_options.setter
    def tcp_options(self, value: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsArgs']]):
        pulumi.set(self, "tcp_options", value)

    @property
    @pulumi.getter(name="udpOptions")
    def udp_options(self) -> Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsArgs']]:
        """
        (Updatable) Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
        """
        return pulumi.get(self, "udp_options")

    @udp_options.setter
    def udp_options(self, value: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsArgs']]):
        pulumi.set(self, "udp_options", value)


@pulumi.input_type
class CoreSecurityListIngressSecurityRuleIcmpOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[int],
                 code: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] type: (Updatable) The ICMP type.
        :param pulumi.Input[int] code: (Updatable) The ICMP code (optional).
        """
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[int]:
        """
        (Updatable) The ICMP type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[int]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The ICMP code (optional).
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)


@pulumi.input_type
class CoreSecurityListIngressSecurityRuleTcpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        :param pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreSecurityListIngressSecurityRuleTcpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreSecurityListIngressSecurityRuleUdpOptionsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 source_port_range: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']] = None):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        :param pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs'] source_port_range: (Updatable)
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['CoreSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


@pulumi.input_type
class CoreSecurityListIngressSecurityRuleUdpOptionsSourcePortRangeArgs:
    def __init__(__self__, *,
                 max: pulumi.Input[int],
                 min: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max: (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        :param pulumi.Input[int] min: (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        pulumi.set(__self__, "max", max)
        pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> pulumi.Input[int]:
        """
        (Updatable) The maximum port number. Must not be lower than the minimum port number. To specify a single port number, set both the min and max to the same value.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: pulumi.Input[int]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> pulumi.Input[int]:
        """
        (Updatable) The minimum port number. Must not be greater than the maximum port number.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[int]):
        pulumi.set(self, "min", value)


@pulumi.input_type
class CoreServiceGatewayServiceArgs:
    def __init__(__self__, *,
                 service_id: pulumi.Input[str],
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/).
        :param pulumi.Input[str] service_name: The name of the service.
        """
        pulumi.set(__self__, "service_id", service_id)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/).
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_id", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class CoreVirtualCircuitCrossConnectMappingArgs:
    def __init__(__self__, *,
                 bgp_md5auth_key: Optional[pulumi.Input[str]] = None,
                 cross_connect_or_cross_connect_group_id: Optional[pulumi.Input[str]] = None,
                 customer_bgp_peering_ip: Optional[pulumi.Input[str]] = None,
                 customer_bgp_peering_ipv6: Optional[pulumi.Input[str]] = None,
                 oracle_bgp_peering_ip: Optional[pulumi.Input[str]] = None,
                 oracle_bgp_peering_ipv6: Optional[pulumi.Input[str]] = None,
                 vlan: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] bgp_md5auth_key: (Updatable) The key for BGP MD5 authentication. Only applicable if your system requires MD5 authentication. If empty or not set (null), that means you don't use BGP MD5 authentication.
        :param pulumi.Input[str] cross_connect_or_cross_connect_group_id: (Updatable) The OCID of the cross-connect or cross-connect group for this mapping. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).
        :param pulumi.Input[str] customer_bgp_peering_ip: (Updatable) The BGP IPv4 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv4 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv4 address of the provider's edge router. Must use a /30 or /31 subnet mask.
        :param pulumi.Input[str] customer_bgp_peering_ipv6: (Updatable) IPv6 is currently supported only in the Government Cloud. The BGP IPv6 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv6 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv6 address of the provider's edge router. Only subnet masks from /64 up to /127 are allowed.
        :param pulumi.Input[str] oracle_bgp_peering_ip: (Updatable) The IPv4 address for Oracle's end of the BGP session. Must use a /30 or /31 subnet mask. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.
        :param pulumi.Input[str] oracle_bgp_peering_ipv6: (Updatable) IPv6 is currently supported only in the Government Cloud. The IPv6 address for Oracle's end of the BGP session.  Only subnet masks from /64 up to /127 are allowed. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.
        :param pulumi.Input[int] vlan: (Updatable) The number of the specific VLAN (on the cross-connect or cross-connect group) that is assigned to this virtual circuit. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).  Example: `200`
        """
        if bgp_md5auth_key is not None:
            pulumi.set(__self__, "bgp_md5auth_key", bgp_md5auth_key)
        if cross_connect_or_cross_connect_group_id is not None:
            pulumi.set(__self__, "cross_connect_or_cross_connect_group_id", cross_connect_or_cross_connect_group_id)
        if customer_bgp_peering_ip is not None:
            pulumi.set(__self__, "customer_bgp_peering_ip", customer_bgp_peering_ip)
        if customer_bgp_peering_ipv6 is not None:
            pulumi.set(__self__, "customer_bgp_peering_ipv6", customer_bgp_peering_ipv6)
        if oracle_bgp_peering_ip is not None:
            pulumi.set(__self__, "oracle_bgp_peering_ip", oracle_bgp_peering_ip)
        if oracle_bgp_peering_ipv6 is not None:
            pulumi.set(__self__, "oracle_bgp_peering_ipv6", oracle_bgp_peering_ipv6)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="bgpMd5authKey")
    def bgp_md5auth_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The key for BGP MD5 authentication. Only applicable if your system requires MD5 authentication. If empty or not set (null), that means you don't use BGP MD5 authentication.
        """
        return pulumi.get(self, "bgp_md5auth_key")

    @bgp_md5auth_key.setter
    def bgp_md5auth_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bgp_md5auth_key", value)

    @property
    @pulumi.getter(name="crossConnectOrCrossConnectGroupId")
    def cross_connect_or_cross_connect_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the cross-connect or cross-connect group for this mapping. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).
        """
        return pulumi.get(self, "cross_connect_or_cross_connect_group_id")

    @cross_connect_or_cross_connect_group_id.setter
    def cross_connect_or_cross_connect_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cross_connect_or_cross_connect_group_id", value)

    @property
    @pulumi.getter(name="customerBgpPeeringIp")
    def customer_bgp_peering_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The BGP IPv4 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv4 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv4 address of the provider's edge router. Must use a /30 or /31 subnet mask.
        """
        return pulumi.get(self, "customer_bgp_peering_ip")

    @customer_bgp_peering_ip.setter
    def customer_bgp_peering_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_bgp_peering_ip", value)

    @property
    @pulumi.getter(name="customerBgpPeeringIpv6")
    def customer_bgp_peering_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) IPv6 is currently supported only in the Government Cloud. The BGP IPv6 address for the router on the other end of the BGP session from Oracle. Specified by the owner of that router. If the session goes from Oracle to a customer, this is the BGP IPv6 address of the customer's edge router. If the session goes from Oracle to a provider, this is the BGP IPv6 address of the provider's edge router. Only subnet masks from /64 up to /127 are allowed.
        """
        return pulumi.get(self, "customer_bgp_peering_ipv6")

    @customer_bgp_peering_ipv6.setter
    def customer_bgp_peering_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_bgp_peering_ipv6", value)

    @property
    @pulumi.getter(name="oracleBgpPeeringIp")
    def oracle_bgp_peering_ip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The IPv4 address for Oracle's end of the BGP session. Must use a /30 or /31 subnet mask. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.
        """
        return pulumi.get(self, "oracle_bgp_peering_ip")

    @oracle_bgp_peering_ip.setter
    def oracle_bgp_peering_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_bgp_peering_ip", value)

    @property
    @pulumi.getter(name="oracleBgpPeeringIpv6")
    def oracle_bgp_peering_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) IPv6 is currently supported only in the Government Cloud. The IPv6 address for Oracle's end of the BGP session.  Only subnet masks from /64 up to /127 are allowed. If the session goes from Oracle to a customer's edge router, the customer specifies this information. If the session goes from Oracle to a provider's edge router, the provider specifies this.
        """
        return pulumi.get(self, "oracle_bgp_peering_ipv6")

    @oracle_bgp_peering_ipv6.setter
    def oracle_bgp_peering_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "oracle_bgp_peering_ipv6", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of the specific VLAN (on the cross-connect or cross-connect group) that is assigned to this virtual circuit. Specified by the owner of the cross-connect or cross-connect group (the customer if the customer is colocated with Oracle, or the provider if the customer is connecting via provider).  Example: `200`
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan", value)


@pulumi.input_type
class CoreVirtualCircuitPublicPrefixArgs:
    def __init__(__self__, *,
                 cidr_block: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cidr_block: (Updatable) An individual public IP prefix (CIDR) to add to the public virtual circuit. All prefix sizes are allowed.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> pulumi.Input[str]:
        """
        (Updatable) An individual public IP prefix (CIDR) to add to the public virtual circuit. All prefix sizes are allowed.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr_block", value)


@pulumi.input_type
class CoreVnicAttachmentCreateVnicDetailsArgs:
    def __init__(__self__, *,
                 assign_private_dns_record: Optional[pulumi.Input[bool]] = None,
                 assign_public_ip: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_ip: Optional[pulumi.Input[str]] = None,
                 skip_source_dest_check: Optional[pulumi.Input[bool]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vlan_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] assign_private_dns_record: Whether the VNIC should be assigned a DNS record. If set to false, no DNS record registion for the VNIC; if set to true, DNS record will be registered. Example: `true`
        :param pulumi.Input[str] assign_public_ip: Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        :param pulumi.Input[str] display_name: A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed. Avoid entering confidential information.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] hostname_label: (Updatable) The hostname for the VNIC's primary private IP. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, `bminstance-1` in FQDN `bminstance-1.subnet123.vcn1.oraclevcn.com`). Must be unique across all VNICs in the subnet and comply with [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        :param pulumi.Input[str] private_ip: A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
        :param pulumi.Input[bool] skip_source_dest_check: (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).
        :param pulumi.Input[str] subnet_id: The OCID of the subnet to create the VNIC in. When launching an instance, use this `subnetId` instead of the deprecated `subnetId` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/requests/LaunchInstanceDetails). At least one of them is required; if you provide both, the values must match.
        :param pulumi.Input[str] vlan_id: Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the OCID of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        if assign_private_dns_record is not None:
            pulumi.set(__self__, "assign_private_dns_record", assign_private_dns_record)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if hostname_label is not None:
            pulumi.set(__self__, "hostname_label", hostname_label)
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if private_ip is not None:
            pulumi.set(__self__, "private_ip", private_ip)
        if skip_source_dest_check is not None:
            pulumi.set(__self__, "skip_source_dest_check", skip_source_dest_check)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="assignPrivateDnsRecord")
    def assign_private_dns_record(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the VNIC should be assigned a DNS record. If set to false, no DNS record registion for the VNIC; if set to true, DNS record will be registered. Example: `true`
        """
        return pulumi.get(self, "assign_private_dns_record")

    @assign_private_dns_record.setter
    def assign_private_dns_record(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "assign_private_dns_record", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        Whether the VNIC should be assigned a public IP address. Defaults to whether the subnet is public or private. If not set and the VNIC is being created in a private subnet (that is, where `prohibitPublicIpOnVnic` = true in the [Subnet](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Subnet/)), then no public IP address is assigned. If not set and the subnet is public (`prohibitPublicIpOnVnic` = false), then a public IP address is assigned. If set to true and `prohibitPublicIpOnVnic` = true, an error is returned.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Operations.CostCenter": "42"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the attachment. Does not have to be unique, and it cannot be changed. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The hostname for the VNIC's primary private IP. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, `bminstance-1` in FQDN `bminstance-1.subnet123.vcn1.oraclevcn.com`). Must be unique across all VNICs in the subnet and comply with [RFC 952](https://tools.ietf.org/html/rfc952) and [RFC 1123](https://tools.ietf.org/html/rfc1123). The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of the OCIDs of the network security groups (NSGs) to add the VNIC to. For more information about NSGs, see [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> Optional[pulumi.Input[str]]:
        """
        A private IP address of your choice to assign to the VNIC. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This is the VNIC's *primary* private IP address. The value appears in the [Vnic](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vnic/) object and also the [PrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/) object returned by [ListPrivateIps](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/ListPrivateIps) and [GetPrivateIp](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/PrivateIp/GetPrivateIp).
        """
        return pulumi.get(self, "private_ip")

    @private_ip.setter
    def private_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip", value)

    @property
    @pulumi.getter(name="skipSourceDestCheck")
    def skip_source_dest_check(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the source/destination check is disabled on the VNIC. Defaults to `false`, which means the check is performed. For information about why you would skip the source/destination check, see [Using a Private IP as a Route Target](https://docs.cloud.oracle.com/iaas/Content/Network/Tasks/managingroutetables.htm#privateip).
        """
        return pulumi.get(self, "skip_source_dest_check")

    @skip_source_dest_check.setter
    def skip_source_dest_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_source_dest_check", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet to create the VNIC in. When launching an instance, use this `subnetId` instead of the deprecated `subnetId` in [LaunchInstanceDetails](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/requests/LaunchInstanceDetails). At least one of them is required; if you provide both, the values must match.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[pulumi.Input[str]]:
        """
        Provide this attribute only if you are an Oracle Cloud VMware Solution customer and creating a secondary VNIC in a VLAN. The value is the OCID of the VLAN. See [Vlan](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Vlan).
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class CoreVolumeAttachmentMultipathDeviceArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[str]] = None,
                 iqn: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ipv4: The volume's iSCSI IP address.  Example: `169.254.2.2`
        :param pulumi.Input[str] iqn: The target volume's iSCSI Qualified Name in the format defined by [RFC 3720](https://tools.ietf.org/html/rfc3720#page-32).  Example: `iqn.2015-12.com.oracleiaas:40b7ee03-883f-46c6-a951-63d2841d2195`
        :param pulumi.Input[int] port: The volume's iSCSI port, usually port 860 or 3260.  Example: `3260`
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if iqn is not None:
            pulumi.set(__self__, "iqn", iqn)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[str]]:
        """
        The volume's iSCSI IP address.  Example: `169.254.2.2`
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def iqn(self) -> Optional[pulumi.Input[str]]:
        """
        The target volume's iSCSI Qualified Name in the format defined by [RFC 3720](https://tools.ietf.org/html/rfc3720#page-32).  Example: `iqn.2015-12.com.oracleiaas:40b7ee03-883f-46c6-a951-63d2841d2195`
        """
        return pulumi.get(self, "iqn")

    @iqn.setter
    def iqn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iqn", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The volume's iSCSI port, usually port 860 or 3260.  Example: `3260`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class CoreVolumeBackupPolicyScheduleArgs:
    def __init__(__self__, *,
                 backup_type: pulumi.Input[str],
                 period: pulumi.Input[str],
                 retention_seconds: pulumi.Input[int],
                 day_of_month: Optional[pulumi.Input[int]] = None,
                 day_of_week: Optional[pulumi.Input[str]] = None,
                 hour_of_day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[str]] = None,
                 offset_seconds: Optional[pulumi.Input[int]] = None,
                 offset_type: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_type: (Updatable) The type of volume backup to create.
        :param pulumi.Input[str] period: (Updatable) The volume backup frequency.
        :param pulumi.Input[int] retention_seconds: (Updatable) How long, in seconds, to keep the volume backups created by this schedule.
        :param pulumi.Input[int] day_of_month: (Updatable) The day of the month to schedule the volume backup.
        :param pulumi.Input[str] day_of_week: (Updatable) The day of the week to schedule the volume backup.
        :param pulumi.Input[int] hour_of_day: (Updatable) The hour of the day to schedule the volume backup.
        :param pulumi.Input[str] month: (Updatable) The month of the year to schedule the volume backup.
        :param pulumi.Input[int] offset_seconds: (Updatable) The number of seconds that the volume backup start time should be shifted from the default interval boundaries specified by the period. The volume backup start time is the frequency start time plus the offset.
        :param pulumi.Input[str] offset_type: (Updatable) Indicates how the offset is defined. If value is `STRUCTURED`, then `hourOfDay`, `dayOfWeek`, `dayOfMonth`, and `month` fields are used and `offsetSeconds` will be ignored in requests and users should ignore its value from the responses.
        :param pulumi.Input[str] time_zone: (Updatable) Specifies what time zone is the schedule in
               enum:
               - `UTC`
               - `REGIONAL_DATA_CENTER_TIME`
        """
        pulumi.set(__self__, "backup_type", backup_type)
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "retention_seconds", retention_seconds)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if hour_of_day is not None:
            pulumi.set(__self__, "hour_of_day", hour_of_day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if offset_seconds is not None:
            pulumi.set(__self__, "offset_seconds", offset_seconds)
        if offset_type is not None:
            pulumi.set(__self__, "offset_type", offset_type)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="backupType")
    def backup_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of volume backup to create.
        """
        return pulumi.get(self, "backup_type")

    @backup_type.setter
    def backup_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_type", value)

    @property
    @pulumi.getter
    def period(self) -> pulumi.Input[str]:
        """
        (Updatable) The volume backup frequency.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[str]):
        pulumi.set(self, "period", value)

    @property
    @pulumi.getter(name="retentionSeconds")
    def retention_seconds(self) -> pulumi.Input[int]:
        """
        (Updatable) How long, in seconds, to keep the volume backups created by this schedule.
        """
        return pulumi.get(self, "retention_seconds")

    @retention_seconds.setter
    def retention_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_seconds", value)

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The day of the month to schedule the volume backup.
        """
        return pulumi.get(self, "day_of_month")

    @day_of_month.setter
    def day_of_month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day_of_month", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The day of the week to schedule the volume backup.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="hourOfDay")
    def hour_of_day(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The hour of the day to schedule the volume backup.
        """
        return pulumi.get(self, "hour_of_day")

    @hour_of_day.setter
    def hour_of_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour_of_day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The month of the year to schedule the volume backup.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter(name="offsetSeconds")
    def offset_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds that the volume backup start time should be shifted from the default interval boundaries specified by the period. The volume backup start time is the frequency start time plus the offset.
        """
        return pulumi.get(self, "offset_seconds")

    @offset_seconds.setter
    def offset_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "offset_seconds", value)

    @property
    @pulumi.getter(name="offsetType")
    def offset_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Indicates how the offset is defined. If value is `STRUCTURED`, then `hourOfDay`, `dayOfWeek`, `dayOfMonth`, and `month` fields are used and `offsetSeconds` will be ignored in requests and users should ignore its value from the responses.
        """
        return pulumi.get(self, "offset_type")

    @offset_type.setter
    def offset_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offset_type", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies what time zone is the schedule in
        enum:
        - `UTC`
        - `REGIONAL_DATA_CENTER_TIME`
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


@pulumi.input_type
class CoreVolumeBackupSourceDetailsArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 volume_backup_id: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: The region of the volume backup source.
        :param pulumi.Input[str] volume_backup_id: The OCID of the source volume backup.
        :param pulumi.Input[str] kms_key_id: The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "volume_backup_id", volume_backup_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the volume backup source.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="volumeBackupId")
    def volume_backup_id(self) -> pulumi.Input[str]:
        """
        The OCID of the source volume backup.
        """
        return pulumi.get(self, "volume_backup_id")

    @volume_backup_id.setter
    def volume_backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_backup_id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class CoreVolumeBlockVolumeReplicaArgs:
    def __init__(__self__, *,
                 availability_domain: pulumi.Input[str],
                 block_volume_replica_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: (Updatable) The availability domain of the block volume replica.  Example: `Uocm:PHX-AD-1`
        :param pulumi.Input[str] block_volume_replica_id: The block volume replica's Oracle ID (OCID).
        :param pulumi.Input[str] display_name: (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        pulumi.set(__self__, "availability_domain", availability_domain)
        if block_volume_replica_id is not None:
            pulumi.set(__self__, "block_volume_replica_id", block_volume_replica_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> pulumi.Input[str]:
        """
        (Updatable) The availability domain of the block volume replica.  Example: `Uocm:PHX-AD-1`
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="blockVolumeReplicaId")
    def block_volume_replica_id(self) -> Optional[pulumi.Input[str]]:
        """
        The block volume replica's Oracle ID (OCID).
        """
        return pulumi.get(self, "block_volume_replica_id")

    @block_volume_replica_id.setter
    def block_volume_replica_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_volume_replica_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-friendly name. Does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class CoreVolumeGroupBackupSourceDetailsArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[str],
                 volume_group_backup_id: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] region: The region of the volume backup source.
        :param pulumi.Input[str] volume_group_backup_id: The OCID of the source volume group backup.
        :param pulumi.Input[str] kms_key_id: The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "volume_group_backup_id", volume_group_backup_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the volume backup source.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="volumeGroupBackupId")
    def volume_group_backup_id(self) -> pulumi.Input[str]:
        """
        The OCID of the source volume group backup.
        """
        return pulumi.get(self, "volume_group_backup_id")

    @volume_group_backup_id.setter
    def volume_group_backup_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "volume_group_backup_id", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the KMS key in the destination region which will be the master encryption key for the copied volume backup.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


@pulumi.input_type
class CoreVolumeGroupSourceDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 volume_group_backup_id: Optional[pulumi.Input[str]] = None,
                 volume_group_id: Optional[pulumi.Input[str]] = None,
                 volume_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: The type can be one of these values: `volumeGroupBackupId`, `volumeGroupId`, `volumeIds`
        :param pulumi.Input[str] volume_group_backup_id: The OCID of the volume group backup to restore from.
        :param pulumi.Input[str] volume_group_id: The OCID of the volume group to clone from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] volume_ids: OCIDs for the volumes in this volume group.
        """
        pulumi.set(__self__, "type", type)
        if volume_group_backup_id is not None:
            pulumi.set(__self__, "volume_group_backup_id", volume_group_backup_id)
        if volume_group_id is not None:
            pulumi.set(__self__, "volume_group_id", volume_group_id)
        if volume_ids is not None:
            pulumi.set(__self__, "volume_ids", volume_ids)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `volumeGroupBackupId`, `volumeGroupId`, `volumeIds`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="volumeGroupBackupId")
    def volume_group_backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume group backup to restore from.
        """
        return pulumi.get(self, "volume_group_backup_id")

    @volume_group_backup_id.setter
    def volume_group_backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_backup_id", value)

    @property
    @pulumi.getter(name="volumeGroupId")
    def volume_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the volume group to clone from.
        """
        return pulumi.get(self, "volume_group_id")

    @volume_group_id.setter
    def volume_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_group_id", value)

    @property
    @pulumi.getter(name="volumeIds")
    def volume_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        OCIDs for the volumes in this volume group.
        """
        return pulumi.get(self, "volume_ids")

    @volume_ids.setter
    def volume_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "volume_ids", value)


@pulumi.input_type
class CoreVolumeSourceDetailsArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The OCID of the block volume replica.
        :param pulumi.Input[str] type: The type can be one of these values: `blockVolumeReplica`, `volume`, `volumeBackup`
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The OCID of the block volume replica.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type can be one of these values: `blockVolumeReplica`, `volume`, `volumeBackup`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DataSafeTargetDatabaseConnectionOptionArgs:
    def __init__(__self__, *,
                 connection_type: pulumi.Input[str],
                 datasafe_private_endpoint_id: Optional[pulumi.Input[str]] = None,
                 on_prem_connector_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] connection_type: (Updatable) The connection type used to connect to the database. Allowed values:
               * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
               * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        :param pulumi.Input[str] datasafe_private_endpoint_id: (Updatable) The OCID of the Data Safe private endpoint.
        :param pulumi.Input[str] on_prem_connector_id: (Updatable) The OCID of the on-premises connector.
        """
        pulumi.set(__self__, "connection_type", connection_type)
        if datasafe_private_endpoint_id is not None:
            pulumi.set(__self__, "datasafe_private_endpoint_id", datasafe_private_endpoint_id)
        if on_prem_connector_id is not None:
            pulumi.set(__self__, "on_prem_connector_id", on_prem_connector_id)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The connection type used to connect to the database. Allowed values:
        * PRIVATE_ENDPOINT - Represents connection through private endpoint in Data Safe.
        * ONPREM_CONNECTOR - Represents connection through on-premises connector in Data Safe.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="datasafePrivateEndpointId")
    def datasafe_private_endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the Data Safe private endpoint.
        """
        return pulumi.get(self, "datasafe_private_endpoint_id")

    @datasafe_private_endpoint_id.setter
    def datasafe_private_endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datasafe_private_endpoint_id", value)

    @property
    @pulumi.getter(name="onPremConnectorId")
    def on_prem_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the on-premises connector.
        """
        return pulumi.get(self, "on_prem_connector_id")

    @on_prem_connector_id.setter
    def on_prem_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_prem_connector_id", value)


@pulumi.input_type
class DataSafeTargetDatabaseCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 user_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: (Updatable) The password of the database user.
        :param pulumi.Input[str] user_name: (Updatable) The database user name.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        (Updatable) The password of the database user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The database user name.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class DataSafeTargetDatabaseDatabaseDetailsArgs:
    def __init__(__self__, *,
                 database_type: pulumi.Input[str],
                 infrastructure_type: pulumi.Input[str],
                 autonomous_database_id: Optional[pulumi.Input[str]] = None,
                 db_system_id: Optional[pulumi.Input[str]] = None,
                 instance_id: Optional[pulumi.Input[str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 listener_port: Optional[pulumi.Input[int]] = None,
                 service_name: Optional[pulumi.Input[str]] = None,
                 vm_cluster_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_type: (Updatable) The database type.
        :param pulumi.Input[str] infrastructure_type: (Updatable) The infrastructure type the database is running on.
        :param pulumi.Input[str] autonomous_database_id: (Updatable) The OCID of the autonomous database registered as a target database in Data Safe.
        :param pulumi.Input[str] db_system_id: (Updatable) The OCID of the cloud database system registered as a target database in Data Safe.
        :param pulumi.Input[str] instance_id: (Updatable) The OCID of the compute instance on which the database is running.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_addresses: (Updatable) A List of either the IP Addresses or FQDN names of the database hosts.
        :param pulumi.Input[int] listener_port: (Updatable) The port number of the database listener.
        :param pulumi.Input[str] service_name: (Updatable) The service name of the database registered as target database.
        :param pulumi.Input[str] vm_cluster_id: (Updatable) The OCID of the VM cluster in which the database is running.
        """
        pulumi.set(__self__, "database_type", database_type)
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        if autonomous_database_id is not None:
            pulumi.set(__self__, "autonomous_database_id", autonomous_database_id)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if vm_cluster_id is not None:
            pulumi.set(__self__, "vm_cluster_id", vm_cluster_id)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The database type.
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_type", value)

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The infrastructure type the database is running on.
        """
        return pulumi.get(self, "infrastructure_type")

    @infrastructure_type.setter
    def infrastructure_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "infrastructure_type", value)

    @property
    @pulumi.getter(name="autonomousDatabaseId")
    def autonomous_database_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the autonomous database registered as a target database in Data Safe.
        """
        return pulumi.get(self, "autonomous_database_id")

    @autonomous_database_id.setter
    def autonomous_database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autonomous_database_id", value)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the cloud database system registered as a target database in Data Safe.
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_system_id", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compute instance on which the database is running.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A List of either the IP Addresses or FQDN names of the database hosts.
        """
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_addresses", value)

    @property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The port number of the database listener.
        """
        return pulumi.get(self, "listener_port")

    @listener_port.setter
    def listener_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "listener_port", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The service name of the database registered as target database.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="vmClusterId")
    def vm_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the VM cluster in which the database is running.
        """
        return pulumi.get(self, "vm_cluster_id")

    @vm_cluster_id.setter
    def vm_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_cluster_id", value)


@pulumi.input_type
class DataSafeTargetDatabaseTlsConfigArgs:
    def __init__(__self__, *,
                 status: pulumi.Input[str],
                 certificate_store_type: Optional[pulumi.Input[str]] = None,
                 key_store_content: Optional[pulumi.Input[str]] = None,
                 store_password: Optional[pulumi.Input[str]] = None,
                 trust_store_content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: (Updatable) Status to represent whether the database connection is TLS enabled or not.
        :param pulumi.Input[str] certificate_store_type: (Updatable) The format of the certificate store.
        :param pulumi.Input[str] key_store_content: (Updatable) Base64 encoded string of key store file content.
        :param pulumi.Input[str] store_password: (Updatable) The password to read the trust store and key store files, if they are password protected.
        :param pulumi.Input[str] trust_store_content: (Updatable) Base64 encoded string of trust store file content.
        """
        pulumi.set(__self__, "status", status)
        if certificate_store_type is not None:
            pulumi.set(__self__, "certificate_store_type", certificate_store_type)
        if key_store_content is not None:
            pulumi.set(__self__, "key_store_content", key_store_content)
        if store_password is not None:
            pulumi.set(__self__, "store_password", store_password)
        if trust_store_content is not None:
            pulumi.set(__self__, "trust_store_content", trust_store_content)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input[str]:
        """
        (Updatable) Status to represent whether the database connection is TLS enabled or not.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[str]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="certificateStoreType")
    def certificate_store_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The format of the certificate store.
        """
        return pulumi.get(self, "certificate_store_type")

    @certificate_store_type.setter
    def certificate_store_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_store_type", value)

    @property
    @pulumi.getter(name="keyStoreContent")
    def key_store_content(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Base64 encoded string of key store file content.
        """
        return pulumi.get(self, "key_store_content")

    @key_store_content.setter
    def key_store_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_store_content", value)

    @property
    @pulumi.getter(name="storePassword")
    def store_password(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The password to read the trust store and key store files, if they are password protected.
        """
        return pulumi.get(self, "store_password")

    @store_password.setter
    def store_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "store_password", value)

    @property
    @pulumi.getter(name="trustStoreContent")
    def trust_store_content(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Base64 encoded string of trust store file content.
        """
        return pulumi.get(self, "trust_store_content")

    @trust_store_content.setter
    def trust_store_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trust_store_content", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 backup_destination_details: Optional[pulumi.Input['DatabaseAutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['DatabaseAutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs'] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input['DatabaseAutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input['DatabaseAutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs']]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseBackupConfigBackupDestinationDetailsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseMaintenanceWindowArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[str]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabaseMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class DatabaseAutonomousContainerDatabasePeerAutonomousContainerDatabaseBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class DatabaseAutonomousDatabaseApexDetailsArgs:
    def __init__(__self__, *,
                 apex_version: Optional[pulumi.Input[str]] = None,
                 ords_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apex_version: The Oracle APEX Application Development version.
        :param pulumi.Input[str] ords_version: The Oracle REST Data Services (ORDS) version.
        """
        if apex_version is not None:
            pulumi.set(__self__, "apex_version", apex_version)
        if ords_version is not None:
            pulumi.set(__self__, "ords_version", ords_version)

    @property
    @pulumi.getter(name="apexVersion")
    def apex_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle APEX Application Development version.
        """
        return pulumi.get(self, "apex_version")

    @apex_version.setter
    def apex_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apex_version", value)

    @property
    @pulumi.getter(name="ordsVersion")
    def ords_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle REST Data Services (ORDS) version.
        """
        return pulumi.get(self, "ords_version")

    @ords_version.setter
    def ords_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ords_version", value)


@pulumi.input_type
class DatabaseAutonomousDatabaseBackupConfigArgs:
    def __init__(__self__, *,
                 manual_backup_bucket_name: Optional[pulumi.Input[str]] = None,
                 manual_backup_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] manual_backup_bucket_name: Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        :param pulumi.Input[str] manual_backup_type: The manual backup destination type.
        """
        if manual_backup_bucket_name is not None:
            pulumi.set(__self__, "manual_backup_bucket_name", manual_backup_bucket_name)
        if manual_backup_type is not None:
            pulumi.set(__self__, "manual_backup_type", manual_backup_type)

    @property
    @pulumi.getter(name="manualBackupBucketName")
    def manual_backup_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of [Object Storage](https://docs.cloud.oracle.com/iaas/Content/Object/Concepts/objectstorageoverview.htm) bucket to use for storing manual backups.
        """
        return pulumi.get(self, "manual_backup_bucket_name")

    @manual_backup_bucket_name.setter
    def manual_backup_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manual_backup_bucket_name", value)

    @property
    @pulumi.getter(name="manualBackupType")
    def manual_backup_type(self) -> Optional[pulumi.Input[str]]:
        """
        The manual backup destination type.
        """
        return pulumi.get(self, "manual_backup_type")

    @manual_backup_type.setter
    def manual_backup_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manual_backup_type", value)


@pulumi.input_type
class DatabaseAutonomousDatabaseConnectionStringsArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 dedicated: Optional[pulumi.Input[str]] = None,
                 high: Optional[pulumi.Input[str]] = None,
                 low: Optional[pulumi.Input[str]] = None,
                 medium: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        :param pulumi.Input[str] dedicated: The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param pulumi.Input[str] high: The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        :param pulumi.Input[str] low: The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        :param pulumi.Input[str] medium: The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if high is not None:
            pulumi.set(__self__, "high", high)
        if low is not None:
            pulumi.set(__self__, "low", low)
        if medium is not None:
            pulumi.set(__self__, "medium", medium)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Returns all connection strings that can be used to connect to the Autonomous Database. For more information, please see [Predefined Database Service Names for Autonomous Transaction Processing](https://docs.oracle.com/en/cloud/paas/atp-cloud/atpug/connect-predefined.html#GUID-9747539B-FD46-44F1-8FF8-F5AC650F15BE)
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[pulumi.Input[str]]:
        """
        The database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "dedicated")

    @dedicated.setter
    def dedicated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dedicated", value)

    @property
    @pulumi.getter
    def high(self) -> Optional[pulumi.Input[str]]:
        """
        The High database service provides the highest level of resources to each SQL statement resulting in the highest performance, but supports the fewest number of concurrent SQL statements.
        """
        return pulumi.get(self, "high")

    @high.setter
    def high(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "high", value)

    @property
    @pulumi.getter
    def low(self) -> Optional[pulumi.Input[str]]:
        """
        The Low database service provides the least level of resources to each SQL statement, but supports the most number of concurrent SQL statements.
        """
        return pulumi.get(self, "low")

    @low.setter
    def low(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "low", value)

    @property
    @pulumi.getter
    def medium(self) -> Optional[pulumi.Input[str]]:
        """
        The Medium database service provides a lower level of resources to each SQL statement potentially resulting a lower level of performance, but supports more concurrent SQL statements.
        """
        return pulumi.get(self, "medium")

    @medium.setter
    def medium(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "medium", value)


@pulumi.input_type
class DatabaseAutonomousDatabaseConnectionUrlsArgs:
    def __init__(__self__, *,
                 apex_url: Optional[pulumi.Input[str]] = None,
                 graph_studio_url: Optional[pulumi.Input[str]] = None,
                 machine_learning_user_management_url: Optional[pulumi.Input[str]] = None,
                 sql_dev_web_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] apex_url: Oracle Application Express (APEX) URL.
        :param pulumi.Input[str] graph_studio_url: The URL of the Graph Studio for the Autonomous Database.
        :param pulumi.Input[str] machine_learning_user_management_url: Oracle Machine Learning user management URL.
        :param pulumi.Input[str] sql_dev_web_url: Oracle SQL Developer Web URL.
        """
        if apex_url is not None:
            pulumi.set(__self__, "apex_url", apex_url)
        if graph_studio_url is not None:
            pulumi.set(__self__, "graph_studio_url", graph_studio_url)
        if machine_learning_user_management_url is not None:
            pulumi.set(__self__, "machine_learning_user_management_url", machine_learning_user_management_url)
        if sql_dev_web_url is not None:
            pulumi.set(__self__, "sql_dev_web_url", sql_dev_web_url)

    @property
    @pulumi.getter(name="apexUrl")
    def apex_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Application Express (APEX) URL.
        """
        return pulumi.get(self, "apex_url")

    @apex_url.setter
    def apex_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apex_url", value)

    @property
    @pulumi.getter(name="graphStudioUrl")
    def graph_studio_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Graph Studio for the Autonomous Database.
        """
        return pulumi.get(self, "graph_studio_url")

    @graph_studio_url.setter
    def graph_studio_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph_studio_url", value)

    @property
    @pulumi.getter(name="machineLearningUserManagementUrl")
    def machine_learning_user_management_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle Machine Learning user management URL.
        """
        return pulumi.get(self, "machine_learning_user_management_url")

    @machine_learning_user_management_url.setter
    def machine_learning_user_management_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_learning_user_management_url", value)

    @property
    @pulumi.getter(name="sqlDevWebUrl")
    def sql_dev_web_url(self) -> Optional[pulumi.Input[str]]:
        """
        Oracle SQL Developer Web URL.
        """
        return pulumi.get(self, "sql_dev_web_url")

    @sql_dev_web_url.setter
    def sql_dev_web_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sql_dev_web_url", value)


@pulumi.input_type
class DatabaseAutonomousDatabaseCustomerContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class DatabaseAutonomousDatabaseKeyHistoryEntryArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 time_activated: Optional[pulumi.Input[str]] = None,
                 vault_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        :param pulumi.Input[str] time_activated: The date and time the kms key activated.
        :param pulumi.Input[str] vault_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if time_activated is not None:
            pulumi.set(__self__, "time_activated", time_activated)
        if vault_id is not None:
            pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the Autonomous Database [Vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts) service key management history entry.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="timeActivated")
    def time_activated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the kms key activated.
        """
        return pulumi.get(self, "time_activated")

    @time_activated.setter
    def time_activated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_activated", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class DatabaseAutonomousDatabaseStandbyDbArgs:
    def __init__(__self__, *,
                 lag_time_in_seconds: Optional[pulumi.Input[int]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] lag_time_in_seconds: The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: (Updatable) The current state of the Autonomous Database. Could be set to AVAILABLE or STOPPED
        """
        if lag_time_in_seconds is not None:
            pulumi.set(__self__, "lag_time_in_seconds", lag_time_in_seconds)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="lagTimeInSeconds")
    def lag_time_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of time, in seconds, that the data of the standby database lags the data of the primary database. Can be used to determine the potential data loss in the event of a failover.
        """
        return pulumi.get(self, "lag_time_in_seconds")

    @lag_time_in_seconds.setter
    def lag_time_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lag_time_in_seconds", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The current state of the Autonomous Database. Could be set to AVAILABLE or STOPPED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class DatabaseAutonomousExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseAutonomousExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[str]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseAutonomousExadataInfrastructureMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseAutonomousExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseBackupDestinationAssociatedDatabaseArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: The display name of the database that is associated with the backup destination.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database that is associated with the backup destination.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class DatabaseBackupDestinationMountTypeDetailsArgs:
    def __init__(__self__, *,
                 mount_type: pulumi.Input[str],
                 local_mount_point_path: Optional[pulumi.Input[str]] = None,
                 nfs_server_export: Optional[pulumi.Input[str]] = None,
                 nfs_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] mount_type: Mount type for backup destination.
        :param pulumi.Input[str] local_mount_point_path: The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        :param pulumi.Input[str] nfs_server_export: Specifies the directory on which to mount the file system
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nfs_servers: IP addresses for NFS Auto mount.
        """
        pulumi.set(__self__, "mount_type", mount_type)
        if local_mount_point_path is not None:
            pulumi.set(__self__, "local_mount_point_path", local_mount_point_path)
        if nfs_server_export is not None:
            pulumi.set(__self__, "nfs_server_export", nfs_server_export)
        if nfs_servers is not None:
            pulumi.set(__self__, "nfs_servers", nfs_servers)

    @property
    @pulumi.getter(name="mountType")
    def mount_type(self) -> pulumi.Input[str]:
        """
        Mount type for backup destination.
        """
        return pulumi.get(self, "mount_type")

    @mount_type.setter
    def mount_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "mount_type", value)

    @property
    @pulumi.getter(name="localMountPointPath")
    def local_mount_point_path(self) -> Optional[pulumi.Input[str]]:
        """
        The local directory path on each VM cluster node where the NFS server location is mounted. The local directory path and the NFS server location must each be the same across all of the VM cluster nodes. Ensure that the NFS mount is maintained continuously on all of the VM cluster nodes.
        """
        return pulumi.get(self, "local_mount_point_path")

    @local_mount_point_path.setter
    def local_mount_point_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_mount_point_path", value)

    @property
    @pulumi.getter(name="nfsServerExport")
    def nfs_server_export(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the directory on which to mount the file system
        """
        return pulumi.get(self, "nfs_server_export")

    @nfs_server_export.setter
    def nfs_server_export(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nfs_server_export", value)

    @property
    @pulumi.getter(name="nfsServers")
    def nfs_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP addresses for NFS Auto mount.
        """
        return pulumi.get(self, "nfs_servers")

    @nfs_servers.setter
    def nfs_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nfs_servers", value)


@pulumi.input_type
class DatabaseCloudExadataInfrastructureCustomerContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email address used by Oracle to send notifications regarding databases and infrastructure.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)


@pulumi.input_type
class DatabaseCloudExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[str]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseCloudExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseCloudExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseCloudVmClusterIormConfigCacheArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudVmClusterIormConfigCacheDbPlanArgs']]]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseCloudVmClusterIormConfigCacheDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the cloud VM cluster.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudVmClusterIormConfigCacheDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseCloudVmClusterIormConfigCacheDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cloud VM cluster.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class DatabaseCloudVmClusterIormConfigCacheDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


@pulumi.input_type
class DatabaseDatabaseConnectionStringsArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the Database.
        :param pulumi.Input[str] cdb_default: Host name based CDB Connection String.
        :param pulumi.Input[str] cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DatabaseDatabaseDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 db_name: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigArgs']] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \#, or -.
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_unique_name: The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        :param pulumi.Input[str] db_workload: The database workload type.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \#, or -.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "db_name", db_name)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        """
        The `DB_UNIQUE_NAME` of the Oracle Database being backed up.
        """
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)


@pulumi.input_type
class DatabaseDatabaseDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class DatabaseDatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatabaseDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class DatabaseDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatabaseDatabaseUpgradeConnectionStringsArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the Database.
        :param pulumi.Input[str] cdb_default: Host name based CDB Connection String.
        :param pulumi.Input[str] cdb_ip_default: IP based CDB Connection String.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the Database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        Host name based CDB Connection String.
        """
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        IP based CDB Connection String.
        """
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DatabaseDatabaseUpgradeDatabaseUpgradeSourceDetailsArgs:
    def __init__(__self__, *,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_version: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        :param pulumi.Input[str] db_version: A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param pulumi.Input[str] options: Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        :param pulumi.Input[str] source: The source of the Oracle Database software to be used for the upgrade.
               * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
               * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
        """
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the image to be used to upgrade a database.
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        """
        A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        Additional upgrade options supported by DBUA(Database Upgrade Assistant). Example: "-upgradeTimezone false -keepEvents"
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the Oracle Database software to be used for the upgrade.
        * Use `DB_VERSION` to specify a generally-available Oracle Database software version to upgrade the database.
        * Use `DB_SOFTWARE_IMAGE` to specify a [database software image](https://docs.cloud.oracle.com/iaas/Content/Database/Concepts/databasesoftwareimage.htm) to upgrade the database.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class DatabaseDatabaseUpgradeDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class DatabaseDatabaseUpgradeDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 internet_proxy: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 vpc_password: Optional[pulumi.Input[str]] = None,
                 vpc_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        :param pulumi.Input[str] internet_proxy: Proxy URL to connect to object store.
        :param pulumi.Input[str] type: Type of the database backup destination.
        :param pulumi.Input[str] vpc_password: For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        :param pulumi.Input[str] vpc_user: For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if internet_proxy is not None:
            pulumi.set(__self__, "internet_proxy", internet_proxy)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vpc_password is not None:
            pulumi.set(__self__, "vpc_password", vpc_password)
        if vpc_user is not None:
            pulumi.set(__self__, "vpc_user", vpc_user)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the database.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="internetProxy")
    def internet_proxy(self) -> Optional[pulumi.Input[str]]:
        """
        Proxy URL to connect to object store.
        """
        return pulumi.get(self, "internet_proxy")

    @internet_proxy.setter
    def internet_proxy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internet_proxy", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vpcPassword")
    def vpc_password(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the password for the VPC user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_password")

    @vpc_password.setter
    def vpc_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_password", value)

    @property
    @pulumi.getter(name="vpcUser")
    def vpc_user(self) -> Optional[pulumi.Input[str]]:
        """
        For a RECOVERY_APPLIANCE backup destination, the Virtual Private Catalog (VPC) user that is used to access the Recovery Appliance.
        """
        return pulumi.get(self, "vpc_user")

    @vpc_user.setter
    def vpc_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_user", value)


@pulumi.input_type
class DatabaseDbHomeDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbHomeDatabaseConnectionStringArgs']]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigArgs']] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 one_off_patches: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_stamp_for_point_in_time_recovery: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \#, or -.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
        :param pulumi.Input[str] database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        :param pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] db_workload: The database workload type.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] one_off_patches: List of one-off patches for Database Homes.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[str] state: The current state of the Database Home.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \#, or -.
        :param pulumi.Input[str] time_created: The date and time the Database Home was created.
        :param pulumi.Input[str] time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if one_off_patches is not None:
            pulumi.set(__self__, "one_off_patches", one_off_patches)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbHomeDatabaseConnectionStringArgs']]]]:
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbHomeDatabaseConnectionStringArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm)
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="oneOffPatches")
    def one_off_patches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of one-off patches for Database Homes.
        """
        return pulumi.get(self, "one_off_patches")

    @one_off_patches.setter
    def one_off_patches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "one_off_patches", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the Database Home.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Database Home was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @time_stamp_for_point_in_time_recovery.setter
    def time_stamp_for_point_in_time_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_stamp_for_point_in_time_recovery", value)


@pulumi.input_type
class DatabaseDbHomeDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DatabaseDbHomeDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class DatabaseDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination. Supported values: `NFS`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination. Supported values: `NFS`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatabaseDbSystemDbHomeArgs:
    def __init__(__self__, *,
                 database: pulumi.Input['DatabaseDbSystemDbHomeDatabaseArgs'],
                 create_async: Optional[pulumi.Input[bool]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_home_location: Optional[pulumi.Input[str]] = None,
                 db_version: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 last_patch_history_entry_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DatabaseDbSystemDbHomeDatabaseArgs'] database: (Updatable) Details for creating a database by restoring from a source database system.
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] db_version: A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[str] display_name: The user-friendly name for the DB system. The name does not have to be unique.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] last_patch_history_entry_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] state: The current state of the DB system.
        :param pulumi.Input[str] time_created: The date and time the DB system was created.
        """
        pulumi.set(__self__, "database", database)
        if create_async is not None:
            pulumi.set(__self__, "create_async", create_async)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_home_location is not None:
            pulumi.set(__self__, "db_home_location", db_home_location)
        if db_version is not None:
            pulumi.set(__self__, "db_version", db_version)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if last_patch_history_entry_id is not None:
            pulumi.set(__self__, "last_patch_history_entry_id", last_patch_history_entry_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input['DatabaseDbSystemDbHomeDatabaseArgs']:
        """
        (Updatable) Details for creating a database by restoring from a source database system.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input['DatabaseDbSystemDbHomeDatabaseArgs']):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="createAsync")
    def create_async(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_async")

    @create_async.setter
    def create_async(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_async", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbHomeLocation")
    def db_home_location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_home_location")

    @db_home_location.setter
    def db_home_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_home_location", value)

    @property
    @pulumi.getter(name="dbVersion")
    def db_version(self) -> Optional[pulumi.Input[str]]:
        """
        A valid Oracle Database version. To get a list of supported versions, use the [ListDbVersions](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/DbVersionSummary/ListDbVersions) operation.
        """
        return pulumi.get(self, "db_version")

    @db_version.setter
    def db_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_version", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The user-friendly name for the DB system. The name does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lastPatchHistoryEntryId")
    def last_patch_history_entry_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the last patch history. This value is updated as soon as a patch operation starts.
        """
        return pulumi.get(self, "last_patch_history_entry_id")

    @last_patch_history_entry_id.setter
    def last_patch_history_entry_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_patch_history_entry_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)


@pulumi.input_type
class DatabaseDbSystemDbHomeDatabaseArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None,
                 backup_tde_password: Optional[pulumi.Input[str]] = None,
                 character_set: Optional[pulumi.Input[str]] = None,
                 connection_strings: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemDbHomeDatabaseConnectionStringArgs']]]] = None,
                 database_id: Optional[pulumi.Input[str]] = None,
                 database_software_image_id: Optional[pulumi.Input[str]] = None,
                 db_backup_config: Optional[pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigArgs']] = None,
                 db_domain: Optional[pulumi.Input[str]] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 db_unique_name: Optional[pulumi.Input[str]] = None,
                 db_workload: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 ncharacter_set: Optional[pulumi.Input[str]] = None,
                 pdb_name: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tde_wallet_password: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_stamp_for_point_in_time_recovery: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \#, or -.
        :param pulumi.Input[str] backup_id: The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] backup_tde_password: The password to open the TDE wallet.
        :param pulumi.Input[str] character_set: The character set for the database.  The default is AL32UTF8. Allowed values are:
        :param pulumi.Input[str] database_id: The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input[str] database_software_image_id: The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        :param pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigArgs'] db_backup_config: (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        :param pulumi.Input[str] db_domain: The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] db_workload: The database workload type.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] ncharacter_set: The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        :param pulumi.Input[str] pdb_name: The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        :param pulumi.Input[str] state: The current state of the DB system.
        :param pulumi.Input[str] tde_wallet_password: The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \#, or -.
        :param pulumi.Input[str] time_created: The date and time the DB system was created.
        :param pulumi.Input[str] time_stamp_for_point_in_time_recovery: The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)
        if backup_tde_password is not None:
            pulumi.set(__self__, "backup_tde_password", backup_tde_password)
        if character_set is not None:
            pulumi.set(__self__, "character_set", character_set)
        if connection_strings is not None:
            pulumi.set(__self__, "connection_strings", connection_strings)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if database_software_image_id is not None:
            pulumi.set(__self__, "database_software_image_id", database_software_image_id)
        if db_backup_config is not None:
            pulumi.set(__self__, "db_backup_config", db_backup_config)
        if db_domain is not None:
            pulumi.set(__self__, "db_domain", db_domain)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_unique_name is not None:
            pulumi.set(__self__, "db_unique_name", db_unique_name)
        if db_workload is not None:
            pulumi.set(__self__, "db_workload", db_workload)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if ncharacter_set is not None:
            pulumi.set(__self__, "ncharacter_set", ncharacter_set)
        if pdb_name is not None:
            pulumi.set(__self__, "pdb_name", pdb_name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if tde_wallet_password is not None:
            pulumi.set(__self__, "tde_wallet_password", tde_wallet_password)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_stamp_for_point_in_time_recovery is not None:
            pulumi.set(__self__, "time_stamp_for_point_in_time_recovery", time_stamp_for_point_in_time_recovery)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        A strong password for SYS, SYSTEM, PDB Admin and TDE Wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numbers, and two special characters. The special characters must be _, \#, or -.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The backup [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)

    @property
    @pulumi.getter(name="backupTdePassword")
    def backup_tde_password(self) -> Optional[pulumi.Input[str]]:
        """
        The password to open the TDE wallet.
        """
        return pulumi.get(self, "backup_tde_password")

    @backup_tde_password.setter
    def backup_tde_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_tde_password", value)

    @property
    @pulumi.getter(name="characterSet")
    def character_set(self) -> Optional[pulumi.Input[str]]:
        """
        The character set for the database.  The default is AL32UTF8. Allowed values are:
        """
        return pulumi.get(self, "character_set")

    @character_set.setter
    def character_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "character_set", value)

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemDbHomeDatabaseConnectionStringArgs']]]]:
        return pulumi.get(self, "connection_strings")

    @connection_strings.setter
    def connection_strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemDbHomeDatabaseConnectionStringArgs']]]]):
        pulumi.set(self, "connection_strings", value)

    @property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_id", value)

    @property
    @pulumi.getter(name="databaseSoftwareImageId")
    def database_software_image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The database software image [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "database_software_image_id")

    @database_software_image_id.setter
    def database_software_image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_software_image_id", value)

    @property
    @pulumi.getter(name="dbBackupConfig")
    def db_backup_config(self) -> Optional[pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigArgs']]:
        """
        (Updatable) Backup Options To use any of the API operations, you must be authorized in an IAM policy. If you're not authorized, talk to an administrator. If you're an administrator who needs to write policies to give users access, see [Getting Started with Policies](https://docs.cloud.oracle.com/iaas/Content/Identity/Concepts/policygetstarted.htm).
        """
        return pulumi.get(self, "db_backup_config")

    @db_backup_config.setter
    def db_backup_config(self, value: Optional[pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigArgs']]):
        pulumi.set(self, "db_backup_config", value)

    @property
    @pulumi.getter(name="dbDomain")
    def db_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The database domain. In a distributed database system, DB_DOMAIN specifies the logical location of the database within the network structure.
        """
        return pulumi.get(self, "db_domain")

    @db_domain.setter
    def db_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_domain", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbUniqueName")
    def db_unique_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_unique_name")

    @db_unique_name.setter
    def db_unique_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_unique_name", value)

    @property
    @pulumi.getter(name="dbWorkload")
    def db_workload(self) -> Optional[pulumi.Input[str]]:
        """
        The database workload type.
        """
        return pulumi.get(self, "db_workload")

    @db_workload.setter
    def db_workload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_workload", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Free-form tags for this resource. Each tag is a simple key-value pair with no predefined name, type, or namespace. For more information, see [Resource Tags](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/resourcetags.htm).  Example: `{"Department": "Finance"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter(name="ncharacterSet")
    def ncharacter_set(self) -> Optional[pulumi.Input[str]]:
        """
        The national character set for the database.  The default is AL16UTF16. Allowed values are: AL16UTF16 or UTF8.
        """
        return pulumi.get(self, "ncharacter_set")

    @ncharacter_set.setter
    def ncharacter_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ncharacter_set", value)

    @property
    @pulumi.getter(name="pdbName")
    def pdb_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the pluggable database. The name must begin with an alphabetic character and can contain a maximum of thirty alphanumeric characters. Special characters are not permitted. Pluggable database should not be same as database name.
        """
        return pulumi.get(self, "pdb_name")

    @pdb_name.setter
    def pdb_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_name", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="tdeWalletPassword")
    def tde_wallet_password(self) -> Optional[pulumi.Input[str]]:
        """
        The optional password to open the TDE wallet. The password must be at least nine characters and contain at least two uppercase, two lowercase, two numeric, and two special characters. The special characters must be _, \#, or -.
        """
        return pulumi.get(self, "tde_wallet_password")

    @tde_wallet_password.setter
    def tde_wallet_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tde_wallet_password", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB system was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeStampForPointInTimeRecovery")
    def time_stamp_for_point_in_time_recovery(self) -> Optional[pulumi.Input[str]]:
        """
        The point in time of the original database from which the new database is created. If not specifed, the latest backup is used to create the database.
        """
        return pulumi.get(self, "time_stamp_for_point_in_time_recovery")

    @time_stamp_for_point_in_time_recovery.setter
    def time_stamp_for_point_in_time_recovery(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_stamp_for_point_in_time_recovery", value)


@pulumi.input_type
class DatabaseDbSystemDbHomeDatabaseConnectionStringArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 cdb_default: Optional[pulumi.Input[str]] = None,
                 cdb_ip_default: Optional[pulumi.Input[str]] = None):
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if cdb_default is not None:
            pulumi.set(__self__, "cdb_default", cdb_default)
        if cdb_ip_default is not None:
            pulumi.set(__self__, "cdb_ip_default", cdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="cdbDefault")
    def cdb_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_default")

    @cdb_default.setter
    def cdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_default", value)

    @property
    @pulumi.getter(name="cdbIpDefault")
    def cdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cdb_ip_default")

    @cdb_ip_default.setter
    def cdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cdb_ip_default", value)


@pulumi.input_type
class DatabaseDbSystemDbHomeDatabaseDbBackupConfigArgs:
    def __init__(__self__, *,
                 auto_backup_enabled: Optional[pulumi.Input[bool]] = None,
                 auto_backup_window: Optional[pulumi.Input[str]] = None,
                 backup_destination_details: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]] = None,
                 recovery_window_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] auto_backup_enabled: (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        :param pulumi.Input[str] auto_backup_window: (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]] backup_destination_details: (Updatable) Backup destination details.
        :param pulumi.Input[int] recovery_window_in_days: (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        if auto_backup_enabled is not None:
            pulumi.set(__self__, "auto_backup_enabled", auto_backup_enabled)
        if auto_backup_window is not None:
            pulumi.set(__self__, "auto_backup_window", auto_backup_window)
        if backup_destination_details is not None:
            pulumi.set(__self__, "backup_destination_details", backup_destination_details)
        if recovery_window_in_days is not None:
            pulumi.set(__self__, "recovery_window_in_days", recovery_window_in_days)

    @property
    @pulumi.getter(name="autoBackupEnabled")
    def auto_backup_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If set to true, configures automatic backups. If you previously used RMAN or dbcli to configure backups and then you switch to using the Console or the API for backups, a new backup configuration is created and associated with your database. This means that you can no longer rely on your previously configured unmanaged backups to work.
        """
        return pulumi.get(self, "auto_backup_enabled")

    @auto_backup_enabled.setter
    def auto_backup_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_backup_enabled", value)

    @property
    @pulumi.getter(name="autoBackupWindow")
    def auto_backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Time window selected for initiating automatic backup for the database system. There are twelve available two-hour time windows. If no option is selected, a start time between 12:00 AM to 7:00 AM in the region of the database is automatically chosen. For example, if the user selects SLOT_TWO from the enum list, the automatic backup job will start in between 2:00 AM (inclusive) to 4:00 AM (exclusive).  Example: `SLOT_TWO`
        """
        return pulumi.get(self, "auto_backup_window")

    @auto_backup_window.setter
    def auto_backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auto_backup_window", value)

    @property
    @pulumi.getter(name="backupDestinationDetails")
    def backup_destination_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]:
        """
        (Updatable) Backup destination details.
        """
        return pulumi.get(self, "backup_destination_details")

    @backup_destination_details.setter
    def backup_destination_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs']]]]):
        pulumi.set(self, "backup_destination_details", value)

    @property
    @pulumi.getter(name="recoveryWindowInDays")
    def recovery_window_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days between the current and the earliest point of recoverability covered by automatic backups. This value applies to automatic backups only. After a new automatic backup has been created, Oracle removes old automatic backups that are created before the window. When the value is updated, it is applied to all existing automatic backups.
        """
        return pulumi.get(self, "recovery_window_in_days")

    @recovery_window_in_days.setter
    def recovery_window_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_in_days", value)


@pulumi.input_type
class DatabaseDbSystemDbHomeDatabaseDbBackupConfigBackupDestinationDetailArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        :param pulumi.Input[str] type: Type of the database backup destination.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the backup destination.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the database backup destination.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatabaseDbSystemDbSystemOptionsArgs:
    def __init__(__self__, *,
                 storage_management: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] storage_management: The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        if storage_management is not None:
            pulumi.set(__self__, "storage_management", storage_management)

    @property
    @pulumi.getter(name="storageManagement")
    def storage_management(self) -> Optional[pulumi.Input[str]]:
        """
        The storage option used in DB system. ASM - Automatic storage management LVM - Logical Volume management
        """
        return pulumi.get(self, "storage_management")

    @storage_management.setter
    def storage_management(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_management", value)


@pulumi.input_type
class DatabaseDbSystemIormConfigCacheArgs:
    def __init__(__self__, *,
                 db_plans: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemIormConfigCacheDbPlanArgs']]]] = None,
                 db_system_id: Optional[pulumi.Input[str]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 objective: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemIormConfigCacheDbPlanArgs']]] db_plans: An array of IORM settings for all the database in the Exadata DB system.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycle state.
        :param pulumi.Input[str] objective: The current value for the IORM objective. The default is `AUTO`.
        :param pulumi.Input[str] state: The current state of the DB system.
        """
        if db_plans is not None:
            pulumi.set(__self__, "db_plans", db_plans)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if objective is not None:
            pulumi.set(__self__, "objective", objective)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="dbPlans")
    def db_plans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemIormConfigCacheDbPlanArgs']]]]:
        """
        An array of IORM settings for all the database in the Exadata DB system.
        """
        return pulumi.get(self, "db_plans")

    @db_plans.setter
    def db_plans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemIormConfigCacheDbPlanArgs']]]]):
        pulumi.set(self, "db_plans", value)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_system_id", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycle state.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def objective(self) -> Optional[pulumi.Input[str]]:
        """
        The current value for the IORM objective. The default is `AUTO`.
        """
        return pulumi.get(self, "objective")

    @objective.setter
    def objective(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "objective", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the DB system.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class DatabaseDbSystemIormConfigCacheDbPlanArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 flash_cache_limit: Optional[pulumi.Input[str]] = None,
                 share: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] db_name: The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        :param pulumi.Input[int] share: The relative priority of this database.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)
        if share is not None:
            pulumi.set(__self__, "share", share)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the database to be created from the backup. It must begin with an alphabetic character and can contain a maximum of eight alphanumeric characters. Special characters are not permitted.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)

    @property
    @pulumi.getter
    def share(self) -> Optional[pulumi.Input[int]]:
        """
        The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "share", value)


@pulumi.input_type
class DatabaseDbSystemMaintenanceWindowArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowMonthArgs']]]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseDbSystemMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseDbSystemMaintenanceWindowDetailsArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsMonthArgs']]]] = None,
                 preference: Optional[pulumi.Input[str]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if preference is not None:
            pulumi.set(__self__, "preference", preference)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseDbSystemMaintenanceWindowDetailsMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter
    def preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseDbSystemMaintenanceWindowDetailsDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseDbSystemMaintenanceWindowDetailsMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseDbSystemMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseExadataInfrastructureContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 is_primary: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email for the Exadata Infrastructure contact.
        :param pulumi.Input[bool] is_primary: (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        :param pulumi.Input[bool] is_contact_mos_validated: (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        :param pulumi.Input[str] phone_number: (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        """
        (Updatable) The email for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a primary contact. If `false`, this Exadata Infrastructure is a secondary contact.
        """
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If `true`, this Exadata Infrastructure contact is a valid My Oracle Support (MOS) contact. If `false`, this Exadata Infrastructure contact is not a valid MOS contact.
        """
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The phone number for the Exadata Infrastructure contact.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class DatabaseExadataInfrastructureMaintenanceWindowArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] preference: (Updatable) The maintenance window scheduling preference.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]] days_of_weeks: (Updatable) Days during the week when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] hours_of_days: (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
               * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        :param pulumi.Input[int] lead_time_in_weeks: (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowMonthArgs']]] months: (Updatable) Months during the year when maintenance should be performed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weeks_of_months: (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input[str]:
        """
        (Updatable) The maintenance window scheduling preference.
        """
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[str]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]:
        """
        (Updatable) Days during the week when maintenance should be performed.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) The window of hours during the day when maintenance should be performed. The window is a 4 hour slot. Valid values are
        * 0 - represents time slot 0:00 - 3:59 UTC - 4 - represents time slot 4:00 - 7:59 UTC - 8 - represents time slot 8:00 - 11:59 UTC - 12 - represents time slot 12:00 - 15:59 UTC - 16 - represents time slot 16:00 - 19:59 UTC - 20 - represents time slot 20:00 - 23:59 UTC
        """
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Lead time window allows user to set a lead time to prepare for a down time. The lead time is in weeks and valid value is between 1 to 4.
        """
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowMonthArgs']]]]:
        """
        (Updatable) Months during the year when maintenance should be performed.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        (Updatable) Weeks during the month when maintenance should be performed. Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a duration of 7 days. Weeks start and end based on calendar dates, not days of the week. For example, to allow maintenance during the 2nd week of the month (from the 8th day to the 14th day of the month), use the value 2. Maintenance cannot be scheduled for the fifth week of months that contain more than 28 days. Note that this parameter works in conjunction with the  daysOfWeek and hoursOfDay parameters to allow you to specify specific days of the week and hours that maintenance will be performed.
        """
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseExadataInfrastructureMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseExadataInfrastructureMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseExadataInfrastructureStorageContactArgs:
    def __init__(__self__, *,
                 email: pulumi.Input[str],
                 is_primary: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 is_contact_mos_validated: Optional[pulumi.Input[bool]] = None,
                 phone_number: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "is_primary", is_primary)
        pulumi.set(__self__, "name", name)
        if is_contact_mos_validated is not None:
            pulumi.set(__self__, "is_contact_mos_validated", is_contact_mos_validated)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter
    def email(self) -> pulumi.Input[str]:
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[str]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="isPrimary")
    def is_primary(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "is_primary")

    @is_primary.setter
    def is_primary(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_primary", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="isContactMosValidated")
    def is_contact_mos_validated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_contact_mos_validated")

    @is_contact_mos_validated.setter
    def is_contact_mos_validated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_contact_mos_validated", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class DatabaseExadataInfrastructureStorageMaintenanceWindowArgs:
    def __init__(__self__, *,
                 preference: pulumi.Input[str],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]] = None,
                 hours_of_days: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 lead_time_in_weeks: Optional[pulumi.Input[int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]] = None,
                 weeks_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        pulumi.set(__self__, "preference", preference)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hours_of_days is not None:
            pulumi.set(__self__, "hours_of_days", hours_of_days)
        if lead_time_in_weeks is not None:
            pulumi.set(__self__, "lead_time_in_weeks", lead_time_in_weeks)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if weeks_of_months is not None:
            pulumi.set(__self__, "weeks_of_months", weeks_of_months)

    @property
    @pulumi.getter
    def preference(self) -> pulumi.Input[str]:
        return pulumi.get(self, "preference")

    @preference.setter
    def preference(self, value: pulumi.Input[str]):
        pulumi.set(self, "preference", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]]:
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs']]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hoursOfDays")
    def hours_of_days(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "hours_of_days")

    @hours_of_days.setter
    def hours_of_days(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "hours_of_days", value)

    @property
    @pulumi.getter(name="leadTimeInWeeks")
    def lead_time_in_weeks(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "lead_time_in_weeks")

    @lead_time_in_weeks.setter
    def lead_time_in_weeks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "lead_time_in_weeks", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]]:
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseExadataInfrastructureStorageMaintenanceWindowMonthArgs']]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weeksOfMonths")
    def weeks_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "weeks_of_months")

    @weeks_of_months.setter
    def weeks_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weeks_of_months", value)


@pulumi.input_type
class DatabaseExadataInfrastructureStorageMaintenanceWindowDaysOfWeekArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseExadataInfrastructureStorageMaintenanceWindowMonthArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseExadataIormConfigDbPlanArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[str],
                 share: pulumi.Input[int],
                 flash_cache_limit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        :param pulumi.Input[int] share: (Updatable) The relative priority of this database.
        :param pulumi.Input[str] flash_cache_limit: The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "share", share)
        if flash_cache_limit is not None:
            pulumi.set(__self__, "flash_cache_limit", flash_cache_limit)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The database name. For the default `DbPlan`, the `dbName` is `default`.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def share(self) -> pulumi.Input[int]:
        """
        (Updatable) The relative priority of this database.
        """
        return pulumi.get(self, "share")

    @share.setter
    def share(self, value: pulumi.Input[int]):
        pulumi.set(self, "share", value)

    @property
    @pulumi.getter(name="flashCacheLimit")
    def flash_cache_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The flash cache limit for this database. This value is internally configured based on the share value assigned to the database.
        """
        return pulumi.get(self, "flash_cache_limit")

    @flash_cache_limit.setter
    def flash_cache_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flash_cache_limit", value)


@pulumi.input_type
class DatabaseExternalContainerDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


@pulumi.input_type
class DatabaseExternalDatabaseConnectorConnectionCredentialsArgs:
    def __init__(__self__, *,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 credential_type: Optional[pulumi.Input[str]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] credential_name: (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        :param pulumi.Input[str] credential_type: (Updatable) The type of credential used to connect to the database.
        :param pulumi.Input[str] password: (Updatable) The password that will be used to connect to the database.
        :param pulumi.Input[str] role: (Updatable) The role of the user that will be connecting to the database.
        :param pulumi.Input[str] username: (Updatable) The username that will be used to connect to the database.
        """
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if credential_type is not None:
            pulumi.set(__self__, "credential_type", credential_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the credential information that used to connect to the database. The name should be in "x.y" format, where the length of "x" has a maximum of 64 characters, and length of "y" has a maximum of 199 characters. The name strings can contain letters, numbers and the underscore character only. Other characters are not valid, except for the "." character that separates the "x" and "y" portions of the name. *IMPORTANT* - The name must be unique within the Oracle Cloud Infrastructure region the credential is being created in. If you specify a name that duplicates the name of another credential within the same Oracle Cloud Infrastructure region, you may overwrite or corrupt the credential that is already using the name.
        """
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of credential used to connect to the database.
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The password that will be used to connect to the database.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The role of the user that will be connecting to the database.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The username that will be used to connect to the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DatabaseExternalDatabaseConnectorConnectionStringArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 service: pulumi.Input[str]):
        """
        :param pulumi.Input[str] hostname: (Updatable) The host name of the database.
        :param pulumi.Input[int] port: (Updatable) The port used to connect to the database.
        :param pulumi.Input[str] protocol: (Updatable) The protocol used to connect to the database.
        :param pulumi.Input[str] service: (Updatable) The name of the service alias used to connect to the database.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The host name of the database.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        (Updatable) The port used to connect to the database.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The protocol used to connect to the database.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the service alias used to connect to the database.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)


@pulumi.input_type
class DatabaseExternalNonContainerDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


@pulumi.input_type
class DatabaseExternalNonContainerDatabaseOperationsInsightsConfigArgs:
    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[pulumi.Input[str]] = None,
                 operations_insights_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @operations_insights_connector_id.setter
    def operations_insights_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_connector_id", value)

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")

    @operations_insights_status.setter
    def operations_insights_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_status", value)


@pulumi.input_type
class DatabaseExternalPluggableDatabaseDatabaseManagementConfigArgs:
    def __init__(__self__, *,
                 database_management_connection_id: Optional[pulumi.Input[str]] = None,
                 database_management_status: Optional[pulumi.Input[str]] = None,
                 license_model: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_management_connection_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] database_management_status: The status of the Database Management service.
        :param pulumi.Input[str] license_model: The Oracle license model that applies to the external database.
        """
        if database_management_connection_id is not None:
            pulumi.set(__self__, "database_management_connection_id", database_management_connection_id)
        if database_management_status is not None:
            pulumi.set(__self__, "database_management_status", database_management_status)
        if license_model is not None:
            pulumi.set(__self__, "license_model", license_model)

    @property
    @pulumi.getter(name="databaseManagementConnectionId")
    def database_management_connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "database_management_connection_id")

    @database_management_connection_id.setter
    def database_management_connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_connection_id", value)

    @property
    @pulumi.getter(name="databaseManagementStatus")
    def database_management_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the Database Management service.
        """
        return pulumi.get(self, "database_management_status")

    @database_management_status.setter
    def database_management_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_management_status", value)

    @property
    @pulumi.getter(name="licenseModel")
    def license_model(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle license model that applies to the external database.
        """
        return pulumi.get(self, "license_model")

    @license_model.setter
    def license_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_model", value)


@pulumi.input_type
class DatabaseExternalPluggableDatabaseOperationsInsightsConfigArgs:
    def __init__(__self__, *,
                 operations_insights_connector_id: Optional[pulumi.Input[str]] = None,
                 operations_insights_status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operations_insights_connector_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        :param pulumi.Input[str] operations_insights_status: The status of Operations Insights
        """
        if operations_insights_connector_id is not None:
            pulumi.set(__self__, "operations_insights_connector_id", operations_insights_connector_id)
        if operations_insights_status is not None:
            pulumi.set(__self__, "operations_insights_status", operations_insights_status)

    @property
    @pulumi.getter(name="operationsInsightsConnectorId")
    def operations_insights_connector_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the [external database connector](https://docs.cloud.oracle.com/iaas/api/#/en/database/latest/datatypes/CreateExternalDatabaseConnectorDetails).
        """
        return pulumi.get(self, "operations_insights_connector_id")

    @operations_insights_connector_id.setter
    def operations_insights_connector_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_connector_id", value)

    @property
    @pulumi.getter(name="operationsInsightsStatus")
    def operations_insights_status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of Operations Insights
        """
        return pulumi.get(self, "operations_insights_status")

    @operations_insights_status.setter
    def operations_insights_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operations_insights_status", value)


@pulumi.input_type
class DatabaseKeyStoreAssociatedDatabaseArgs:
    def __init__(__self__, *,
                 db_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_name: The name of the database that is associated with the key store.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the database that is associated with the key store.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the key store.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class DatabaseKeyStoreTypeDetailsArgs:
    def __init__(__self__, *,
                 admin_username: pulumi.Input[str],
                 connection_ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 secret_id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] admin_username: (Updatable) The administrator username to connect to Oracle Key Vault
        :param pulumi.Input[Sequence[pulumi.Input[str]]] connection_ips: (Updatable) The list of Oracle Key Vault connection IP addresses.
        :param pulumi.Input[str] secret_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        :param pulumi.Input[str] type: (Updatable) The type of key store.
        :param pulumi.Input[str] vault_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "connection_ips", connection_ips)
        pulumi.set(__self__, "secret_id", secret_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        (Updatable) The administrator username to connect to Oracle Key Vault
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="connectionIps")
    def connection_ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of Oracle Key Vault connection IP addresses.
        """
        return pulumi.get(self, "connection_ips")

    @connection_ips.setter
    def connection_ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "connection_ips", value)

    @property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [secret](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "secret_id")

    @secret_id.setter
    def secret_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of key store.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Oracle Cloud Infrastructure [vault](https://docs.cloud.oracle.com/iaas/Content/KeyManagement/Concepts/keyoverview.htm#concepts).
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class DatabaseManagementManagedDatabaseGroupManagedDatabaseArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 database_sub_type: Optional[pulumi.Input[str]] = None,
                 database_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 time_added: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment in which the Managed Database Group resides.
        :param pulumi.Input[str] database_sub_type: The subtype of the Oracle Database. Indicates whether the database is a Container Database, Pluggable Database, or a Non-container Database.
        :param pulumi.Input[str] database_type: The type of Oracle Database installation.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the managed database that needs to be added to the Managed Database Group.
        :param pulumi.Input[str] name: The name of the Managed Database Group. Valid characters are uppercase or lowercase letters, numbers, and "_". The name of the Managed Database Group cannot be modified. It must be unique in the compartment and must begin with an alphabetic character.
        :param pulumi.Input[str] time_added: The date and time the Managed Database was added to the group.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if database_sub_type is not None:
            pulumi.set(__self__, "database_sub_type", database_sub_type)
        if database_type is not None:
            pulumi.set(__self__, "database_type", database_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if time_added is not None:
            pulumi.set(__self__, "time_added", time_added)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment in which the Managed Database Group resides.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="databaseSubType")
    def database_sub_type(self) -> Optional[pulumi.Input[str]]:
        """
        The subtype of the Oracle Database. Indicates whether the database is a Container Database, Pluggable Database, or a Non-container Database.
        """
        return pulumi.get(self, "database_sub_type")

    @database_sub_type.setter
    def database_sub_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_sub_type", value)

    @property
    @pulumi.getter(name="databaseType")
    def database_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of Oracle Database installation.
        """
        return pulumi.get(self, "database_type")

    @database_type.setter
    def database_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the managed database that needs to be added to the Managed Database Group.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Managed Database Group. Valid characters are uppercase or lowercase letters, numbers, and "_". The name of the Managed Database Group cannot be modified. It must be unique in the compartment and must begin with an alphabetic character.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="timeAdded")
    def time_added(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Managed Database was added to the group.
        """
        return pulumi.get(self, "time_added")

    @time_added.setter
    def time_added(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_added", value)


@pulumi.input_type
class DatabaseManagementManagedDatabasesChangeDatabaseParameterCredentialsArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: The password for the database user name.
        :param pulumi.Input[str] role: The role of the database user. Indicates whether the database user is a normal user or sysdba.
        :param pulumi.Input[str] user_name: The database user name used to perform management activity.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for the database user name.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The role of the database user. Indicates whether the database user is a normal user or sysdba.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database user name used to perform management activity.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class DatabaseManagementManagedDatabasesChangeDatabaseParameterParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str],
                 update_comment: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The parameter name.
        :param pulumi.Input[str] value: The parameter value.
        :param pulumi.Input[str] update_comment: A comment string to associate with the change in parameter value. It cannot contain control characters or a line break.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if update_comment is not None:
            pulumi.set(__self__, "update_comment", update_comment)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The parameter name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="updateComment")
    def update_comment(self) -> Optional[pulumi.Input[str]]:
        """
        A comment string to associate with the change in parameter value. It cannot contain control characters or a line break.
        """
        return pulumi.get(self, "update_comment")

    @update_comment.setter
    def update_comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_comment", value)


@pulumi.input_type
class DatabaseManagementManagedDatabasesResetDatabaseParameterCredentialsArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 user_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: The password for the database user name.
        :param pulumi.Input[str] role: The role of the database user. Indicates whether the database user is a normal user or sysdba.
        :param pulumi.Input[str] user_name: The database user name used to perform management activity.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        The password for the database user name.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        The role of the database user. Indicates whether the database user is a normal user or sysdba.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[str]]:
        """
        The database user name used to perform management activity.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_name", value)


@pulumi.input_type
class DatabaseMigrationAdditionalMigrationArgs:
    def __init__(__self__, *,
                 cloud_exadata_infrastructure_id: Optional[pulumi.Input[str]] = None,
                 cloud_vm_cluster_id: Optional[pulumi.Input[str]] = None,
                 db_system_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_exadata_infrastructure_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Exadata infrastructure.
        :param pulumi.Input[str] cloud_vm_cluster_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster.
        :param pulumi.Input[str] db_system_id: The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        if cloud_exadata_infrastructure_id is not None:
            pulumi.set(__self__, "cloud_exadata_infrastructure_id", cloud_exadata_infrastructure_id)
        if cloud_vm_cluster_id is not None:
            pulumi.set(__self__, "cloud_vm_cluster_id", cloud_vm_cluster_id)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)

    @property
    @pulumi.getter(name="cloudExadataInfrastructureId")
    def cloud_exadata_infrastructure_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud Exadata infrastructure.
        """
        return pulumi.get(self, "cloud_exadata_infrastructure_id")

    @cloud_exadata_infrastructure_id.setter
    def cloud_exadata_infrastructure_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_exadata_infrastructure_id", value)

    @property
    @pulumi.getter(name="cloudVmClusterId")
    def cloud_vm_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the cloud VM cluster.
        """
        return pulumi.get(self, "cloud_vm_cluster_id")

    @cloud_vm_cluster_id.setter
    def cloud_vm_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_vm_cluster_id", value)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[str]]:
        """
        The DB system [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm).
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_system_id", value)


@pulumi.input_type
class DatabaseMigrationConnectionAdminCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: (Updatable) Admin password
        :param pulumi.Input[str] username: (Updatable) Admin username
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DatabaseMigrationConnectionConnectDescriptorArgs:
    def __init__(__self__, *,
                 connect_string: Optional[pulumi.Input[str]] = None,
                 database_service_name: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] connect_string: (Updatable) Connect String. Required if no host, port nor databaseServiceName were specified. If a Private Endpoint was specified in the Connection, the host entry should be a valid IP address. Supported formats: Easy connect: <host>:<port>/<db_service_name> Long format: (description= (address=(port=<port>)(host=<host>))(connect_data=(service_name=<db_service_name>)))
        :param pulumi.Input[str] database_service_name: (Updatable) Database service name. Required if no connectString was specified.
        :param pulumi.Input[str] host: (Updatable) Name of the host the sshkey is valid for.
        :param pulumi.Input[int] port: (Updatable) Port of the connect descriptor. Required if no connectString was specified.
        """
        if connect_string is not None:
            pulumi.set(__self__, "connect_string", connect_string)
        if database_service_name is not None:
            pulumi.set(__self__, "database_service_name", database_service_name)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="connectString")
    def connect_string(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Connect String. Required if no host, port nor databaseServiceName were specified. If a Private Endpoint was specified in the Connection, the host entry should be a valid IP address. Supported formats: Easy connect: <host>:<port>/<db_service_name> Long format: (description= (address=(port=<port>)(host=<host>))(connect_data=(service_name=<db_service_name>)))
        """
        return pulumi.get(self, "connect_string")

    @connect_string.setter
    def connect_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_string", value)

    @property
    @pulumi.getter(name="databaseServiceName")
    def database_service_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Database service name. Required if no connectString was specified.
        """
        return pulumi.get(self, "database_service_name")

    @database_service_name.setter
    def database_service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_service_name", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the host the sshkey is valid for.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Port of the connect descriptor. Required if no connectString was specified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class DatabaseMigrationConnectionPrivateEndpointArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 vcn_id: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) OCID of the compartment where the secret containing the credentials will be created.
        :param pulumi.Input[str] subnet_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the customer's subnet where the private endpoint VNIC will reside.  Required if the id was not specified.
        :param pulumi.Input[str] vcn_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VCN where the Private Endpoint will be bound to. Required if the id was not specified.
        :param pulumi.Input[str] id: [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a previously created Private Endpoint.
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vcn_id", vcn_id)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) OCID of the compartment where the secret containing the credentials will be created.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the customer's subnet where the private endpoint VNIC will reside.  Required if the id was not specified.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vcnId")
    def vcn_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the VCN where the Private Endpoint will be bound to. Required if the id was not specified.
        """
        return pulumi.get(self, "vcn_id")

    @vcn_id.setter
    def vcn_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vcn_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a previously created Private Endpoint.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class DatabaseMigrationConnectionSshDetailsArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 sshkey: pulumi.Input[str],
                 user: pulumi.Input[str],
                 sudo_location: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: (Updatable) Name of the host the sshkey is valid for.
        :param pulumi.Input[str] sshkey: (Updatable) Private ssh key string.
        :param pulumi.Input[str] user: (Updatable) SSH user
        :param pulumi.Input[str] sudo_location: (Updatable) Sudo location
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "sshkey", sshkey)
        pulumi.set(__self__, "user", user)
        if sudo_location is not None:
            pulumi.set(__self__, "sudo_location", sudo_location)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the host the sshkey is valid for.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def sshkey(self) -> pulumi.Input[str]:
        """
        (Updatable) Private ssh key string.
        """
        return pulumi.get(self, "sshkey")

    @sshkey.setter
    def sshkey(self, value: pulumi.Input[str]):
        pulumi.set(self, "sshkey", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        (Updatable) SSH user
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="sudoLocation")
    def sudo_location(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Sudo location
        """
        return pulumi.get(self, "sudo_location")

    @sudo_location.setter
    def sudo_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sudo_location", value)


@pulumi.input_type
class DatabaseMigrationConnectionVaultDetailsArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 key_id: pulumi.Input[str],
                 vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) OCID of the compartment where the secret containing the credentials will be created.
        :param pulumi.Input[str] key_id: (Updatable) OCID of the vault encryption key
        :param pulumi.Input[str] vault_id: (Updatable) OCID of the vault
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) OCID of the compartment where the secret containing the credentials will be created.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        """
        (Updatable) OCID of the vault encryption key
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> pulumi.Input[str]:
        """
        (Updatable) OCID of the vault
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class DatabaseMigrationJobProgressArgs:
    def __init__(__self__, *,
                 current_phase: Optional[pulumi.Input[str]] = None,
                 current_status: Optional[pulumi.Input[str]] = None,
                 phases: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationJobProgressPhaseArgs']]]] = None):
        """
        :param pulumi.Input[str] current_phase: Current phase of the job.
        :param pulumi.Input[str] current_status: Current status of the job.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationJobProgressPhaseArgs']]] phases: List of phase status for the job.
        """
        if current_phase is not None:
            pulumi.set(__self__, "current_phase", current_phase)
        if current_status is not None:
            pulumi.set(__self__, "current_status", current_status)
        if phases is not None:
            pulumi.set(__self__, "phases", phases)

    @property
    @pulumi.getter(name="currentPhase")
    def current_phase(self) -> Optional[pulumi.Input[str]]:
        """
        Current phase of the job.
        """
        return pulumi.get(self, "current_phase")

    @current_phase.setter
    def current_phase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_phase", value)

    @property
    @pulumi.getter(name="currentStatus")
    def current_status(self) -> Optional[pulumi.Input[str]]:
        """
        Current status of the job.
        """
        return pulumi.get(self, "current_status")

    @current_status.setter
    def current_status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_status", value)

    @property
    @pulumi.getter
    def phases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationJobProgressPhaseArgs']]]]:
        """
        List of phase status for the job.
        """
        return pulumi.get(self, "phases")

    @phases.setter
    def phases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationJobProgressPhaseArgs']]]]):
        pulumi.set(self, "phases", value)


@pulumi.input_type
class DatabaseMigrationJobProgressPhaseArgs:
    def __init__(__self__, *,
                 duration_in_ms: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 progress: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] duration_in_ms: Duration of the phase in milliseconds
        :param pulumi.Input[str] name: Phase name
        :param pulumi.Input[int] progress: Percent progress of job phase.
        :param pulumi.Input[str] status: Phase status
        """
        if duration_in_ms is not None:
            pulumi.set(__self__, "duration_in_ms", duration_in_ms)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if progress is not None:
            pulumi.set(__self__, "progress", progress)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="durationInMs")
    def duration_in_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Duration of the phase in milliseconds
        """
        return pulumi.get(self, "duration_in_ms")

    @duration_in_ms.setter
    def duration_in_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration_in_ms", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Phase name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def progress(self) -> Optional[pulumi.Input[int]]:
        """
        Percent progress of job phase.
        """
        return pulumi.get(self, "progress")

    @progress.setter
    def progress(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "progress", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Phase status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class DatabaseMigrationJobUnsupportedObjectArgs:
    def __init__(__self__, *,
                 object: Optional[pulumi.Input[str]] = None,
                 owner: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] object: Name of the object (regular expression is allowed)
        :param pulumi.Input[str] owner: Owner of the object (regular expression is allowed)
        :param pulumi.Input[str] type: Type of unsupported object
        """
        if object is not None:
            pulumi.set(__self__, "object", object)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the object (regular expression is allowed)
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of the object (regular expression is allowed)
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of unsupported object
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatabaseMigrationMigrationDataTransferMediumDetailsArgs:
    def __init__(__self__, *,
                 database_link_details: Optional[pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsDatabaseLinkDetailsArgs']] = None,
                 object_storage_details: Optional[pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsObjectStorageDetailsArgs']] = None):
        """
        :param pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsDatabaseLinkDetailsArgs'] database_link_details: (Updatable) Optional details for creating a network database link from Oracle Cloud Infrastructure database to on-premise database.
        :param pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsObjectStorageDetailsArgs'] object_storage_details: (Updatable) In lieu of a network database link, Oracle Cloud Infrastructure Object Storage bucket will be used to store Datapump dump files for the migration.
        """
        if database_link_details is not None:
            pulumi.set(__self__, "database_link_details", database_link_details)
        if object_storage_details is not None:
            pulumi.set(__self__, "object_storage_details", object_storage_details)

    @property
    @pulumi.getter(name="databaseLinkDetails")
    def database_link_details(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsDatabaseLinkDetailsArgs']]:
        """
        (Updatable) Optional details for creating a network database link from Oracle Cloud Infrastructure database to on-premise database.
        """
        return pulumi.get(self, "database_link_details")

    @database_link_details.setter
    def database_link_details(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsDatabaseLinkDetailsArgs']]):
        pulumi.set(self, "database_link_details", value)

    @property
    @pulumi.getter(name="objectStorageDetails")
    def object_storage_details(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsObjectStorageDetailsArgs']]:
        """
        (Updatable) In lieu of a network database link, Oracle Cloud Infrastructure Object Storage bucket will be used to store Datapump dump files for the migration.
        """
        return pulumi.get(self, "object_storage_details")

    @object_storage_details.setter
    def object_storage_details(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationDataTransferMediumDetailsObjectStorageDetailsArgs']]):
        pulumi.set(self, "object_storage_details", value)


@pulumi.input_type
class DatabaseMigrationMigrationDataTransferMediumDetailsDatabaseLinkDetailsArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of directory object in database
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of directory object in database
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DatabaseMigrationMigrationDataTransferMediumDetailsObjectStorageDetailsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 namespace: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: (Updatable) Bucket name.
        :param pulumi.Input[str] namespace: (Updatable) Namespace name of the object store bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        (Updatable) Bucket name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        (Updatable) Namespace name of the object store bucket.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class DatabaseMigrationMigrationDatapumpSettingsArgs:
    def __init__(__self__, *,
                 data_pump_parameters: Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsDataPumpParametersArgs']] = None,
                 export_directory_object: Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsExportDirectoryObjectArgs']] = None,
                 import_directory_object: Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsImportDirectoryObjectArgs']] = None,
                 job_mode: Optional[pulumi.Input[str]] = None,
                 metadata_remaps: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsMetadataRemapArgs']]]] = None):
        """
        :param pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsDataPumpParametersArgs'] data_pump_parameters: (Updatable) Optional parameters for Datapump Export and Import. Refer to https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/ODMS_DATAPUMP.html#GUID-62324358-2F26-4A94-B69F-1075D53FA96D__BABDECJE
        :param pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsExportDirectoryObjectArgs'] export_directory_object: (Updatable) Directory object details, used to define either import or export directory objects in Data Pump Settings. Import directory is required for Non-Autonomous target connections. If specified for an autonomous target, it will show an error. Export directory will error if there are database link details specified.
        :param pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsImportDirectoryObjectArgs'] import_directory_object: (Updatable) Directory object details, used to define either import or export directory objects in Data Pump Settings. Import directory is required for Non-Autonomous target connections. If specified for an autonomous target, it will show an error. Export directory will error if there are database link details specified.
        :param pulumi.Input[str] job_mode: (Updatable) DataPump job mode. Refer to docs.oracle.com/en/database/oracle/oracle-database/19/arpls/ODMS_DATAPUMP.html#GUID-92C2CB46-8BC9-414D-B62E-79CD788C1E62__BABBDEHD
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsMetadataRemapArgs']]] metadata_remaps: (Updatable) Defines remapping to be applied to objects as they are processed. Refer to https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/ODMS_DATAPUMP.html#GUID-0FC32790-91E6-4781-87A3-229DE024CB3D.
        """
        if data_pump_parameters is not None:
            pulumi.set(__self__, "data_pump_parameters", data_pump_parameters)
        if export_directory_object is not None:
            pulumi.set(__self__, "export_directory_object", export_directory_object)
        if import_directory_object is not None:
            pulumi.set(__self__, "import_directory_object", import_directory_object)
        if job_mode is not None:
            pulumi.set(__self__, "job_mode", job_mode)
        if metadata_remaps is not None:
            pulumi.set(__self__, "metadata_remaps", metadata_remaps)

    @property
    @pulumi.getter(name="dataPumpParameters")
    def data_pump_parameters(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsDataPumpParametersArgs']]:
        """
        (Updatable) Optional parameters for Datapump Export and Import. Refer to https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/ODMS_DATAPUMP.html#GUID-62324358-2F26-4A94-B69F-1075D53FA96D__BABDECJE
        """
        return pulumi.get(self, "data_pump_parameters")

    @data_pump_parameters.setter
    def data_pump_parameters(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsDataPumpParametersArgs']]):
        pulumi.set(self, "data_pump_parameters", value)

    @property
    @pulumi.getter(name="exportDirectoryObject")
    def export_directory_object(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsExportDirectoryObjectArgs']]:
        """
        (Updatable) Directory object details, used to define either import or export directory objects in Data Pump Settings. Import directory is required for Non-Autonomous target connections. If specified for an autonomous target, it will show an error. Export directory will error if there are database link details specified.
        """
        return pulumi.get(self, "export_directory_object")

    @export_directory_object.setter
    def export_directory_object(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsExportDirectoryObjectArgs']]):
        pulumi.set(self, "export_directory_object", value)

    @property
    @pulumi.getter(name="importDirectoryObject")
    def import_directory_object(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsImportDirectoryObjectArgs']]:
        """
        (Updatable) Directory object details, used to define either import or export directory objects in Data Pump Settings. Import directory is required for Non-Autonomous target connections. If specified for an autonomous target, it will show an error. Export directory will error if there are database link details specified.
        """
        return pulumi.get(self, "import_directory_object")

    @import_directory_object.setter
    def import_directory_object(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsImportDirectoryObjectArgs']]):
        pulumi.set(self, "import_directory_object", value)

    @property
    @pulumi.getter(name="jobMode")
    def job_mode(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) DataPump job mode. Refer to docs.oracle.com/en/database/oracle/oracle-database/19/arpls/ODMS_DATAPUMP.html#GUID-92C2CB46-8BC9-414D-B62E-79CD788C1E62__BABBDEHD
        """
        return pulumi.get(self, "job_mode")

    @job_mode.setter
    def job_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "job_mode", value)

    @property
    @pulumi.getter(name="metadataRemaps")
    def metadata_remaps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsMetadataRemapArgs']]]]:
        """
        (Updatable) Defines remapping to be applied to objects as they are processed. Refer to https://docs.oracle.com/en/database/oracle/oracle-database/19/arpls/ODMS_DATAPUMP.html#GUID-0FC32790-91E6-4781-87A3-229DE024CB3D.
        """
        return pulumi.get(self, "metadata_remaps")

    @metadata_remaps.setter
    def metadata_remaps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseMigrationMigrationDatapumpSettingsMetadataRemapArgs']]]]):
        pulumi.set(self, "metadata_remaps", value)


@pulumi.input_type
class DatabaseMigrationMigrationDatapumpSettingsDataPumpParametersArgs:
    def __init__(__self__, *,
                 estimate: Optional[pulumi.Input[str]] = None,
                 exclude_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 export_parallelism_degree: Optional[pulumi.Input[int]] = None,
                 import_parallelism_degree: Optional[pulumi.Input[int]] = None,
                 is_cluster: Optional[pulumi.Input[bool]] = None,
                 table_exists_action: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] estimate: (Updatable) Estimate size of dumps that will be generated.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_parameters: (Updatable) Exclude paratemers for export and import.
        :param pulumi.Input[int] export_parallelism_degree: (Updatable) Maximum number of worker processes that can be used for a Datapump Export job.
        :param pulumi.Input[int] import_parallelism_degree: (Updatable) Maximum number of worker processes that can be used for a Datapump Import job. For an Autonomous Database, ODMS will automatically query its CPU core count and set this property.
        :param pulumi.Input[bool] is_cluster: (Updatable) False to force datapump worker process to run on one instance.
        :param pulumi.Input[str] table_exists_action: (Updatable) IMPORT: Specifies the action to be performed when data is loaded into a preexisting table.
        """
        if estimate is not None:
            pulumi.set(__self__, "estimate", estimate)
        if exclude_parameters is not None:
            pulumi.set(__self__, "exclude_parameters", exclude_parameters)
        if export_parallelism_degree is not None:
            pulumi.set(__self__, "export_parallelism_degree", export_parallelism_degree)
        if import_parallelism_degree is not None:
            pulumi.set(__self__, "import_parallelism_degree", import_parallelism_degree)
        if is_cluster is not None:
            pulumi.set(__self__, "is_cluster", is_cluster)
        if table_exists_action is not None:
            pulumi.set(__self__, "table_exists_action", table_exists_action)

    @property
    @pulumi.getter
    def estimate(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Estimate size of dumps that will be generated.
        """
        return pulumi.get(self, "estimate")

    @estimate.setter
    def estimate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "estimate", value)

    @property
    @pulumi.getter(name="excludeParameters")
    def exclude_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Exclude paratemers for export and import.
        """
        return pulumi.get(self, "exclude_parameters")

    @exclude_parameters.setter
    def exclude_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_parameters", value)

    @property
    @pulumi.getter(name="exportParallelismDegree")
    def export_parallelism_degree(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum number of worker processes that can be used for a Datapump Export job.
        """
        return pulumi.get(self, "export_parallelism_degree")

    @export_parallelism_degree.setter
    def export_parallelism_degree(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "export_parallelism_degree", value)

    @property
    @pulumi.getter(name="importParallelismDegree")
    def import_parallelism_degree(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Maximum number of worker processes that can be used for a Datapump Import job. For an Autonomous Database, ODMS will automatically query its CPU core count and set this property.
        """
        return pulumi.get(self, "import_parallelism_degree")

    @import_parallelism_degree.setter
    def import_parallelism_degree(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "import_parallelism_degree", value)

    @property
    @pulumi.getter(name="isCluster")
    def is_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) False to force datapump worker process to run on one instance.
        """
        return pulumi.get(self, "is_cluster")

    @is_cluster.setter
    def is_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cluster", value)

    @property
    @pulumi.getter(name="tableExistsAction")
    def table_exists_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) IMPORT: Specifies the action to be performed when data is loaded into a preexisting table.
        """
        return pulumi.get(self, "table_exists_action")

    @table_exists_action.setter
    def table_exists_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_exists_action", value)


@pulumi.input_type
class DatabaseMigrationMigrationDatapumpSettingsExportDirectoryObjectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of directory object in database
        :param pulumi.Input[str] path: (Updatable) Absolute path of directory on database server
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of directory object in database
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        (Updatable) Absolute path of directory on database server
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class DatabaseMigrationMigrationDatapumpSettingsImportDirectoryObjectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) Name of directory object in database
        :param pulumi.Input[str] path: (Updatable) Absolute path of directory on database server
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of directory object in database
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        (Updatable) Absolute path of directory on database server
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class DatabaseMigrationMigrationDatapumpSettingsMetadataRemapArgs:
    def __init__(__self__, *,
                 new_value: pulumi.Input[str],
                 old_value: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] new_value: (Updatable) Specifies the new value that oldValue should be translated into.
        :param pulumi.Input[str] old_value: (Updatable) Specifies the value which needs to be reset.
        :param pulumi.Input[str] type: (Updatable) Migration type.
        """
        pulumi.set(__self__, "new_value", new_value)
        pulumi.set(__self__, "old_value", old_value)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="newValue")
    def new_value(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies the new value that oldValue should be translated into.
        """
        return pulumi.get(self, "new_value")

    @new_value.setter
    def new_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "new_value", value)

    @property
    @pulumi.getter(name="oldValue")
    def old_value(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies the value which needs to be reset.
        """
        return pulumi.get(self, "old_value")

    @old_value.setter
    def old_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "old_value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) Migration type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class DatabaseMigrationMigrationExcludeObjectArgs:
    def __init__(__self__, *,
                 object: pulumi.Input[str],
                 owner: pulumi.Input[str]):
        """
        :param pulumi.Input[str] object: (Updatable) Name of the object (regular expression is allowed)
        :param pulumi.Input[str] owner: (Updatable) Owner of the object (regular expression is allowed)
        """
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "owner", owner)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the object (regular expression is allowed)
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def owner(self) -> pulumi.Input[str]:
        """
        (Updatable) Owner of the object (regular expression is allowed)
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[str]):
        pulumi.set(self, "owner", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsArgs:
    def __init__(__self__, *,
                 hub: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubArgs'],
                 settings: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsArgs']] = None):
        """
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubArgs'] hub: (Updatable) Details about Oracle GoldenGate Microservices. Required for online logical migration.
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsArgs'] settings: (Updatable) Optional settings for Oracle GoldenGate processes
        """
        pulumi.set(__self__, "hub", hub)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def hub(self) -> pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubArgs']:
        """
        (Updatable) Details about Oracle GoldenGate Microservices. Required for online logical migration.
        """
        return pulumi.get(self, "hub")

    @hub.setter
    def hub(self, value: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubArgs']):
        pulumi.set(self, "hub", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsArgs']]:
        """
        (Updatable) Optional settings for Oracle GoldenGate processes
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsArgs']]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsHubArgs:
    def __init__(__self__, *,
                 rest_admin_credentials: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubRestAdminCredentialsArgs'],
                 source_db_admin_credentials: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceDbAdminCredentialsArgs'],
                 source_microservices_deployment_name: pulumi.Input[str],
                 target_db_admin_credentials: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubTargetDbAdminCredentialsArgs'],
                 target_microservices_deployment_name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 compute_id: Optional[pulumi.Input[str]] = None,
                 source_container_db_admin_credentials: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceContainerDbAdminCredentialsArgs']] = None):
        """
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubRestAdminCredentialsArgs'] rest_admin_credentials: (Updatable) Database Admin Credentials details.
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceDbAdminCredentialsArgs'] source_db_admin_credentials: (Updatable) Database Admin Credentials details.
        :param pulumi.Input[str] source_microservices_deployment_name: (Updatable) Name of Microservices deployment to operate on source DB
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubTargetDbAdminCredentialsArgs'] target_db_admin_credentials: (Updatable) Database Admin Credentials details.
        :param pulumi.Input[str] target_microservices_deployment_name: (Updatable) Name of Microservices deployment to operate on target DB
        :param pulumi.Input[str] url: (Updatable) Oracle GoldenGate hub's REST endpoint. Refer to https://docs.oracle.com/en/middleware/goldengate/core/19.1/securing/network.html#GUID-A709DA55-111D-455E-8942-C9BDD1E38CAA
        :param pulumi.Input[str] compute_id: (Updatable) OCID of Golden Gate compute instance.
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceContainerDbAdminCredentialsArgs'] source_container_db_admin_credentials: (Updatable) Database Admin Credentials details.
        """
        pulumi.set(__self__, "rest_admin_credentials", rest_admin_credentials)
        pulumi.set(__self__, "source_db_admin_credentials", source_db_admin_credentials)
        pulumi.set(__self__, "source_microservices_deployment_name", source_microservices_deployment_name)
        pulumi.set(__self__, "target_db_admin_credentials", target_db_admin_credentials)
        pulumi.set(__self__, "target_microservices_deployment_name", target_microservices_deployment_name)
        pulumi.set(__self__, "url", url)
        if compute_id is not None:
            pulumi.set(__self__, "compute_id", compute_id)
        if source_container_db_admin_credentials is not None:
            pulumi.set(__self__, "source_container_db_admin_credentials", source_container_db_admin_credentials)

    @property
    @pulumi.getter(name="restAdminCredentials")
    def rest_admin_credentials(self) -> pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubRestAdminCredentialsArgs']:
        """
        (Updatable) Database Admin Credentials details.
        """
        return pulumi.get(self, "rest_admin_credentials")

    @rest_admin_credentials.setter
    def rest_admin_credentials(self, value: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubRestAdminCredentialsArgs']):
        pulumi.set(self, "rest_admin_credentials", value)

    @property
    @pulumi.getter(name="sourceDbAdminCredentials")
    def source_db_admin_credentials(self) -> pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceDbAdminCredentialsArgs']:
        """
        (Updatable) Database Admin Credentials details.
        """
        return pulumi.get(self, "source_db_admin_credentials")

    @source_db_admin_credentials.setter
    def source_db_admin_credentials(self, value: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceDbAdminCredentialsArgs']):
        pulumi.set(self, "source_db_admin_credentials", value)

    @property
    @pulumi.getter(name="sourceMicroservicesDeploymentName")
    def source_microservices_deployment_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of Microservices deployment to operate on source DB
        """
        return pulumi.get(self, "source_microservices_deployment_name")

    @source_microservices_deployment_name.setter
    def source_microservices_deployment_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_microservices_deployment_name", value)

    @property
    @pulumi.getter(name="targetDbAdminCredentials")
    def target_db_admin_credentials(self) -> pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubTargetDbAdminCredentialsArgs']:
        """
        (Updatable) Database Admin Credentials details.
        """
        return pulumi.get(self, "target_db_admin_credentials")

    @target_db_admin_credentials.setter
    def target_db_admin_credentials(self, value: pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubTargetDbAdminCredentialsArgs']):
        pulumi.set(self, "target_db_admin_credentials", value)

    @property
    @pulumi.getter(name="targetMicroservicesDeploymentName")
    def target_microservices_deployment_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of Microservices deployment to operate on target DB
        """
        return pulumi.get(self, "target_microservices_deployment_name")

    @target_microservices_deployment_name.setter
    def target_microservices_deployment_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_microservices_deployment_name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        (Updatable) Oracle GoldenGate hub's REST endpoint. Refer to https://docs.oracle.com/en/middleware/goldengate/core/19.1/securing/network.html#GUID-A709DA55-111D-455E-8942-C9BDD1E38CAA
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="computeId")
    def compute_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) OCID of Golden Gate compute instance.
        """
        return pulumi.get(self, "compute_id")

    @compute_id.setter
    def compute_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_id", value)

    @property
    @pulumi.getter(name="sourceContainerDbAdminCredentials")
    def source_container_db_admin_credentials(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceContainerDbAdminCredentialsArgs']]:
        """
        (Updatable) Database Admin Credentials details.
        """
        return pulumi.get(self, "source_container_db_admin_credentials")

    @source_container_db_admin_credentials.setter
    def source_container_db_admin_credentials(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsHubSourceContainerDbAdminCredentialsArgs']]):
        pulumi.set(self, "source_container_db_admin_credentials", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsHubRestAdminCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: (Updatable) Admin password
        :param pulumi.Input[str] username: (Updatable) Admin username
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsHubSourceContainerDbAdminCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: (Updatable) Admin password
        :param pulumi.Input[str] username: (Updatable) Admin username
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsHubSourceDbAdminCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: (Updatable) Admin password
        :param pulumi.Input[str] username: (Updatable) Admin username
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsHubTargetDbAdminCredentialsArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: (Updatable) Admin password
        :param pulumi.Input[str] username: (Updatable) Admin username
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        (Updatable) Admin username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsSettingsArgs:
    def __init__(__self__, *,
                 acceptable_lag: Optional[pulumi.Input[int]] = None,
                 extract: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsExtractArgs']] = None,
                 replicat: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsReplicatArgs']] = None):
        """
        :param pulumi.Input[int] acceptable_lag: (Updatable) ODMS will monitor GoldenGate end-to-end latency until the lag time is lower than the specified value in seconds.
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsExtractArgs'] extract: (Updatable) Parameters for Extract processes.
        :param pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsReplicatArgs'] replicat: (Updatable) Parameters for Replicat processes.
        """
        if acceptable_lag is not None:
            pulumi.set(__self__, "acceptable_lag", acceptable_lag)
        if extract is not None:
            pulumi.set(__self__, "extract", extract)
        if replicat is not None:
            pulumi.set(__self__, "replicat", replicat)

    @property
    @pulumi.getter(name="acceptableLag")
    def acceptable_lag(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) ODMS will monitor GoldenGate end-to-end latency until the lag time is lower than the specified value in seconds.
        """
        return pulumi.get(self, "acceptable_lag")

    @acceptable_lag.setter
    def acceptable_lag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "acceptable_lag", value)

    @property
    @pulumi.getter
    def extract(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsExtractArgs']]:
        """
        (Updatable) Parameters for Extract processes.
        """
        return pulumi.get(self, "extract")

    @extract.setter
    def extract(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsExtractArgs']]):
        pulumi.set(self, "extract", value)

    @property
    @pulumi.getter
    def replicat(self) -> Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsReplicatArgs']]:
        """
        (Updatable) Parameters for Replicat processes.
        """
        return pulumi.get(self, "replicat")

    @replicat.setter
    def replicat(self, value: Optional[pulumi.Input['DatabaseMigrationMigrationGoldenGateDetailsSettingsReplicatArgs']]):
        pulumi.set(self, "replicat", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsSettingsExtractArgs:
    def __init__(__self__, *,
                 long_trans_duration: Optional[pulumi.Input[int]] = None,
                 performance_profile: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] long_trans_duration: (Updatable) Length of time (in seconds) that a transaction can be open before Extract generates a warning message that the transaction is long-running. If not specified, Extract will not generate a warning on long-running transactions.
        :param pulumi.Input[str] performance_profile: (Updatable) Extract performance.
        """
        if long_trans_duration is not None:
            pulumi.set(__self__, "long_trans_duration", long_trans_duration)
        if performance_profile is not None:
            pulumi.set(__self__, "performance_profile", performance_profile)

    @property
    @pulumi.getter(name="longTransDuration")
    def long_trans_duration(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Length of time (in seconds) that a transaction can be open before Extract generates a warning message that the transaction is long-running. If not specified, Extract will not generate a warning on long-running transactions.
        """
        return pulumi.get(self, "long_trans_duration")

    @long_trans_duration.setter
    def long_trans_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "long_trans_duration", value)

    @property
    @pulumi.getter(name="performanceProfile")
    def performance_profile(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Extract performance.
        """
        return pulumi.get(self, "performance_profile")

    @performance_profile.setter
    def performance_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "performance_profile", value)


@pulumi.input_type
class DatabaseMigrationMigrationGoldenGateDetailsSettingsReplicatArgs:
    def __init__(__self__, *,
                 map_parallelism: Optional[pulumi.Input[int]] = None,
                 max_apply_parallelism: Optional[pulumi.Input[int]] = None,
                 min_apply_parallelism: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] map_parallelism: (Updatable) Number of threads used to read trail files (valid for Parallel Replicat)
        :param pulumi.Input[int] max_apply_parallelism: (Updatable) Defines the range in which the Replicat automatically adjusts its apply parallelism (valid for Parallel Replicat)
        :param pulumi.Input[int] min_apply_parallelism: (Updatable) Defines the range in which the Replicat automatically adjusts its apply parallelism (valid for Parallel Replicat)
        """
        if map_parallelism is not None:
            pulumi.set(__self__, "map_parallelism", map_parallelism)
        if max_apply_parallelism is not None:
            pulumi.set(__self__, "max_apply_parallelism", max_apply_parallelism)
        if min_apply_parallelism is not None:
            pulumi.set(__self__, "min_apply_parallelism", min_apply_parallelism)

    @property
    @pulumi.getter(name="mapParallelism")
    def map_parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of threads used to read trail files (valid for Parallel Replicat)
        """
        return pulumi.get(self, "map_parallelism")

    @map_parallelism.setter
    def map_parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "map_parallelism", value)

    @property
    @pulumi.getter(name="maxApplyParallelism")
    def max_apply_parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines the range in which the Replicat automatically adjusts its apply parallelism (valid for Parallel Replicat)
        """
        return pulumi.get(self, "max_apply_parallelism")

    @max_apply_parallelism.setter
    def max_apply_parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_apply_parallelism", value)

    @property
    @pulumi.getter(name="minApplyParallelism")
    def min_apply_parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Defines the range in which the Replicat automatically adjusts its apply parallelism (valid for Parallel Replicat)
        """
        return pulumi.get(self, "min_apply_parallelism")

    @min_apply_parallelism.setter
    def min_apply_parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_apply_parallelism", value)


@pulumi.input_type
class DatabaseMigrationMigrationVaultDetailsArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 key_id: pulumi.Input[str],
                 vault_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) OCID of the compartment where the secret containing the credentials will be created.
        :param pulumi.Input[str] key_id: (Updatable) OCID of the vault encryption key
        :param pulumi.Input[str] vault_id: (Updatable) OCID of the vault
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "key_id", key_id)
        pulumi.set(__self__, "vault_id", vault_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        (Updatable) OCID of the compartment where the secret containing the credentials will be created.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[str]:
        """
        (Updatable) OCID of the vault encryption key
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter(name="vaultId")
    def vault_id(self) -> pulumi.Input[str]:
        """
        (Updatable) OCID of the vault
        """
        return pulumi.get(self, "vault_id")

    @vault_id.setter
    def vault_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vault_id", value)


@pulumi.input_type
class DatabasePluggableDatabaseConnectionStringsArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


@pulumi.input_type
class DatabasePluggableDatabasesLocalCloneConnectionStringsArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


@pulumi.input_type
class DatabasePluggableDatabasesRemoteCloneConnectionStringsArgs:
    def __init__(__self__, *,
                 all_connection_strings: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 pdb_default: Optional[pulumi.Input[str]] = None,
                 pdb_ip_default: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] all_connection_strings: All connection strings to use to connect to the pluggable database.
        :param pulumi.Input[str] pdb_default: A host name-based PDB connection string.
        :param pulumi.Input[str] pdb_ip_default: An IP-based PDB connection string.
        """
        if all_connection_strings is not None:
            pulumi.set(__self__, "all_connection_strings", all_connection_strings)
        if pdb_default is not None:
            pulumi.set(__self__, "pdb_default", pdb_default)
        if pdb_ip_default is not None:
            pulumi.set(__self__, "pdb_ip_default", pdb_ip_default)

    @property
    @pulumi.getter(name="allConnectionStrings")
    def all_connection_strings(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        All connection strings to use to connect to the pluggable database.
        """
        return pulumi.get(self, "all_connection_strings")

    @all_connection_strings.setter
    def all_connection_strings(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "all_connection_strings", value)

    @property
    @pulumi.getter(name="pdbDefault")
    def pdb_default(self) -> Optional[pulumi.Input[str]]:
        """
        A host name-based PDB connection string.
        """
        return pulumi.get(self, "pdb_default")

    @pdb_default.setter
    def pdb_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_default", value)

    @property
    @pulumi.getter(name="pdbIpDefault")
    def pdb_ip_default(self) -> Optional[pulumi.Input[str]]:
        """
        An IP-based PDB connection string.
        """
        return pulumi.get(self, "pdb_ip_default")

    @pdb_ip_default.setter
    def pdb_ip_default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pdb_ip_default", value)


@pulumi.input_type
class DatabaseVmClusterNetworkScanArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 port: pulumi.Input[int]):
        """
        :param pulumi.Input[str] hostname: (Updatable) The node host name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        :param pulumi.Input[int] port: (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of SCAN IP addresses. Three addresses should be provided.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        (Updatable) The SCAN TCPIP port. Default is 1521.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class DatabaseVmClusterNetworkVmNetworkArgs:
    def __init__(__self__, *,
                 domain_name: pulumi.Input[str],
                 gateway: pulumi.Input[str],
                 netmask: pulumi.Input[str],
                 network_type: pulumi.Input[str],
                 nodes: pulumi.Input[Sequence[pulumi.Input['DatabaseVmClusterNetworkVmNetworkNodeArgs']]],
                 vlan_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] domain_name: (Updatable) The network domain name.
        :param pulumi.Input[str] gateway: (Updatable) The network gateway.
        :param pulumi.Input[str] netmask: (Updatable) The network netmask.
        :param pulumi.Input[str] network_type: (Updatable) The network type.
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseVmClusterNetworkVmNetworkNodeArgs']]] nodes: (Updatable) The list of node details.
        :param pulumi.Input[str] vlan_id: (Updatable) The network VLAN ID.
        """
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The network domain name.
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        (Updatable) The network gateway.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> pulumi.Input[str]:
        """
        (Updatable) The network netmask.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: pulumi.Input[str]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The network type.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[Sequence[pulumi.Input['DatabaseVmClusterNetworkVmNetworkNodeArgs']]]:
        """
        (Updatable) The list of node details.
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[Sequence[pulumi.Input['DatabaseVmClusterNetworkVmNetworkNodeArgs']]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class DatabaseVmClusterNetworkVmNetworkNodeArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 ip: pulumi.Input[str],
                 vip: Optional[pulumi.Input[str]] = None,
                 vip_hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) The node host name.
        :param pulumi.Input[str] ip: (Updatable) The node IP address.
        :param pulumi.Input[str] vip: (Updatable) The node virtual IP (VIP) address.
        :param pulumi.Input[str] vip_hostname: (Updatable) The node virtual IP (VIP) host name.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "ip", ip)
        if vip is not None:
            pulumi.set(__self__, "vip", vip)
        if vip_hostname is not None:
            pulumi.set(__self__, "vip_hostname", vip_hostname)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The node host name.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        (Updatable) The node IP address.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def vip(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The node virtual IP (VIP) address.
        """
        return pulumi.get(self, "vip")

    @vip.setter
    def vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vip", value)

    @property
    @pulumi.getter(name="vipHostname")
    def vip_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The node virtual IP (VIP) host name.
        """
        return pulumi.get(self, "vip_hostname")

    @vip_hostname.setter
    def vip_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vip_hostname", value)


@pulumi.input_type
class DataflowApplicationParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        :param pulumi.Input[str] value: (Updatable) The value of the parameter. It must be a string of 0 or more characters of any kind. Examples: "" (empty string), "10", "mydata.xml", "${x}"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) The value of the parameter. It must be a string of 0 or more characters of any kind. Examples: "" (empty string), "10", "mydata.xml", "${x}"
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DataflowInvokeRunParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        :param pulumi.Input[str] value: The value of the parameter. It must be a string of 0 or more characters of any kind. Examples: "" (empty string), "10", "mydata.xml", "${x}"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the parameter. It must be a string of 0 or more characters of any kind. Examples: "" (empty string), "10", "mydata.xml", "${x}"
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DatascienceModelCustomMetadataListArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category: (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,other".
        :param pulumi.Input[str] description: (Updatable) A short description of the model.
        :param pulumi.Input[str] key: (Updatable) key of the model Metadata. This can be custom key(user defined) as well as Oracle Cloud Infrastructure defined. Example of Oracle defined keys - useCaseType, libraryName, libraryVersion, estimatorClass, hyperParameters. Example of user defined keys - BaseModel
        :param pulumi.Input[str] value: (Updatable) Value of model metadata
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,other".
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A short description of the model.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) key of the model Metadata. This can be custom key(user defined) as well as Oracle Cloud Infrastructure defined. Example of Oracle defined keys - useCaseType, libraryName, libraryVersion, estimatorClass, hyperParameters. Example of user defined keys - BaseModel
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of model metadata
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DatascienceModelDefinedMetadataListArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category: (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,other".
        :param pulumi.Input[str] description: (Updatable) A short description of the model.
        :param pulumi.Input[str] key: (Updatable) key of the model Metadata. This can be custom key(user defined) as well as Oracle Cloud Infrastructure defined. Example of Oracle defined keys - useCaseType, libraryName, libraryVersion, estimatorClass, hyperParameters. Example of user defined keys - BaseModel
        :param pulumi.Input[str] value: (Updatable) Value of model metadata
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Category of model metadata which should be null for defined metadata.For custom metadata is should be one of the following values "Performance,Training Profile,Training and Validation Datasets,Training Environment,other".
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A short description of the model.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) key of the model Metadata. This can be custom key(user defined) as well as Oracle Cloud Infrastructure defined. Example of Oracle defined keys - useCaseType, libraryName, libraryVersion, estimatorClass, hyperParameters. Example of user defined keys - BaseModel
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Value of model metadata
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DatascienceModelDeploymentCategoryLogDetailsArgs:
    def __init__(__self__, *,
                 access: Optional[pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsAccessArgs']] = None,
                 predict: Optional[pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsPredictArgs']] = None):
        """
        :param pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsAccessArgs'] access: (Updatable) The log details.
        :param pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsPredictArgs'] predict: (Updatable) The log details.
        """
        if access is not None:
            pulumi.set(__self__, "access", access)
        if predict is not None:
            pulumi.set(__self__, "predict", predict)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsAccessArgs']]:
        """
        (Updatable) The log details.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsAccessArgs']]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter
    def predict(self) -> Optional[pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsPredictArgs']]:
        """
        (Updatable) The log details.
        """
        return pulumi.get(self, "predict")

    @predict.setter
    def predict(self, value: Optional[pulumi.Input['DatascienceModelDeploymentCategoryLogDetailsPredictArgs']]):
        pulumi.set(self, "predict", value)


@pulumi.input_type
class DatascienceModelDeploymentCategoryLogDetailsAccessArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[str],
                 log_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        :param pulumi.Input[str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_id", log_id)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="logId")
    def log_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_id", value)


@pulumi.input_type
class DatascienceModelDeploymentCategoryLogDetailsPredictArgs:
    def __init__(__self__, *,
                 log_group_id: pulumi.Input[str],
                 log_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        :param pulumi.Input[str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        pulumi.set(__self__, "log_group_id", log_group_id)
        pulumi.set(__self__, "log_id", log_id)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log group to work with.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="logId")
    def log_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a log to work with.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_id", value)


@pulumi.input_type
class DatascienceModelDeploymentModelDeploymentConfigurationDetailsArgs:
    def __init__(__self__, *,
                 deployment_type: pulumi.Input[str],
                 model_configuration_details: pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs']):
        """
        :param pulumi.Input[str] deployment_type: (Updatable) The type of the model deployment.
        :param pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs'] model_configuration_details: (Updatable) The model configuration details.
        """
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "model_configuration_details", model_configuration_details)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of the model deployment.
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment_type", value)

    @property
    @pulumi.getter(name="modelConfigurationDetails")
    def model_configuration_details(self) -> pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs']:
        """
        (Updatable) The model configuration details.
        """
        return pulumi.get(self, "model_configuration_details")

    @model_configuration_details.setter
    def model_configuration_details(self, value: pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs']):
        pulumi.set(self, "model_configuration_details", value)


@pulumi.input_type
class DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsArgs:
    def __init__(__self__, *,
                 instance_configuration: pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs'],
                 model_id: pulumi.Input[str],
                 bandwidth_mbps: Optional[pulumi.Input[int]] = None,
                 scaling_policy: Optional[pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs']] = None):
        """
        :param pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs'] instance_configuration: (Updatable) The model deployment instance configuration
        :param pulumi.Input[str] model_id: (Updatable) The OCID of the model you want to deploy.
        :param pulumi.Input[int] bandwidth_mbps: (Updatable) The network bandwidth for the model.
        :param pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs'] scaling_policy: (Updatable) The scaling policy to apply to each model of the deployment.
        """
        pulumi.set(__self__, "instance_configuration", instance_configuration)
        pulumi.set(__self__, "model_id", model_id)
        if bandwidth_mbps is not None:
            pulumi.set(__self__, "bandwidth_mbps", bandwidth_mbps)
        if scaling_policy is not None:
            pulumi.set(__self__, "scaling_policy", scaling_policy)

    @property
    @pulumi.getter(name="instanceConfiguration")
    def instance_configuration(self) -> pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs']:
        """
        (Updatable) The model deployment instance configuration
        """
        return pulumi.get(self, "instance_configuration")

    @instance_configuration.setter
    def instance_configuration(self, value: pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs']):
        pulumi.set(self, "instance_configuration", value)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the model you want to deploy.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_id", value)

    @property
    @pulumi.getter(name="bandwidthMbps")
    def bandwidth_mbps(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The network bandwidth for the model.
        """
        return pulumi.get(self, "bandwidth_mbps")

    @bandwidth_mbps.setter
    def bandwidth_mbps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bandwidth_mbps", value)

    @property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> Optional[pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs']]:
        """
        (Updatable) The scaling policy to apply to each model of the deployment.
        """
        return pulumi.get(self, "scaling_policy")

    @scaling_policy.setter
    def scaling_policy(self, value: Optional[pulumi.Input['DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs']]):
        pulumi.set(self, "scaling_policy", value)


@pulumi.input_type
class DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsInstanceConfigurationArgs:
    def __init__(__self__, *,
                 instance_shape_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] instance_shape_name: (Updatable) The shape used to launch the model deployment instances.
        """
        pulumi.set(__self__, "instance_shape_name", instance_shape_name)

    @property
    @pulumi.getter(name="instanceShapeName")
    def instance_shape_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The shape used to launch the model deployment instances.
        """
        return pulumi.get(self, "instance_shape_name")

    @instance_shape_name.setter
    def instance_shape_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_shape_name", value)


@pulumi.input_type
class DatascienceModelDeploymentModelDeploymentConfigurationDetailsModelConfigurationDetailsScalingPolicyArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 policy_type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] instance_count: (Updatable) The number of instances for the model deployment.
        :param pulumi.Input[str] policy_type: (Updatable) The type of scaling policy.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        (Updatable) The number of instances for the model deployment.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of scaling policy.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_type", value)


@pulumi.input_type
class DatascienceNotebookSessionNotebookSessionConfigurationDetailsArgs:
    def __init__(__self__, *,
                 shape: pulumi.Input[str],
                 subnet_id: pulumi.Input[str],
                 block_storage_size_in_gbs: Optional[pulumi.Input[int]] = None,
                 notebook_session_shape_config_details: Optional[pulumi.Input['DatascienceNotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs']] = None):
        """
        :param pulumi.Input[str] shape: (Updatable) The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        :param pulumi.Input[str] subnet_id: (Updatable) A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        :param pulumi.Input[int] block_storage_size_in_gbs: (Updatable) A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        :param pulumi.Input['DatascienceNotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs'] notebook_session_shape_config_details: (Updatable) Details for the notebook session shape configuration.
        """
        pulumi.set(__self__, "shape", shape)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if block_storage_size_in_gbs is not None:
            pulumi.set(__self__, "block_storage_size_in_gbs", block_storage_size_in_gbs)
        if notebook_session_shape_config_details is not None:
            pulumi.set(__self__, "notebook_session_shape_config_details", notebook_session_shape_config_details)

    @property
    @pulumi.getter
    def shape(self) -> pulumi.Input[str]:
        """
        (Updatable) The shape used to launch the notebook session compute instance.  The list of available shapes in a given compartment can be retrieved using the `ListNotebookSessionShapes` endpoint.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        (Updatable) A notebook session instance is provided with a VNIC for network access.  This specifies the [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the subnet to create a VNIC in.  The subnet should be in a VCN with a NAT gateway for egress to the internet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="blockStorageSizeInGbs")
    def block_storage_size_in_gbs(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) A notebook session instance is provided with a block storage volume. This specifies the size of the volume in GBs.
        """
        return pulumi.get(self, "block_storage_size_in_gbs")

    @block_storage_size_in_gbs.setter
    def block_storage_size_in_gbs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_storage_size_in_gbs", value)

    @property
    @pulumi.getter(name="notebookSessionShapeConfigDetails")
    def notebook_session_shape_config_details(self) -> Optional[pulumi.Input['DatascienceNotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs']]:
        """
        (Updatable) Details for the notebook session shape configuration.
        """
        return pulumi.get(self, "notebook_session_shape_config_details")

    @notebook_session_shape_config_details.setter
    def notebook_session_shape_config_details(self, value: Optional[pulumi.Input['DatascienceNotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs']]):
        pulumi.set(self, "notebook_session_shape_config_details", value)


@pulumi.input_type
class DatascienceNotebookSessionNotebookSessionConfigurationDetailsNotebookSessionShapeConfigDetailsArgs:
    def __init__(__self__, *,
                 memory_in_gbs: Optional[pulumi.Input[float]] = None,
                 ocpus: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] memory_in_gbs: (Updatable) A notebook session instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        :param pulumi.Input[float] ocpus: (Updatable) A notebook session instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        if memory_in_gbs is not None:
            pulumi.set(__self__, "memory_in_gbs", memory_in_gbs)
        if ocpus is not None:
            pulumi.set(__self__, "ocpus", ocpus)

    @property
    @pulumi.getter(name="memoryInGbs")
    def memory_in_gbs(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) A notebook session instance of type VM.Standard.E3.Flex allows memory to be specified. This specifies the size of the memory in GBs.
        """
        return pulumi.get(self, "memory_in_gbs")

    @memory_in_gbs.setter
    def memory_in_gbs(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory_in_gbs", value)

    @property
    @pulumi.getter
    def ocpus(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) A notebook session instance of type VM.Standard.E3.Flex allows the ocpu count to be specified.
        """
        return pulumi.get(self, "ocpus")

    @ocpus.setter
    def ocpus(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ocpus", value)


@pulumi.input_type
class DevopsDeployArtifactDeployArtifactSourceArgs:
    def __init__(__self__, *,
                 deploy_artifact_source_type: pulumi.Input[str],
                 base64encoded_content: Optional[pulumi.Input[str]] = None,
                 deploy_artifact_path: Optional[pulumi.Input[str]] = None,
                 deploy_artifact_version: Optional[pulumi.Input[str]] = None,
                 image_digest: Optional[pulumi.Input[str]] = None,
                 image_uri: Optional[pulumi.Input[str]] = None,
                 repository_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_source_type: (Updatable) Specifies types of artifact sources.
        :param pulumi.Input[str] base64encoded_content: (Updatable) base64 Encoded String
        :param pulumi.Input[str] deploy_artifact_path: (Updatable) Specifies the artifact path in the repository.
        :param pulumi.Input[str] deploy_artifact_version: (Updatable) Users can set this as a placeholder value that refers to a pipeline parameter, for example, ${appVersion}.
        :param pulumi.Input[str] image_digest: (Updatable) Specifies image digest for the version of the image.
        :param pulumi.Input[str] image_uri: (Updatable) Specifies OCIR Image Path - optionally include tag.
        :param pulumi.Input[str] repository_id: (Updatable) The OCID of a repository
        """
        pulumi.set(__self__, "deploy_artifact_source_type", deploy_artifact_source_type)
        if base64encoded_content is not None:
            pulumi.set(__self__, "base64encoded_content", base64encoded_content)
        if deploy_artifact_path is not None:
            pulumi.set(__self__, "deploy_artifact_path", deploy_artifact_path)
        if deploy_artifact_version is not None:
            pulumi.set(__self__, "deploy_artifact_version", deploy_artifact_version)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if repository_id is not None:
            pulumi.set(__self__, "repository_id", repository_id)

    @property
    @pulumi.getter(name="deployArtifactSourceType")
    def deploy_artifact_source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies types of artifact sources.
        """
        return pulumi.get(self, "deploy_artifact_source_type")

    @deploy_artifact_source_type.setter
    def deploy_artifact_source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "deploy_artifact_source_type", value)

    @property
    @pulumi.getter(name="base64encodedContent")
    def base64encoded_content(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) base64 Encoded String
        """
        return pulumi.get(self, "base64encoded_content")

    @base64encoded_content.setter
    def base64encoded_content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base64encoded_content", value)

    @property
    @pulumi.getter(name="deployArtifactPath")
    def deploy_artifact_path(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies the artifact path in the repository.
        """
        return pulumi.get(self, "deploy_artifact_path")

    @deploy_artifact_path.setter
    def deploy_artifact_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_path", value)

    @property
    @pulumi.getter(name="deployArtifactVersion")
    def deploy_artifact_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Users can set this as a placeholder value that refers to a pipeline parameter, for example, ${appVersion}.
        """
        return pulumi.get(self, "deploy_artifact_version")

    @deploy_artifact_version.setter
    def deploy_artifact_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_version", value)

    @property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies image digest for the version of the image.
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_digest", value)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies OCIR Image Path - optionally include tag.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="repositoryId")
    def repository_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of a repository
        """
        return pulumi.get(self, "repository_id")

    @repository_id.setter
    def repository_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository_id", value)


@pulumi.input_type
class DevopsDeployEnvironmentComputeInstanceGroupSelectorsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]] items: (Updatable) A list of selectors for the instance group. UNION operator is used for combining the instances selected by each selector.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]]]:
        """
        (Updatable) A list of selectors for the instance group. UNION operator is used for combining the instances selected by each selector.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployEnvironmentComputeInstanceGroupSelectorsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployEnvironmentComputeInstanceGroupSelectorsItemArgs:
    def __init__(__self__, *,
                 selector_type: pulumi.Input[str],
                 compute_instance_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 query: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] selector_type: (Updatable) Defines the type of the instance selector for the group.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] compute_instance_ids: (Updatable) Compute instance OCID identifiers that are members of this group.
        :param pulumi.Input[str] query: (Updatable) Query expression confirming to the Oracle Cloud Infrastructure Search Language syntax to select compute instances for the group. The language is documented at https://docs.oracle.com/en-us/iaas/Content/Search/Concepts/querysyntax.htm
        :param pulumi.Input[str] region: (Updatable) Region identifier referred by the deployment environment. Region identifiers are listed at https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        """
        pulumi.set(__self__, "selector_type", selector_type)
        if compute_instance_ids is not None:
            pulumi.set(__self__, "compute_instance_ids", compute_instance_ids)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="selectorType")
    def selector_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Defines the type of the instance selector for the group.
        """
        return pulumi.get(self, "selector_type")

    @selector_type.setter
    def selector_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "selector_type", value)

    @property
    @pulumi.getter(name="computeInstanceIds")
    def compute_instance_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Compute instance OCID identifiers that are members of this group.
        """
        return pulumi.get(self, "compute_instance_ids")

    @compute_instance_ids.setter
    def compute_instance_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "compute_instance_ids", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Query expression confirming to the Oracle Cloud Infrastructure Search Language syntax to select compute instances for the group. The language is documented at https://docs.oracle.com/en-us/iaas/Content/Search/Concepts/querysyntax.htm
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Region identifier referred by the deployment environment. Region identifiers are listed at https://docs.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineArtifactsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemArgs']]] items: (Updatable) List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemArgs']]]]:
        """
        (Updatable) List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineArtifactsItemArgs:
    def __init__(__self__, *,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_id: The OCID of an artifact
        :param pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesArgs'] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an artifact
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesArgs']]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesArgs']]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]] items: (Updatable) List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]]]:
        """
        (Updatable) List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineArtifactsItemDeployPipelineStagesItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: The OCID of a stage
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of a stage
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineEnvironmentsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemArgs']]] items: (Updatable) List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemArgs']]]]:
        """
        (Updatable) List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineEnvironmentsItemArgs:
    def __init__(__self__, *,
                 deploy_environment_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_environment_id: The OCID of an Environment
        :param pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesArgs'] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_environment_id is not None:
            pulumi.set(__self__, "deploy_environment_id", deploy_environment_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployEnvironmentId")
    def deploy_environment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an Environment
        """
        return pulumi.get(self, "deploy_environment_id")

    @deploy_environment_id.setter
    def deploy_environment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_environment_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesArgs']]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesArgs']]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]] items: (Updatable) List of parameters defined for a deployment pipeline.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]]]:
        """
        (Updatable) List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: The OCID of a stage
        :param pulumi.Input[str] display_name: (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of a stage
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment pipeline display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineParametersArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineParametersItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineParametersItemArgs']]] items: (Updatable) List of parameters defined for a deployment pipeline.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineParametersItemArgs']]]:
        """
        (Updatable) List of parameters defined for a deployment pipeline.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DevopsDeployPipelineDeployPipelineParametersItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployPipelineDeployPipelineParametersItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default_value: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        :param pulumi.Input[str] default_value: (Updatable) Default value of the parameter.
        :param pulumi.Input[str] description: (Updatable) Optional description about the deployment pipeline.
        """
        pulumi.set(__self__, "name", name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Default value of the parameter.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Optional description about the deployment pipeline.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class DevopsDeployStageApprovalPolicyArgs:
    def __init__(__self__, *,
                 approval_policy_type: pulumi.Input[str],
                 number_of_approvals_required: pulumi.Input[int]):
        """
        :param pulumi.Input[str] approval_policy_type: (Updatable) Approval policy type.
        :param pulumi.Input[int] number_of_approvals_required: (Updatable) A minimum number of approvals required for stage to proceed.
        """
        pulumi.set(__self__, "approval_policy_type", approval_policy_type)
        pulumi.set(__self__, "number_of_approvals_required", number_of_approvals_required)

    @property
    @pulumi.getter(name="approvalPolicyType")
    def approval_policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Approval policy type.
        """
        return pulumi.get(self, "approval_policy_type")

    @approval_policy_type.setter
    def approval_policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "approval_policy_type", value)

    @property
    @pulumi.getter(name="numberOfApprovalsRequired")
    def number_of_approvals_required(self) -> pulumi.Input[int]:
        """
        (Updatable) A minimum number of approvals required for stage to proceed.
        """
        return pulumi.get(self, "number_of_approvals_required")

    @number_of_approvals_required.setter
    def number_of_approvals_required(self, value: pulumi.Input[int]):
        pulumi.set(self, "number_of_approvals_required", value)


@pulumi.input_type
class DevopsDeployStageBlueBackendIpsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] items: (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployStageDeployStagePredecessorCollectionArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['DevopsDeployStageDeployStagePredecessorCollectionItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeployStageDeployStagePredecessorCollectionItemArgs']]] items: (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['DevopsDeployStageDeployStagePredecessorCollectionItemArgs']]]:
        """
        (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['DevopsDeployStageDeployStagePredecessorCollectionItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployStageDeployStagePredecessorCollectionItemArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the predecessor stage. If a stage is the first stage in the pipeline, then the ID is the pipeline's OCID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class DevopsDeployStageFailurePolicyArgs:
    def __init__(__self__, *,
                 policy_type: pulumi.Input[str],
                 failure_count: Optional[pulumi.Input[int]] = None,
                 failure_percentage: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] policy_type: (Updatable) The type of policy used for rolling out a deployment stage.
        :param pulumi.Input[int] failure_count: (Updatable) The threshold count of failed instances in the group, which when reached or exceeded sets the stage as FAILED.
        :param pulumi.Input[int] failure_percentage: (Updatable) The failure percentage threshold, which when reached or exceeded sets the stage as FAILED. Percentage is computed as the ceiling value of the number of failed instances over the total count of the instances in the group.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        if failure_count is not None:
            pulumi.set(__self__, "failure_count", failure_count)
        if failure_percentage is not None:
            pulumi.set(__self__, "failure_percentage", failure_percentage)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of policy used for rolling out a deployment stage.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_type", value)

    @property
    @pulumi.getter(name="failureCount")
    def failure_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The threshold count of failed instances in the group, which when reached or exceeded sets the stage as FAILED.
        """
        return pulumi.get(self, "failure_count")

    @failure_count.setter
    def failure_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_count", value)

    @property
    @pulumi.getter(name="failurePercentage")
    def failure_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The failure percentage threshold, which when reached or exceeded sets the stage as FAILED. Percentage is computed as the ceiling value of the number of failed instances over the total count of the instances in the group.
        """
        return pulumi.get(self, "failure_percentage")

    @failure_percentage.setter
    def failure_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_percentage", value)


@pulumi.input_type
class DevopsDeployStageGreenBackendIpsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] items: (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The IP address of the backend server. A server could be a compute instance or a load balancer.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeployStageLoadBalancerConfigArgs:
    def __init__(__self__, *,
                 backend_port: Optional[pulumi.Input[int]] = None,
                 listener_name: Optional[pulumi.Input[str]] = None,
                 load_balancer_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] backend_port: (Updatable) Listen port for the backend server.
        :param pulumi.Input[str] listener_name: (Updatable) Name of the load balancer listener.
        :param pulumi.Input[str] load_balancer_id: (Updatable) The OCID of the load balancer.
        :param pulumi.Input[str] state: The current state of the deployment stage.
        """
        if backend_port is not None:
            pulumi.set(__self__, "backend_port", backend_port)
        if listener_name is not None:
            pulumi.set(__self__, "listener_name", listener_name)
        if load_balancer_id is not None:
            pulumi.set(__self__, "load_balancer_id", load_balancer_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="backendPort")
    def backend_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Listen port for the backend server.
        """
        return pulumi.get(self, "backend_port")

    @backend_port.setter
    def backend_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backend_port", value)

    @property
    @pulumi.getter(name="listenerName")
    def listener_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the load balancer listener.
        """
        return pulumi.get(self, "listener_name")

    @listener_name.setter
    def listener_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "listener_name", value)

    @property
    @pulumi.getter(name="loadBalancerId")
    def load_balancer_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the load balancer.
        """
        return pulumi.get(self, "load_balancer_id")

    @load_balancer_id.setter
    def load_balancer_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the deployment stage.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class DevopsDeployStageRollbackPolicyArgs:
    def __init__(__self__, *,
                 policy_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy_type: (Updatable) The type of policy used for rolling out a deployment stage.
        """
        if policy_type is not None:
            pulumi.set(__self__, "policy_type", policy_type)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type of policy used for rolling out a deployment stage.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy_type", value)


@pulumi.input_type
class DevopsDeployStageRolloutPolicyArgs:
    def __init__(__self__, *,
                 policy_type: pulumi.Input[str],
                 batch_count: Optional[pulumi.Input[int]] = None,
                 batch_delay_in_seconds: Optional[pulumi.Input[int]] = None,
                 batch_percentage: Optional[pulumi.Input[int]] = None,
                 ramp_limit_percent: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] policy_type: (Updatable) The type of policy used for rolling out a deployment stage.
        :param pulumi.Input[int] batch_count: (Updatable) The number that will be used to determine how many instances will be deployed concurrently.
        :param pulumi.Input[int] batch_delay_in_seconds: (Updatable) The duration of delay between batch rollout. The default delay is 1 minute.
        :param pulumi.Input[int] batch_percentage: (Updatable) The percentage that will be used to determine how many instances will be deployed concurrently.
        :param pulumi.Input[float] ramp_limit_percent: (Updatable) Indicates the criteria to stop.
        """
        pulumi.set(__self__, "policy_type", policy_type)
        if batch_count is not None:
            pulumi.set(__self__, "batch_count", batch_count)
        if batch_delay_in_seconds is not None:
            pulumi.set(__self__, "batch_delay_in_seconds", batch_delay_in_seconds)
        if batch_percentage is not None:
            pulumi.set(__self__, "batch_percentage", batch_percentage)
        if ramp_limit_percent is not None:
            pulumi.set(__self__, "ramp_limit_percent", ramp_limit_percent)

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of policy used for rolling out a deployment stage.
        """
        return pulumi.get(self, "policy_type")

    @policy_type.setter
    def policy_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy_type", value)

    @property
    @pulumi.getter(name="batchCount")
    def batch_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number that will be used to determine how many instances will be deployed concurrently.
        """
        return pulumi.get(self, "batch_count")

    @batch_count.setter
    def batch_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_count", value)

    @property
    @pulumi.getter(name="batchDelayInSeconds")
    def batch_delay_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The duration of delay between batch rollout. The default delay is 1 minute.
        """
        return pulumi.get(self, "batch_delay_in_seconds")

    @batch_delay_in_seconds.setter
    def batch_delay_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_delay_in_seconds", value)

    @property
    @pulumi.getter(name="batchPercentage")
    def batch_percentage(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The percentage that will be used to determine how many instances will be deployed concurrently.
        """
        return pulumi.get(self, "batch_percentage")

    @batch_percentage.setter
    def batch_percentage(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_percentage", value)

    @property
    @pulumi.getter(name="rampLimitPercent")
    def ramp_limit_percent(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) Indicates the criteria to stop.
        """
        return pulumi.get(self, "ramp_limit_percent")

    @ramp_limit_percent.setter
    def ramp_limit_percent(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "ramp_limit_percent", value)


@pulumi.input_type
class DevopsDeployStageWaitCriteriaArgs:
    def __init__(__self__, *,
                 wait_duration: pulumi.Input[str],
                 wait_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] wait_duration: (Updatable) The absolute wait duration. An ISO 8601 formatted duration string. Minimum waitDuration should be 5 seconds. Maximum waitDuration can be up to 2 days.
        :param pulumi.Input[str] wait_type: (Updatable) Wait criteria type.
        """
        pulumi.set(__self__, "wait_duration", wait_duration)
        pulumi.set(__self__, "wait_type", wait_type)

    @property
    @pulumi.getter(name="waitDuration")
    def wait_duration(self) -> pulumi.Input[str]:
        """
        (Updatable) The absolute wait duration. An ISO 8601 formatted duration string. Minimum waitDuration should be 5 seconds. Maximum waitDuration can be up to 2 days.
        """
        return pulumi.get(self, "wait_duration")

    @wait_duration.setter
    def wait_duration(self, value: pulumi.Input[str]):
        pulumi.set(self, "wait_duration", value)

    @property
    @pulumi.getter(name="waitType")
    def wait_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Wait criteria type.
        """
        return pulumi.get(self, "wait_type")

    @wait_type.setter
    def wait_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "wait_type", value)


@pulumi.input_type
class DevopsDeploymentDeployArtifactOverrideArgumentsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployArtifactOverrideArgumentsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployArtifactOverrideArgumentsItemArgs']]] items: List of arguments provided at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployArtifactOverrideArgumentsItemArgs']]]]:
        """
        List of arguments provided at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployArtifactOverrideArgumentsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeploymentDeployArtifactOverrideArgumentsItemArgs:
    def __init__(__self__, *,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_id: The OCID of the artifact to which this parameter applies.
        :param pulumi.Input[str] name: Name of the parameter (case-sensitive).
        :param pulumi.Input[str] value: value of the argument.
        """
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the artifact to which this parameter applies.
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of the argument.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineArtifactsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemArgs']]] items: List of arguments provided at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemArgs']]]]:
        """
        List of arguments provided at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineArtifactsItemArgs:
    def __init__(__self__, *,
                 deploy_artifact_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_artifact_id: The OCID of the artifact to which this parameter applies.
        :param pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesArgs'] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_artifact_id is not None:
            pulumi.set(__self__, "deploy_artifact_id", deploy_artifact_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployArtifactId")
    def deploy_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the artifact to which this parameter applies.
        """
        return pulumi.get(self, "deploy_artifact_id")

    @deploy_artifact_id.setter
    def deploy_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_artifact_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesArgs']]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesArgs']]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]] items: List of arguments provided at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]]]:
        """
        List of arguments provided at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineArtifactsItemDeployPipelineStagesItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: Specifies the OCID of the stage to be redeployed.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the OCID of the stage to be redeployed.
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineEnvironmentsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemArgs']]] items: List of arguments provided at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemArgs']]]]:
        """
        List of arguments provided at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineEnvironmentsItemArgs:
    def __init__(__self__, *,
                 deploy_environment_id: Optional[pulumi.Input[str]] = None,
                 deploy_pipeline_stages: Optional[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesArgs']] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_environment_id: The OCID of an Environment
        :param pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesArgs'] deploy_pipeline_stages: List of stages.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_environment_id is not None:
            pulumi.set(__self__, "deploy_environment_id", deploy_environment_id)
        if deploy_pipeline_stages is not None:
            pulumi.set(__self__, "deploy_pipeline_stages", deploy_pipeline_stages)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployEnvironmentId")
    def deploy_environment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of an Environment
        """
        return pulumi.get(self, "deploy_environment_id")

    @deploy_environment_id.setter
    def deploy_environment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_environment_id", value)

    @property
    @pulumi.getter(name="deployPipelineStages")
    def deploy_pipeline_stages(self) -> Optional[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesArgs']]:
        """
        List of stages.
        """
        return pulumi.get(self, "deploy_pipeline_stages")

    @deploy_pipeline_stages.setter
    def deploy_pipeline_stages(self, value: Optional[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesArgs']]):
        pulumi.set(self, "deploy_pipeline_stages", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]] items: List of arguments provided at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]]]:
        """
        List of arguments provided at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeploymentDeployPipelineEnvironmentsItemDeployPipelineStagesItemArgs:
    def __init__(__self__, *,
                 deploy_stage_id: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deploy_stage_id: Specifies the OCID of the stage to be redeployed.
        :param pulumi.Input[str] display_name: (Updatable) Deployment display name. Avoid entering confidential information.
        """
        if deploy_stage_id is not None:
            pulumi.set(__self__, "deploy_stage_id", deploy_stage_id)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="deployStageId")
    def deploy_stage_id(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the OCID of the stage to be redeployed.
        """
        return pulumi.get(self, "deploy_stage_id")

    @deploy_stage_id.setter
    def deploy_stage_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deploy_stage_id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Deployment display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class DevopsDeploymentDeploymentArgumentsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeploymentArgumentsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeploymentArgumentsItemArgs']]] items: List of arguments provided at the time of deployment.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeploymentArgumentsItemArgs']]]]:
        """
        List of arguments provided at the time of deployment.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DevopsDeploymentDeploymentArgumentsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class DevopsDeploymentDeploymentArgumentsItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the parameter (case-sensitive).
        :param pulumi.Input[str] value: value of the argument.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the parameter (case-sensitive).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        value of the argument.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DevopsDeploymentDeploymentExecutionProgressArgs:
    def __init__(__self__, *,
                 deploy_stage_execution_progress: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 time_finished: Optional[pulumi.Input[str]] = None,
                 time_started: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] deploy_stage_execution_progress: Map of stage OCIDs to deploy stage execution progress model.
        :param pulumi.Input[str] time_finished: Time the deployment is finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        :param pulumi.Input[str] time_started: Time the deployment is started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        if deploy_stage_execution_progress is not None:
            pulumi.set(__self__, "deploy_stage_execution_progress", deploy_stage_execution_progress)
        if time_finished is not None:
            pulumi.set(__self__, "time_finished", time_finished)
        if time_started is not None:
            pulumi.set(__self__, "time_started", time_started)

    @property
    @pulumi.getter(name="deployStageExecutionProgress")
    def deploy_stage_execution_progress(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Map of stage OCIDs to deploy stage execution progress model.
        """
        return pulumi.get(self, "deploy_stage_execution_progress")

    @deploy_stage_execution_progress.setter
    def deploy_stage_execution_progress(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "deploy_stage_execution_progress", value)

    @property
    @pulumi.getter(name="timeFinished")
    def time_finished(self) -> Optional[pulumi.Input[str]]:
        """
        Time the deployment is finished. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        return pulumi.get(self, "time_finished")

    @time_finished.setter
    def time_finished(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_finished", value)

    @property
    @pulumi.getter(name="timeStarted")
    def time_started(self) -> Optional[pulumi.Input[str]]:
        """
        Time the deployment is started. Format defined by [RFC3339](https://datatracker.ietf.org/doc/html/rfc3339).
        """
        return pulumi.get(self, "time_started")

    @time_started.setter
    def time_started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_started", value)


@pulumi.input_type
class DevopsProjectNotificationConfigArgs:
    def __init__(__self__, *,
                 topic_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] topic_id: (Updatable) The topic ID for notifications.
        """
        pulumi.set(__self__, "topic_id", topic_id)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The topic ID for notifications.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_id", value)


@pulumi.input_type
class DnsResolverAttachedViewArgs:
    def __init__(__self__, *,
                 view_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] view_id: (Updatable) The OCID of the view.
        """
        pulumi.set(__self__, "view_id", view_id)

    @property
    @pulumi.getter(name="viewId")
    def view_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the view.
        """
        return pulumi.get(self, "view_id")

    @view_id.setter
    def view_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_id", value)


@pulumi.input_type
class DnsResolverEndpointArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 endpoint_type: Optional[pulumi.Input[str]] = None,
                 forwarding_address: Optional[pulumi.Input[str]] = None,
                 is_forwarding: Optional[pulumi.Input[bool]] = None,
                 is_listening: Optional[pulumi.Input[bool]] = None,
                 listening_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 self: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the owning compartment.
        :param pulumi.Input[str] endpoint_type: The type of resolver endpoint. VNIC is currently the only supported type.
        :param pulumi.Input[str] forwarding_address: An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        :param pulumi.Input[bool] is_forwarding: A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        :param pulumi.Input[bool] is_listening: A Boolean flag indicating whether or not the resolver endpoint is for listening.
        :param pulumi.Input[str] listening_address: An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        :param pulumi.Input[str] name: The name of the resolver endpoint. Must be unique, case-insensitive, within the resolver.
        :param pulumi.Input[str] self: The canonical absolute URL of the resource.
        :param pulumi.Input[str] state: The current state of the resource.
        :param pulumi.Input[str] subnet_id: The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        :param pulumi.Input[str] time_created: The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        :param pulumi.Input[str] time_updated: The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if forwarding_address is not None:
            pulumi.set(__self__, "forwarding_address", forwarding_address)
        if is_forwarding is not None:
            pulumi.set(__self__, "is_forwarding", is_forwarding)
        if is_listening is not None:
            pulumi.set(__self__, "is_listening", is_listening)
        if listening_address is not None:
            pulumi.set(__self__, "listening_address", listening_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if self is not None:
            pulumi.set(__self__, "self", self)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the owning compartment.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of resolver endpoint. VNIC is currently the only supported type.
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="forwardingAddress")
    def forwarding_address(self) -> Optional[pulumi.Input[str]]:
        """
        An IP address from which forwarded queries may be sent. For VNIC endpoints, this IP address must be part of the subnet and will be assigned by the system if unspecified when isForwarding is true.
        """
        return pulumi.get(self, "forwarding_address")

    @forwarding_address.setter
    def forwarding_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forwarding_address", value)

    @property
    @pulumi.getter(name="isForwarding")
    def is_forwarding(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for forwarding.
        """
        return pulumi.get(self, "is_forwarding")

    @is_forwarding.setter
    def is_forwarding(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_forwarding", value)

    @property
    @pulumi.getter(name="isListening")
    def is_listening(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean flag indicating whether or not the resolver endpoint is for listening.
        """
        return pulumi.get(self, "is_listening")

    @is_listening.setter
    def is_listening(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_listening", value)

    @property
    @pulumi.getter(name="listeningAddress")
    def listening_address(self) -> Optional[pulumi.Input[str]]:
        """
        An IP address to listen to queries on. For VNIC endpoints this IP address must be part of the subnet and will be assigned by the system if unspecified when isListening is true.
        """
        return pulumi.get(self, "listening_address")

    @listening_address.setter
    def listening_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "listening_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the resolver endpoint. Must be unique, case-insensitive, within the resolver.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def self(self) -> Optional[pulumi.Input[str]]:
        """
        The canonical absolute URL of the resource.
        """
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "self", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the resource.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of a subnet. Must be part of the VCN that the resolver is attached to.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the resource was created in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the resource was last updated in "YYYY-MM-ddThh:mm:ssZ" format with a Z offset, as defined by RFC 3339.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class DnsResolverRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 destination_addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 source_endpoint_name: pulumi.Input[str],
                 client_address_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 qname_cover_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] action: (Updatable) The action determines the behavior of the rule. If a query matches a supplied condition, the action will apply. If there are no conditions on the rule, all queries are subject to the specified action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_addresses: (Updatable) IP addresses to which queries should be forwarded. Currently limited to a single address.
        :param pulumi.Input[str] source_endpoint_name: (Updatable) Name of an endpoint, that is a sub-resource of the resolver, to use as the forwarding interface. The endpoint must have isForwarding set to true.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] client_address_conditions: (Updatable) A list of CIDR blocks. The query must come from a client within one of the blocks in order for the rule action to apply.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] qname_cover_conditions: (Updatable) A list of domain names. The query must be covered by one of the domains in order for the rule action to apply.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "destination_addresses", destination_addresses)
        pulumi.set(__self__, "source_endpoint_name", source_endpoint_name)
        if client_address_conditions is not None:
            pulumi.set(__self__, "client_address_conditions", client_address_conditions)
        if qname_cover_conditions is not None:
            pulumi.set(__self__, "qname_cover_conditions", qname_cover_conditions)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        (Updatable) The action determines the behavior of the rule. If a query matches a supplied condition, the action will apply. If there are no conditions on the rule, all queries are subject to the specified action.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) IP addresses to which queries should be forwarded. Currently limited to a single address.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="sourceEndpointName")
    def source_endpoint_name(self) -> pulumi.Input[str]:
        """
        (Updatable) Name of an endpoint, that is a sub-resource of the resolver, to use as the forwarding interface. The endpoint must have isForwarding set to true.
        """
        return pulumi.get(self, "source_endpoint_name")

    @source_endpoint_name.setter
    def source_endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_endpoint_name", value)

    @property
    @pulumi.getter(name="clientAddressConditions")
    def client_address_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of CIDR blocks. The query must come from a client within one of the blocks in order for the rule action to apply.
        """
        return pulumi.get(self, "client_address_conditions")

    @client_address_conditions.setter
    def client_address_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "client_address_conditions", value)

    @property
    @pulumi.getter(name="qnameCoverConditions")
    def qname_cover_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of domain names. The query must be covered by one of the domains in order for the rule action to apply.
        """
        return pulumi.get(self, "qname_cover_conditions")

    @qname_cover_conditions.setter
    def qname_cover_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "qname_cover_conditions", value)


@pulumi.input_type
class DnsRrsetItemArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[str],
                 rdata: pulumi.Input[str],
                 rtype: pulumi.Input[str],
                 ttl: pulumi.Input[int],
                 is_protected: Optional[pulumi.Input[bool]] = None,
                 record_hash: Optional[pulumi.Input[str]] = None,
                 rrset_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] domain: The fully qualified domain name where the record can be located.
        :param pulumi.Input[str] rdata: (Updatable) The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        :param pulumi.Input[str] rtype: The type of the target RRSet within the target zone.
        :param pulumi.Input[int] ttl: (Updatable) The Time To Live for the record, in seconds.
        :param pulumi.Input[bool] is_protected: A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        :param pulumi.Input[str] record_hash: A unique identifier for the record within its zone.
        :param pulumi.Input[str] rrset_version: The latest version of the record's zone in which its RRSet differs from the preceding version.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "rtype", rtype)
        pulumi.set(__self__, "ttl", ttl)
        if is_protected is not None:
            pulumi.set(__self__, "is_protected", is_protected)
        if record_hash is not None:
            pulumi.set(__self__, "record_hash", record_hash)
        if rrset_version is not None:
            pulumi.set(__self__, "rrset_version", rrset_version)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The fully qualified domain name where the record can be located.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def rdata(self) -> pulumi.Input[str]:
        """
        (Updatable) The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm)
        """
        return pulumi.get(self, "rdata")

    @rdata.setter
    def rdata(self, value: pulumi.Input[str]):
        pulumi.set(self, "rdata", value)

    @property
    @pulumi.getter
    def rtype(self) -> pulumi.Input[str]:
        """
        The type of the target RRSet within the target zone.
        """
        return pulumi.get(self, "rtype")

    @rtype.setter
    def rtype(self, value: pulumi.Input[str]):
        pulumi.set(self, "rtype", value)

    @property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[int]:
        """
        (Updatable) The Time To Live for the record, in seconds.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[int]):
        pulumi.set(self, "ttl", value)

    @property
    @pulumi.getter(name="isProtected")
    def is_protected(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean flag indicating whether or not parts of the record are unable to be explicitly managed.
        """
        return pulumi.get(self, "is_protected")

    @is_protected.setter
    def is_protected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_protected", value)

    @property
    @pulumi.getter(name="recordHash")
    def record_hash(self) -> Optional[pulumi.Input[str]]:
        """
        A unique identifier for the record within its zone.
        """
        return pulumi.get(self, "record_hash")

    @record_hash.setter
    def record_hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_hash", value)

    @property
    @pulumi.getter(name="rrsetVersion")
    def rrset_version(self) -> Optional[pulumi.Input[str]]:
        """
        The latest version of the record's zone in which its RRSet differs from the preceding version.
        """
        return pulumi.get(self, "rrset_version")

    @rrset_version.setter
    def rrset_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rrset_version", value)


@pulumi.input_type
class DnsSteeringPolicyAnswerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 rdata: pulumi.Input[str],
                 rtype: pulumi.Input[str],
                 is_disabled: Optional[pulumi.Input[bool]] = None,
                 pool: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        :param pulumi.Input[str] rdata: The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        :param pulumi.Input[str] rtype: The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        :param pulumi.Input[bool] is_disabled: Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        :param pulumi.Input[str] pool: The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rdata", rdata)
        pulumi.set(__self__, "rtype", rtype)
        if is_disabled is not None:
            pulumi.set(__self__, "is_disabled", is_disabled)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def rdata(self) -> pulumi.Input[str]:
        """
        The record's data, as whitespace-delimited tokens in type-specific presentation format. All RDATA is normalized and the returned presentation of your RDATA may differ from its initial input. For more information about RDATA, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rdata")

    @rdata.setter
    def rdata(self, value: pulumi.Input[str]):
        pulumi.set(self, "rdata", value)

    @property
    @pulumi.getter
    def rtype(self) -> pulumi.Input[str]:
        """
        The type of DNS record, such as A or CNAME. Only A, AAAA, and CNAME are supported. For more information, see [Supported DNS Resource Record Types](https://docs.cloud.oracle.com/iaas/Content/DNS/Reference/supporteddnsresource.htm).
        """
        return pulumi.get(self, "rtype")

    @rtype.setter
    def rtype(self, value: pulumi.Input[str]):
        pulumi.set(self, "rtype", value)

    @property
    @pulumi.getter(name="isDisabled")
    def is_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this property to `true` to indicate that the answer is administratively disabled, such as when the corresponding server is down for maintenance. An answer's `isDisabled` property can be referenced in `answerCondition` properties in rules using `answer.isDisabled`.
        """
        return pulumi.get(self, "is_disabled")

    @is_disabled.setter
    def is_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_disabled", value)

    @property
    @pulumi.getter
    def pool(self) -> Optional[pulumi.Input[str]]:
        """
        The freeform name of a group of one or more records in which this record is included, such as "LAX data center". An answer's `pool` property can be referenced in `answerCondition` properties of rules using `answer.pool`.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool", value)


@pulumi.input_type
class DnsSteeringPolicyRuleArgs:
    def __init__(__self__, *,
                 rule_type: pulumi.Input[str],
                 cases: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseArgs']]]] = None,
                 default_answer_datas: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleDefaultAnswerDataArgs']]]] = None,
                 default_count: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] rule_type: The type of a rule determines its sorting/filtering behavior.
        :param pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseArgs']]] cases: An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        :param pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleDefaultAnswerDataArgs']]] default_answer_datas: Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        :param pulumi.Input[int] default_count: Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        :param pulumi.Input[str] description: A user-defined description of the rule's purpose or behavior.
        """
        pulumi.set(__self__, "rule_type", rule_type)
        if cases is not None:
            pulumi.set(__self__, "cases", cases)
        if default_answer_datas is not None:
            pulumi.set(__self__, "default_answer_datas", default_answer_datas)
        if default_count is not None:
            pulumi.set(__self__, "default_count", default_count)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="ruleType")
    def rule_type(self) -> pulumi.Input[str]:
        """
        The type of a rule determines its sorting/filtering behavior.
        """
        return pulumi.get(self, "rule_type")

    @rule_type.setter
    def rule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule_type", value)

    @property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseArgs']]]]:
        """
        An array of `caseConditions`. A rule may optionally include a sequence of cases defining alternate configurations for how it should behave during processing for any given DNS query. When a rule has no sequence of `cases`, it is always evaluated with the same configuration during processing. When a rule has an empty sequence of `cases`, it is always ignored during processing. When a rule has a non-empty sequence of `cases`, its behavior during processing is configured by the first matching `case` in the sequence. When a rule has no matching cases the rule is ignored. A rule case with no `caseCondition` always matches. A rule case with a `caseCondition` matches only when that expression evaluates to true for the given query.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseArgs']]]]):
        pulumi.set(self, "cases", value)

    @property
    @pulumi.getter(name="defaultAnswerDatas")
    def default_answer_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleDefaultAnswerDataArgs']]]]:
        """
        Defines a default set of answer conditions and values that are applied to an answer when `cases` is not defined for the rule, or a matching case does not have any matching `answerCondition`s in its `answerData`. `defaultAnswerData` is not applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed.
        """
        return pulumi.get(self, "default_answer_datas")

    @default_answer_datas.setter
    def default_answer_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleDefaultAnswerDataArgs']]]]):
        pulumi.set(self, "default_answer_datas", value)

    @property
    @pulumi.getter(name="defaultCount")
    def default_count(self) -> Optional[pulumi.Input[int]]:
        """
        Defines a default count if `cases` is not defined for the rule or a matching case does not define `count`. `defaultCount` is **not** applied if `cases` is defined and there are no matching cases. In this scenario, the next rule will be processed. If no rules remain to be processed, the answer will be chosen from the remaining list of answers.
        """
        return pulumi.get(self, "default_count")

    @default_count.setter
    def default_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_count", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A user-defined description of the rule's purpose or behavior.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class DnsSteeringPolicyRuleCaseArgs:
    def __init__(__self__, *,
                 answer_datas: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseAnswerDataArgs']]]] = None,
                 case_condition: Optional[pulumi.Input[str]] = None,
                 count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseAnswerDataArgs']]] answer_datas: An array of `SteeringPolicyPriorityAnswerData` objects.
        :param pulumi.Input[str] case_condition: An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.subnet in ('192.0.2.0/24')` to define a case that matches queries from that office.
        :param pulumi.Input[int] count: The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        if answer_datas is not None:
            pulumi.set(__self__, "answer_datas", answer_datas)
        if case_condition is not None:
            pulumi.set(__self__, "case_condition", case_condition)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter(name="answerDatas")
    def answer_datas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseAnswerDataArgs']]]]:
        """
        An array of `SteeringPolicyPriorityAnswerData` objects.
        """
        return pulumi.get(self, "answer_datas")

    @answer_datas.setter
    def answer_datas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DnsSteeringPolicyRuleCaseAnswerDataArgs']]]]):
        pulumi.set(self, "answer_datas", value)

    @property
    @pulumi.getter(name="caseCondition")
    def case_condition(self) -> Optional[pulumi.Input[str]]:
        """
        An expression that uses conditions at the time of a DNS query to indicate whether a case matches. Conditions may include the geographical location, IP subnet, or ASN the DNS query originated. **Example:** If you have an office that uses the subnet `192.0.2.0/24` you could use a `caseCondition` expression `query.client.subnet in ('192.0.2.0/24')` to define a case that matches queries from that office.
        """
        return pulumi.get(self, "case_condition")

    @case_condition.setter
    def case_condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "case_condition", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of answers allowed to remain after the limit rule has been processed, keeping only the first of the remaining answers in the list. Example: If the `count` property is set to `2` and four answers remain before the limit rule is processed, only the first two answers in the list will remain after the limit rule has been processed.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class DnsSteeringPolicyRuleCaseAnswerDataArgs:
    def __init__(__self__, *,
                 answer_condition: Optional[pulumi.Input[str]] = None,
                 should_keep: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param pulumi.Input[bool] should_keep: Keeps the answer only if the value is `true`.
        :param pulumi.Input[int] value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        if answer_condition is not None:
            pulumi.set(__self__, "answer_condition", answer_condition)
        if should_keep is not None:
            pulumi.set(__self__, "should_keep", should_keep)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> Optional[pulumi.Input[str]]:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @answer_condition.setter
    def answer_condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "answer_condition", value)

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> Optional[pulumi.Input[bool]]:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @should_keep.setter
    def should_keep(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_keep", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DnsSteeringPolicyRuleDefaultAnswerDataArgs:
    def __init__(__self__, *,
                 answer_condition: Optional[pulumi.Input[str]] = None,
                 should_keep: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] answer_condition: An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        :param pulumi.Input[bool] should_keep: Keeps the answer only if the value is `true`.
        :param pulumi.Input[int] value: The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        if answer_condition is not None:
            pulumi.set(__self__, "answer_condition", answer_condition)
        if should_keep is not None:
            pulumi.set(__self__, "should_keep", should_keep)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="answerCondition")
    def answer_condition(self) -> Optional[pulumi.Input[str]]:
        """
        An expression that is used to select a set of answers that match a condition. For example, answers with matching pool properties.
        """
        return pulumi.get(self, "answer_condition")

    @answer_condition.setter
    def answer_condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "answer_condition", value)

    @property
    @pulumi.getter(name="shouldKeep")
    def should_keep(self) -> Optional[pulumi.Input[bool]]:
        """
        Keeps the answer only if the value is `true`.
        """
        return pulumi.get(self, "should_keep")

    @should_keep.setter
    def should_keep(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "should_keep", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        The rank assigned to the set of answers that match the expression in `answerCondition`. Answers with the lowest values move to the beginning of the list without changing the relative order of those with the same value. Answers can be given a value between `0` and `255`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DnsZoneExternalMasterArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 tsig_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: (Updatable) The server's IP address (IPv4 or IPv6).
        :param pulumi.Input[int] port: (Updatable) The server's port. Port value must be a value of 53, otherwise omit the port value.
        :param pulumi.Input[str] tsig_key_id: (Updatable) The OCID of the TSIG key.
        """
        pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tsig_key_id is not None:
            pulumi.set(__self__, "tsig_key_id", tsig_key_id)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        (Updatable) The server's IP address (IPv4 or IPv6).
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The server's port. Port value must be a value of 53, otherwise omit the port value.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="tsigKeyId")
    def tsig_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the TSIG key.
        """
        return pulumi.get(self, "tsig_key_id")

    @tsig_key_id.setter
    def tsig_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tsig_key_id", value)


@pulumi.input_type
class DnsZoneNameserverArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: The hostname of the nameserver.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname of the nameserver.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)


@pulumi.input_type
class EventsRuleActionsArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input['EventsRuleActionsActionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventsRuleActionsActionArgs']]] actions: (Updatable) A list of one or more ActionDetails objects.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input['EventsRuleActionsActionArgs']]]:
        """
        (Updatable) A list of one or more ActionDetails objects.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input['EventsRuleActionsActionArgs']]]):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class EventsRuleActionsActionArgs:
    def __init__(__self__, *,
                 action_type: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 description: Optional[pulumi.Input[str]] = None,
                 function_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 lifecycle_message: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 stream_id: Optional[pulumi.Input[str]] = None,
                 topic_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action_type: (Updatable) The action to perform if the condition in the rule matches an event.
               * **ONS:** Send to an Oracle Notification Service topic.
               * **OSS:** Send to a stream from Oracle Streaming Service.
               * **FAAS:** Send to an Oracle Functions Service endpoint.
        :param pulumi.Input[bool] is_enabled: (Updatable) Whether or not this rule is currently enabled.  Example: `true`
        :param pulumi.Input[str] description: (Updatable) A string that describes the details of the rule. It does not have to be unique, and you can change it. Avoid entering confidential information.
        :param pulumi.Input[str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a Function hosted by Oracle Functions Service.
        :param pulumi.Input[str] id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of this rule.
        :param pulumi.Input[str] lifecycle_message: A message generated by the Events service about the current state of this rule.
        :param pulumi.Input[str] state: The current state of the rule.
        :param pulumi.Input[str] stream_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream to which messages are delivered.
        :param pulumi.Input[str] topic_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the topic to which messages are delivered.
        """
        pulumi.set(__self__, "action_type", action_type)
        pulumi.set(__self__, "is_enabled", is_enabled)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if lifecycle_message is not None:
            pulumi.set(__self__, "lifecycle_message", lifecycle_message)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if topic_id is not None:
            pulumi.set(__self__, "topic_id", topic_id)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The action to perform if the condition in the rule matches an event.
        * **ONS:** Send to an Oracle Notification Service topic.
        * **OSS:** Send to a stream from Oracle Streaming Service.
        * **FAAS:** Send to an Oracle Functions Service endpoint.
        """
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Whether or not this rule is currently enabled.  Example: `true`
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A string that describes the details of the rule. It does not have to be unique, and you can change it. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of a Function hosted by Oracle Functions Service.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of this rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="lifecycleMessage")
    def lifecycle_message(self) -> Optional[pulumi.Input[str]]:
        """
        A message generated by the Events service about the current state of this rule.
        """
        return pulumi.get(self, "lifecycle_message")

    @lifecycle_message.setter
    def lifecycle_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_message", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the rule.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream to which messages are delivered.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_id", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the topic to which messages are delivered.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_id", value)


@pulumi.input_type
class FileStorageExportExportOptionArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[str],
                 access: Optional[pulumi.Input[str]] = None,
                 anonymous_gid: Optional[pulumi.Input[str]] = None,
                 anonymous_uid: Optional[pulumi.Input[str]] = None,
                 identity_squash: Optional[pulumi.Input[str]] = None,
                 require_privileged_source_port: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] source: (Updatable) Clients these options should apply to. Must be a either single IPv4 address or single IPv4 CIDR block.
        :param pulumi.Input[str] access: (Updatable) Type of access to grant clients using the file system through this export. If unspecified defaults to `READ_ONLY`.
        :param pulumi.Input[str] anonymous_gid: (Updatable) GID value to remap to when squashing a client GID (see identitySquash for more details.) If unspecified defaults to `65534`.
        :param pulumi.Input[str] anonymous_uid: (Updatable) UID value to remap to when squashing a client UID (see identitySquash for more details.) If unspecified, defaults to `65534`.
        :param pulumi.Input[str] identity_squash: (Updatable) Used when clients accessing the file system through this export have their UID and GID remapped to 'anonymousUid' and 'anonymousGid'. If `ALL`, all users and groups are remapped; if `ROOT`, only the root user and group (UID/GID 0) are remapped; if `NONE`, no remapping is done. If unspecified, defaults to `ROOT`.
        :param pulumi.Input[bool] require_privileged_source_port: (Updatable) If `true`, clients accessing the file system through this export must connect from a privileged source port. If unspecified, defaults to `true`.
        """
        pulumi.set(__self__, "source", source)
        if access is not None:
            pulumi.set(__self__, "access", access)
        if anonymous_gid is not None:
            pulumi.set(__self__, "anonymous_gid", anonymous_gid)
        if anonymous_uid is not None:
            pulumi.set(__self__, "anonymous_uid", anonymous_uid)
        if identity_squash is not None:
            pulumi.set(__self__, "identity_squash", identity_squash)
        if require_privileged_source_port is not None:
            pulumi.set(__self__, "require_privileged_source_port", require_privileged_source_port)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        (Updatable) Clients these options should apply to. Must be a either single IPv4 address or single IPv4 CIDR block.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def access(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Type of access to grant clients using the file system through this export. If unspecified defaults to `READ_ONLY`.
        """
        return pulumi.get(self, "access")

    @access.setter
    def access(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access", value)

    @property
    @pulumi.getter(name="anonymousGid")
    def anonymous_gid(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) GID value to remap to when squashing a client GID (see identitySquash for more details.) If unspecified defaults to `65534`.
        """
        return pulumi.get(self, "anonymous_gid")

    @anonymous_gid.setter
    def anonymous_gid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "anonymous_gid", value)

    @property
    @pulumi.getter(name="anonymousUid")
    def anonymous_uid(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) UID value to remap to when squashing a client UID (see identitySquash for more details.) If unspecified, defaults to `65534`.
        """
        return pulumi.get(self, "anonymous_uid")

    @anonymous_uid.setter
    def anonymous_uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "anonymous_uid", value)

    @property
    @pulumi.getter(name="identitySquash")
    def identity_squash(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Used when clients accessing the file system through this export have their UID and GID remapped to 'anonymousUid' and 'anonymousGid'. If `ALL`, all users and groups are remapped; if `ROOT`, only the root user and group (UID/GID 0) are remapped; if `NONE`, no remapping is done. If unspecified, defaults to `ROOT`.
        """
        return pulumi.get(self, "identity_squash")

    @identity_squash.setter
    def identity_squash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity_squash", value)

    @property
    @pulumi.getter(name="requirePrivilegedSourcePort")
    def require_privileged_source_port(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If `true`, clients accessing the file system through this export must connect from a privileged source port. If unspecified, defaults to `true`.
        """
        return pulumi.get(self, "require_privileged_source_port")

    @require_privileged_source_port.setter
    def require_privileged_source_port(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_privileged_source_port", value)


@pulumi.input_type
class FileStorageFileSystemSourceDetailsArgs:
    def __init__(__self__, *,
                 parent_file_system_id: Optional[pulumi.Input[str]] = None,
                 source_snapshot_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] parent_file_system_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the file system that contains the source snapshot of a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningafilesystem.htm).
        :param pulumi.Input[str] source_snapshot_id: The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the snapshot used to create a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningafilesystem.htm).
        """
        if parent_file_system_id is not None:
            pulumi.set(__self__, "parent_file_system_id", parent_file_system_id)
        if source_snapshot_id is not None:
            pulumi.set(__self__, "source_snapshot_id", source_snapshot_id)

    @property
    @pulumi.getter(name="parentFileSystemId")
    def parent_file_system_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the file system that contains the source snapshot of a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningafilesystem.htm).
        """
        return pulumi.get(self, "parent_file_system_id")

    @parent_file_system_id.setter
    def parent_file_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_file_system_id", value)

    @property
    @pulumi.getter(name="sourceSnapshotId")
    def source_snapshot_id(self) -> Optional[pulumi.Input[str]]:
        """
        The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the snapshot used to create a cloned file system. See [Cloning a File System](https://docs.cloud.oracle.com/iaas/Content/File/Tasks/cloningafilesystem.htm).
        """
        return pulumi.get(self, "source_snapshot_id")

    @source_snapshot_id.setter
    def source_snapshot_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_snapshot_id", value)


@pulumi.input_type
class FunctionsApplicationTraceConfigArgs:
    def __init__(__self__, *,
                 domain_id: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] domain_id: (Updatable) The OCID of the collector (e.g. an APM Domain) trace events will be sent to.
        :param pulumi.Input[bool] is_enabled: (Updatable) Define if tracing is enabled for the resource.
        """
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the collector (e.g. an APM Domain) trace events will be sent to.
        """
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Define if tracing is enabled for the resource.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class FunctionsFunctionTraceConfigArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Define if tracing is enabled for the resource.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Define if tracing is enabled for the resource.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class GetAnalyticsAnalyticsInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApigatewayApisFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the validation.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the validation.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApigatewayCertificatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApigatewayDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The case-insensitive name of the header.  This name must be unique across transformation policies.
        :param Sequence[str] values: A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The case-insensitive name of the header.  This name must be unique across transformation policies.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of new values.  Each value can be a constant or may include one or more expressions enclosed within ${} delimiters.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApigatewayGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApmApmDomainsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApmDataKeysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the Data Key. The name uniquely identifies a Data Key within an APM domain.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Data Key. The name uniquely identifies a Data Key within an APM domain.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApmSyntheticsMonitorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the vantage point.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the vantage point.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApmSyntheticsPublicVantagePointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetApmSyntheticsScriptsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetArtifactsContainerImageSignaturesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetArtifactsContainerImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetArtifactsContainerRepositoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetArtifactsGenericArtifactsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetArtifactsRepositoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAuditEventsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetAutoscalingAutoScalingConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBastionBastionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBastionSessionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBdsAutoScalingConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBdsBdsInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBlockchainBlockchainPlatformsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBlockchainOsnsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBlockchainPeersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBudgetAlertRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetBudgetBudgetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudGuardDataMaskRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param Sequence[str] values: Types of Targets
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Types of Targets
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudGuardDetectorRecipesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: configuration name
        :param Sequence[str] values: List of configuration values
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudGuardManagedListsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudGuardResponderRecipesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: configuration name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCloudGuardTargetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: configuration name
        :param Sequence[str] values: List of configuration values
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        configuration name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        List of configuration values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeinstanceagentInstanceAgentPluginsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The plugin name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The plugin name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetComputeinstanceagentInstanceAvailablePluginsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The plugin name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The plugin name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetContainerengineClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name to filter on.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name to filter on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetContainerengineNodePoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name to filter on.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name to filter on.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetContainerengineWorkRequestErrorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetContainerengineWorkRequestLogEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetContainerengineWorkRequestsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreAppCatalogListingResourceVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreAppCatalogListingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreAppCatalogSubscriptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreBlockVolumeReplicasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreBootVolumeAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreBootVolumeBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreBootVolumeReplicasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreBootVolumesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreByoipAllocatedRangesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreByoipRangesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreClusterNetworkInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreClusterNetworksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreComputeCapacityReservationInstanceShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreComputeCapacityReservationInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreComputeCapacityReservationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreComputeGlobalImageCapabilitySchemasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreComputeGlobalImageCapabilitySchemasVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the compute global image capability schema version
        :param Sequence[str] values: the list of values for the enum
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the compute global image capability schema version
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        the list of values for the enum
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreComputeImageCapabilitySchemasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param Sequence[str] values: the list of values for the enum
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        the list of values for the enum
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreConsoleHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreCpeDeviceShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreCpesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreCrossConnectGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreCrossConnectLocationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the location.  Example: `CyrusOne, Chandler, AZ`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the location.  Example: `CyrusOne, Chandler, AZ`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreCrossConnectPortSpeedShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the port speed shape.  Example: `10 Gbps`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the port speed shape.  Example: `10 Gbps`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreCrossConnectsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDedicatedVmHostInstanceShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDedicatedVmHostShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDedicatedVmHostsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDedicatedVmHostsInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDhcpOptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDrgAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDrgRouteDistributionStatementsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDrgRouteDistributionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDrgRouteTableRouteRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDrgRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreDrgsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreFastConnectProviderServicesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreImageShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreInstanceConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreInstanceConsoleConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreInstanceDevicesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only devices that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only devices that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreInstancePoolInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreInstancePoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The plugin name. To get a list of available plugins, use the [ListInstanceagentAvailablePlugins](https://docs.cloud.oracle.com/iaas/api/#/en/instanceagent/20180530/Plugin/ListInstanceagentAvailablePlugins) operation in the Oracle Cloud Agent API. For more information about the available plugins, see [Managing Plugins with Oracle Cloud Agent](https://docs.cloud.oracle.com/iaas/Content/Compute/Tasks/manage-plugins.htm).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreInternetGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreIpsecConfigFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreIpsecConnectionTunnelsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreIpsecConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreIpsecStatusFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreIpv6sFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreListingResourceVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreLocalPeeringGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreNatGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreNetworkSecurityGroupSecurityRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreNetworkSecurityGroupVnicsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreNetworkSecurityGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCorePeerRegionForRemotePeeringsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The region's name.  Example: `us-phoenix-1`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The region's name.  Example: `us-phoenix-1`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCorePrivateIpsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCorePublicIpPoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCorePublicIpsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreRemotePeeringConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreRouteTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreSecurityListsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreServiceGatewaysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreServicesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the `Service` object. This name can change and is not guaranteed to be unique.  Example: `OCI PHX Object Storage`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the `Service` object. This name can change and is not guaranteed to be unique.  Example: `OCI PHX Object Storage`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreShapeFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape. You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape. You can enumerate all available shapes by calling [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Shape/ListShapes).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreSubnetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVcnsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVirtualCircuitBandwidthShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the bandwidth shape.  Example: `10 Gbps`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the bandwidth shape.  Example: `10 Gbps`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVirtualCircuitPublicPrefixesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVirtualCircuitsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVirtualNetworksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVlansFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVnicAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVolumeAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVolumeBackupPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVolumeBackupPolicyAssignmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVolumeBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVolumeGroupBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVolumeGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetCoreVolumesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataSafeDataSafePrivateEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataSafeOnPremConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataSafeTargetDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousContainerDatabaseDataguardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousContainerPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousDatabaseBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousDatabaseDataguardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousDatabasesClonesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousDbPreviewVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousDbVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousExadataInfrastructureShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the Autonomous Exadata Infrastructure.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseAutonomousVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseBackupDestinationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseCloudExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseCloudVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDataGuardAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDatabaseSoftwareImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDatabaseUpgradeHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbHomePatchHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbHomePatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbHomesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbNodeConsoleConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbNodesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbSystemPatchHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbSystemPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbSystemShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape used for the DB system.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape used for the DB system.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbSystemsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseDbVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseExadataInfrastructuresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the month of the year.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the month of the year.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseExternalContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseExternalDatabaseConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseExternalNonContainerDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseExternalPluggableDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseFlexComponentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given. The match is not case sensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseGiVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseKeyStoresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseMaintenanceRunsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseManagementManagedDatabaseGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name. Only one of the parameters, id or name should be provided
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name. Only one of the parameters, id or name should be provided
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseManagementManagedDatabasesDatabaseParametersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return all parameters that have the text given in their names.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return all parameters that have the text given in their names.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseManagementManagedDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseMigrationAgentImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseMigrationAgentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseMigrationConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseMigrationJobsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Phase name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Phase name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseMigrationMigrationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of directory object in database
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of directory object in database
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabasePluggableDatabasesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseVmClusterNetworksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseVmClusterPatchHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseVmClusterPatchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseVmClusterRecommendedNetworkNetworkArgs:
    def __init__(__self__, *,
                 cidr: str,
                 domain: str,
                 gateway: str,
                 netmask: str,
                 network_type: str,
                 prefix: str,
                 vlan_id: str):
        """
        :param str cidr: The cidr for the network.
        :param str domain: The network domain name.
        :param str gateway: The network gateway.
        :param str netmask: The network netmask.
        :param str network_type: The network type.
        :param str prefix: The network domain name.
        :param str vlan_id: The network VLAN ID.
        """
        pulumi.set(__self__, "cidr", cidr)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "network_type", network_type)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The cidr for the network.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: str):
        pulumi.set(self, "cidr", value)

    @property
    @pulumi.getter
    def domain(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: str):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: str):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The network netmask.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: str):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter(name="networkType")
    def network_type(self) -> str:
        """
        The network type.
        """
        return pulumi.get(self, "network_type")

    @network_type.setter
    def network_type(self, value: str):
        pulumi.set(self, "network_type", value)

    @property
    @pulumi.getter
    def prefix(self) -> str:
        """
        The network domain name.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: str):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> str:
        """
        The network VLAN ID.
        """
        return pulumi.get(self, "vlan_id")

    @vlan_id.setter
    def vlan_id(self, value: str):
        pulumi.set(self, "vlan_id", value)


@pulumi.input_type
class GetDatabaseVmClusterUpdateHistoryEntriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseVmClusterUpdatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatabaseVmClustersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatacatalogCatalogPrivateEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatacatalogCatalogTypesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Immutable resource name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Immutable resource name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatacatalogCatalogsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatacatalogConnectionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatacatalogDataAssetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatacatalogMetastoresFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataflowApplicationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataflowInvokeRunsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the parameter.  It must be a string of one or more word characters (a-z, A-Z, 0-9, _). Examples: "iterations", "input_file"
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataflowPrivateEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataflowRunLogsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDataintegrationWorkspacesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Used to filter by the name of the object.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Used to filter by the name of the object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatascienceModelDeploymentShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the model deployment shape.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the model deployment shape.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatascienceModelDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatascienceModelsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatascienceNotebookSessionShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the notebook session shape.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the notebook session shape.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatascienceNotebookSessionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDatascienceProjectsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDevopsDeployArtifactsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDevopsDeployEnvironmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDevopsDeployPipelinesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the parameter (case-sensitive). Parameter name must be ^[a-zA-Z][a-zA-Z_0-9]*$.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDevopsDeployStagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDevopsDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the step.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDevopsProjectsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsRecordsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsResolverEndpointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of a resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsResolversFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsSteeringPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for the answer, unique within the steering policy. An answer's `name` property can be referenced in `answerCondition` properties of rules using `answer.name`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsSteeringPolicyAttachmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsTsigKeysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of a resource.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsViewsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetDnsZonesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A case-sensitive filter for zone names. Will match any zone with a name that equals the provided value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A case-sensitive filter for zone names. Will match any zone with a name that equals the provided value.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetEmailDkimsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetEmailEmailDomainsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetEmailSendersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetEmailSuppressionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetEventsRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFileStorageExportSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFileStorageExportsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFileStorageFileSystemsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFileStorageMountTargetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFileStorageSnapshotsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the snapshot. This value is immutable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the snapshot. This value is immutable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFunctionsApplicationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetFunctionsFunctionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetGoldenGateDatabaseRegistrationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetGoldenGateDeploymentBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetGoldenGateDeploymentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetHealthChecksHttpMonitorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetHealthChecksHttpProbeResultsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetHealthChecksPingMonitorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetHealthChecksPingProbeResultsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetHealthChecksVantagePointsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Filters results that exactly match the `name` field.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Filters results that exactly match the `name` field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityApiKeysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityAuthTokensFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityAvailabilityDomainsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the Availability Domain.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Availability Domain.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityCompartmentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityCostTrackingTagsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name assigned to the tag during creation. This is the tag key definition. The name must be unique within the tag namespace and cannot be changed.
        :param Sequence[str] values: The list of allowed values for a definedTag value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name assigned to the tag during creation. This is the tag key definition. The name must be unique within the tag namespace and cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The list of allowed values for a definedTag value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityCustomerSecretKeysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityDynamicGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityFaultDomainsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the Fault Domain.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Fault Domain.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityIdentityProviderGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityIdentityProvidersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityIdpGroupMappingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityNetworkSourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityRegionSubscriptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityRegionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the region. See [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm) for the full list of supported region names.  Example: `us-phoenix-1`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the region. See [Regions and Availability Domains](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/regions.htm) for the full list of supported region names.  Example: `us-phoenix-1`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentitySmtpCredentialsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentitySwiftPasswordsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityTagDefaultsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityTagNamespacesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the tag namespace. It must be unique across all tag namespaces in the tenancy and cannot be changed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the tag namespace. It must be unique across all tag namespaces in the tenancy and cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityTagsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name assigned to the tag during creation. This is the tag key definition. The name must be unique within the tag namespace and cannot be changed.
        :param Sequence[str] values: The list of allowed values for a definedTag value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name assigned to the tag during creation. This is the tag key definition. The name must be unique within the tag namespace and cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The list of allowed values for a definedTag value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityUserGroupMembershipsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIdentityUsersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetIntegrationIntegrationInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetJmsFleetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetKmsKeyVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetKmsKeysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetKmsVaultReplicasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetKmsVaultsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLimitsLimitDefinitionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Optional field, filter for a specific resource limit.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional field, filter for a specific resource limit.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLimitsLimitValuesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Optional field, can be used to see a specific resource limit value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional field, can be used to see a specific resource limit value.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLimitsQuotasFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLimitsServicesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The service name. Use this when calling other APIs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The service name. Use this when calling other APIs.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerBackendSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A friendly name for the backend set. It must be unique and it cannot be changed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name for the backend set. It must be unique and it cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerBackendsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A read-only field showing the IP address and port that uniquely identify this backend server in the backend set.  Example: `10.0.0.3:8080`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A read-only field showing the IP address and port that uniquely identify this backend server in the backend set.  Example: `10.0.0.3:8080`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerCertificatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerHostnamesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A friendly name for the hostname resource. It must be unique and it cannot be changed. Avoid entering confidential information.  Example: `example_hostname_001`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name for the hostname resource. It must be unique and it cannot be changed. Avoid entering confidential information.  Example: `example_hostname_001`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerListenerRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the rule set that the rule belongs to.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the rule set that the rule belongs to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerLoadBalancerRoutingPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A unique name for the routing policy rule. Avoid entering confidential information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A unique name for the routing policy rule. Avoid entering confidential information.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerLoadBalancersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A unique name for the routing policy rule. Avoid entering confidential information.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A unique name for the routing policy rule. Avoid entering confidential information.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerPathRouteSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The unique name for this set of path route rules. Avoid entering confidential information.  Example: `example_path_route_set`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique name for this set of path route rules. Avoid entering confidential information.  Example: `example_path_route_set`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of a load balancing policy.  Example: 'LEAST_CONNECTIONS'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a load balancing policy.  Example: 'LEAST_CONNECTIONS'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerProtocolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of a protocol.  Example: 'HTTP'
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of a protocol.  Example: 'HTTP'
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerRuleSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name for this set of rules. It must be unique and it cannot be changed. Avoid entering confidential information.  Example: `example_rule_set`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for this set of rules. It must be unique and it cannot be changed. Avoid entering confidential information.  Example: `example_rule_set`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the shape.  Example: `100Mbps`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the shape.  Example: `100Mbps`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancerSslCipherSuitesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A friendly name for the SSL cipher suite. It must be unique and it cannot be changed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name for the SSL cipher suite. It must be unique and it cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoadBalancersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogAnalyticsLogAnalyticsEntitiesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only log analytics entities whose name matches the entire name given. The match is case-insensitive.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogAnalyticsLogAnalyticsLogGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogAnalyticsLogAnalyticsObjectCollectionRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return rules only matching with this name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return rules only matching with this name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLogAnalyticsNamespacesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoggingLogGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoggingLogSavedSearchesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Resource name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Resource name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoggingLogsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetLoggingUnifiedAgentConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name key to tag this grok pattern.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name key to tag this grok pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetManagementAgentManagementAgentAvailableHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetManagementAgentManagementAgentImagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the entire platform name given.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the entire platform name given.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetManagementAgentManagementAgentInstallKeysFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetManagementAgentManagementAgentPluginsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Management Agent Plugin Name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Management Agent Plugin Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetManagementAgentManagementAgentsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplaceAcceptedAgreementsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplaceCategoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the product category.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the product category.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplaceListingPackageAgreementsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplaceListingPackagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplaceListingTaxesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name of the tax code.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the tax code.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplaceListingsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the listing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the listing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplacePublicationPackagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplacePublicationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the listing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the listing.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMarketplacePublishersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the publisher.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the publisher.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMeteringComputationCustomTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMeteringComputationQueriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMonitoringAlarmStatusesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMonitoringAlarmsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMonitoringMetricDataFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the metric.  Example: `CpuUtilization`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the metric.  Example: `CpuUtilization`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMonitoringMetricsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The metric name to use when searching for metric definitions.  Example: `CpuUtilization`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The metric name to use when searching for metric definitions.  Example: `CpuUtilization`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMysqlChannelsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMysqlMysqlBackupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMysqlMysqlConfigurationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMysqlMysqlDbSystemsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMysqlMysqlVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetMysqlShapesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkLoadBalancerBackendSetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A user-friendly name for the backend set that must be unique and cannot be changed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A user-friendly name for the backend set that must be unique and cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkLoadBalancerBackendsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A read-only field showing the IP address/IP OCID and port that uniquely identify this backend server in the backend set.  Example: `10.0.0.3:8080`, or `ocid1.privateip..oc1.<var>&lt;unique_ID&gt;</var>:443` or `10.0.0.3:0`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A read-only field showing the IP address/IP OCID and port that uniquely identify this backend server in the backend set.  Example: `10.0.0.3:8080`, or `ocid1.privateip..oc1.<var>&lt;unique_ID&gt;</var>:443` or `10.0.0.3:0`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkLoadBalancerListenersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A friendly name for the listener. It must be unique and it cannot be changed.  Example: `example_listener`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A friendly name for the listener. It must be unique and it cannot be changed.  Example: `example_listener`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkLoadBalancerNetworkLoadBalancersFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkLoadBalancerNetworkLoadBalancersPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNetworkLoadBalancerNetworkLoadBalancersProtocolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNosqlIndexesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A shell-globbing-style (*?[]) filter for names.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A shell-globbing-style (*?[]) filter for names.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetNosqlTablesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A shell-globbing-style (*?[]) filter for names.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A shell-globbing-style (*?[]) filter for names.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetObjectstorageBucketSummariesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the bucket. Avoid entering confidential information. Example: my-new-bucket1
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the bucket. Avoid entering confidential information. Example: my-new-bucket1
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetObjectstorageObjectVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the object. Avoid entering confidential information. Example: test/object1.log
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the object. Avoid entering confidential information. Example: test/object1.log
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetObjectstorageObjectsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the object.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the object.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetObjectstoragePreauthrequestsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The user-provided name of the pre-authenticated request.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The user-provided name of the pre-authenticated request.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetObjectstorageReplicationPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the policy.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the policy.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetObjectstorageReplicationSourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOceOceInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: OceInstance Name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        OceInstance Name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOcvpEsxiHostsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOcvpSddcsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOcvpSupportedSkusFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: name of SKU
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        name of SKU
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOcvpSupportedVmwareSoftwareVersionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOdaOdaInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOnsNotificationTopicsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to only return resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to only return resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOnsSubscriptionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOpsiDatabaseInsightsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOpsiEnterpriseManagerBridgesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOpsiHostInsightsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOptimizerCategoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOptimizerEnrollmentStatusesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOptimizerHistoriesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOptimizerProfilesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOptimizerRecommendationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOptimizerResourceActionsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: Optional. A filter that returns results that match the name specified.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Optional. A filter that returns results that match the name specified.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOsmanagementManagedInstanceGroupsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOsmanagementManagedInstancesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: software source name
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        software source name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetOsmanagementSoftwareSourcesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetResourcemanagerStacksFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetSchServiceConnectorsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetServiceCatalogPrivateApplicationPackagesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetServiceCatalogPrivateApplicationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetServiceCatalogServiceCatalogAssociationsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetServiceCatalogServiceCatalogsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetStreamingConnectHarnessesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetStreamingStreamPoolsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetStreamingStreamsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: A filter to return only resources that match the given name exactly.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        A filter to return only resources that match the given name exactly.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVaultSecretsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The secret name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The secret name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVulnerabilityScanningHostScanRecipesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetVulnerabilityScanningHostScanTargetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWaasAddressListsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWaasCertificatesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The certificate extension name.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The certificate extension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWaasCustomProtectionRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWaasEdgeSubnetsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWaasHttpRedirectsFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWaasProtectionRulesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The name of the protection rule.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the protection rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GetWaasWaasPoliciesFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 regex: Optional[bool] = None):
        """
        :param str name: The unique name of the whitelist.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[bool]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[bool]):
        pulumi.set(self, "regex", value)


@pulumi.input_type
class GoldenGateDeploymentOggDataArgs:
    def __init__(__self__, *,
                 admin_password: pulumi.Input[str],
                 admin_username: pulumi.Input[str],
                 deployment_name: pulumi.Input[str],
                 certificate: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_password: (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as $, ^, or ? are not allowed.
        :param pulumi.Input[str] admin_username: (Updatable) The GoldenGate deployment console username.
        :param pulumi.Input[str] deployment_name: The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        :param pulumi.Input[str] certificate: (Updatable) A PEM-encoded SSL certificate.
        :param pulumi.Input[str] key: (Updatable) A PEM-encoded private key.
        """
        pulumi.set(__self__, "admin_password", admin_password)
        pulumi.set(__self__, "admin_username", admin_username)
        pulumi.set(__self__, "deployment_name", deployment_name)
        if certificate is not None:
            pulumi.set(__self__, "certificate", certificate)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter(name="adminPassword")
    def admin_password(self) -> pulumi.Input[str]:
        """
        (Updatable) The password associated with the GoldenGate deployment console username. The password must be 8 to 30 characters long and must contain at least 1 uppercase, 1 lowercase, 1 numeric, and 1 special character. Special characters such as $, ^, or ? are not allowed.
        """
        return pulumi.get(self, "admin_password")

    @admin_password.setter
    def admin_password(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_password", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> pulumi.Input[str]:
        """
        (Updatable) The GoldenGate deployment console username.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: pulumi.Input[str]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="deploymentName")
    def deployment_name(self) -> pulumi.Input[str]:
        """
        The name given to the GoldenGate service deployment. The name must be 1 to 32 characters long, must contain only alphanumeric characters and must start with a letter.
        """
        return pulumi.get(self, "deployment_name")

    @deployment_name.setter
    def deployment_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "deployment_name", value)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A PEM-encoded SSL certificate.
        """
        return pulumi.get(self, "certificate")

    @certificate.setter
    def certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A PEM-encoded private key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class IdentityAuthenticationPolicyNetworkPolicyArgs:
    def __init__(__self__, *,
                 network_source_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] network_source_ids: (Updatable) Network Source ids
        """
        if network_source_ids is not None:
            pulumi.set(__self__, "network_source_ids", network_source_ids)

    @property
    @pulumi.getter(name="networkSourceIds")
    def network_source_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Network Source ids
        """
        return pulumi.get(self, "network_source_ids")

    @network_source_ids.setter
    def network_source_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "network_source_ids", value)


@pulumi.input_type
class IdentityAuthenticationPolicyPasswordPolicyArgs:
    def __init__(__self__, *,
                 is_lowercase_characters_required: Optional[pulumi.Input[bool]] = None,
                 is_numeric_characters_required: Optional[pulumi.Input[bool]] = None,
                 is_special_characters_required: Optional[pulumi.Input[bool]] = None,
                 is_uppercase_characters_required: Optional[pulumi.Input[bool]] = None,
                 is_username_containment_allowed: Optional[pulumi.Input[bool]] = None,
                 minimum_password_length: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_lowercase_characters_required: (Updatable) At least one lower case character required.
        :param pulumi.Input[bool] is_numeric_characters_required: (Updatable) At least one numeric character required.
        :param pulumi.Input[bool] is_special_characters_required: (Updatable) At least one special character required.
        :param pulumi.Input[bool] is_uppercase_characters_required: (Updatable) At least one uppercase character required.
        :param pulumi.Input[bool] is_username_containment_allowed: (Updatable) User name is allowed to be part of the password.
        :param pulumi.Input[int] minimum_password_length: (Updatable) Minimum password length required.
        """
        if is_lowercase_characters_required is not None:
            pulumi.set(__self__, "is_lowercase_characters_required", is_lowercase_characters_required)
        if is_numeric_characters_required is not None:
            pulumi.set(__self__, "is_numeric_characters_required", is_numeric_characters_required)
        if is_special_characters_required is not None:
            pulumi.set(__self__, "is_special_characters_required", is_special_characters_required)
        if is_uppercase_characters_required is not None:
            pulumi.set(__self__, "is_uppercase_characters_required", is_uppercase_characters_required)
        if is_username_containment_allowed is not None:
            pulumi.set(__self__, "is_username_containment_allowed", is_username_containment_allowed)
        if minimum_password_length is not None:
            pulumi.set(__self__, "minimum_password_length", minimum_password_length)

    @property
    @pulumi.getter(name="isLowercaseCharactersRequired")
    def is_lowercase_characters_required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) At least one lower case character required.
        """
        return pulumi.get(self, "is_lowercase_characters_required")

    @is_lowercase_characters_required.setter
    def is_lowercase_characters_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_lowercase_characters_required", value)

    @property
    @pulumi.getter(name="isNumericCharactersRequired")
    def is_numeric_characters_required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) At least one numeric character required.
        """
        return pulumi.get(self, "is_numeric_characters_required")

    @is_numeric_characters_required.setter
    def is_numeric_characters_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_numeric_characters_required", value)

    @property
    @pulumi.getter(name="isSpecialCharactersRequired")
    def is_special_characters_required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) At least one special character required.
        """
        return pulumi.get(self, "is_special_characters_required")

    @is_special_characters_required.setter
    def is_special_characters_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_special_characters_required", value)

    @property
    @pulumi.getter(name="isUppercaseCharactersRequired")
    def is_uppercase_characters_required(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) At least one uppercase character required.
        """
        return pulumi.get(self, "is_uppercase_characters_required")

    @is_uppercase_characters_required.setter
    def is_uppercase_characters_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_uppercase_characters_required", value)

    @property
    @pulumi.getter(name="isUsernameContainmentAllowed")
    def is_username_containment_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) User name is allowed to be part of the password.
        """
        return pulumi.get(self, "is_username_containment_allowed")

    @is_username_containment_allowed.setter
    def is_username_containment_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_username_containment_allowed", value)

    @property
    @pulumi.getter(name="minimumPasswordLength")
    def minimum_password_length(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Minimum password length required.
        """
        return pulumi.get(self, "minimum_password_length")

    @minimum_password_length.setter
    def minimum_password_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_password_length", value)


@pulumi.input_type
class IdentityNetworkSourceVirtualSourceListArgs:
    def __init__(__self__, *,
                 ip_ranges: pulumi.Input[Sequence[pulumi.Input[str]]],
                 vcn_id: pulumi.Input[str]):
        pulumi.set(__self__, "ip_ranges", ip_ranges)
        pulumi.set(__self__, "vcn_id", vcn_id)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ip_ranges", value)

    @property
    @pulumi.getter(name="vcnId")
    def vcn_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vcn_id")

    @vcn_id.setter
    def vcn_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vcn_id", value)


@pulumi.input_type
class IdentityTagValidatorArgs:
    def __init__(__self__, *,
                 validator_type: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] validator_type: (Updatable) Specifies the type of validation: a static value (no validation) or a list.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Updatable) The list of allowed values for a definedTag value.
        """
        pulumi.set(__self__, "validator_type", validator_type)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="validatorType")
    def validator_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies the type of validation: a static value (no validation) or a list.
        """
        return pulumi.get(self, "validator_type")

    @validator_type.setter
    def validator_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "validator_type", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of allowed values for a definedTag value.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class IdentityUserCapabilitiesArgs:
    def __init__(__self__, *,
                 can_use_api_keys: Optional[pulumi.Input[bool]] = None,
                 can_use_auth_tokens: Optional[pulumi.Input[bool]] = None,
                 can_use_console_password: Optional[pulumi.Input[bool]] = None,
                 can_use_customer_secret_keys: Optional[pulumi.Input[bool]] = None,
                 can_use_oauth2client_credentials: Optional[pulumi.Input[bool]] = None,
                 can_use_smtp_credentials: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] can_use_api_keys: Indicates if the user can use API keys.
        :param pulumi.Input[bool] can_use_auth_tokens: Indicates if the user can use SWIFT passwords / auth tokens.
        :param pulumi.Input[bool] can_use_console_password: Indicates if the user can log in to the console.
        :param pulumi.Input[bool] can_use_customer_secret_keys: Indicates if the user can use SigV4 symmetric keys.
        :param pulumi.Input[bool] can_use_oauth2client_credentials: Indicates if the user can use OAuth2 credentials and tokens.
        :param pulumi.Input[bool] can_use_smtp_credentials: Indicates if the user can use SMTP passwords.
        """
        if can_use_api_keys is not None:
            pulumi.set(__self__, "can_use_api_keys", can_use_api_keys)
        if can_use_auth_tokens is not None:
            pulumi.set(__self__, "can_use_auth_tokens", can_use_auth_tokens)
        if can_use_console_password is not None:
            pulumi.set(__self__, "can_use_console_password", can_use_console_password)
        if can_use_customer_secret_keys is not None:
            pulumi.set(__self__, "can_use_customer_secret_keys", can_use_customer_secret_keys)
        if can_use_oauth2client_credentials is not None:
            pulumi.set(__self__, "can_use_oauth2client_credentials", can_use_oauth2client_credentials)
        if can_use_smtp_credentials is not None:
            pulumi.set(__self__, "can_use_smtp_credentials", can_use_smtp_credentials)

    @property
    @pulumi.getter(name="canUseApiKeys")
    def can_use_api_keys(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the user can use API keys.
        """
        return pulumi.get(self, "can_use_api_keys")

    @can_use_api_keys.setter
    def can_use_api_keys(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_use_api_keys", value)

    @property
    @pulumi.getter(name="canUseAuthTokens")
    def can_use_auth_tokens(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the user can use SWIFT passwords / auth tokens.
        """
        return pulumi.get(self, "can_use_auth_tokens")

    @can_use_auth_tokens.setter
    def can_use_auth_tokens(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_use_auth_tokens", value)

    @property
    @pulumi.getter(name="canUseConsolePassword")
    def can_use_console_password(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the user can log in to the console.
        """
        return pulumi.get(self, "can_use_console_password")

    @can_use_console_password.setter
    def can_use_console_password(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_use_console_password", value)

    @property
    @pulumi.getter(name="canUseCustomerSecretKeys")
    def can_use_customer_secret_keys(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the user can use SigV4 symmetric keys.
        """
        return pulumi.get(self, "can_use_customer_secret_keys")

    @can_use_customer_secret_keys.setter
    def can_use_customer_secret_keys(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_use_customer_secret_keys", value)

    @property
    @pulumi.getter(name="canUseOauth2clientCredentials")
    def can_use_oauth2client_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the user can use OAuth2 credentials and tokens.
        """
        return pulumi.get(self, "can_use_oauth2client_credentials")

    @can_use_oauth2client_credentials.setter
    def can_use_oauth2client_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_use_oauth2client_credentials", value)

    @property
    @pulumi.getter(name="canUseSmtpCredentials")
    def can_use_smtp_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if the user can use SMTP passwords.
        """
        return pulumi.get(self, "can_use_smtp_credentials")

    @can_use_smtp_credentials.setter
    def can_use_smtp_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_use_smtp_credentials", value)


@pulumi.input_type
class IntegrationIntegrationInstanceAlternateCustomEndpointArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 certificate_secret_id: Optional[pulumi.Input[str]] = None,
                 certificate_secret_version: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) A custom hostname to be used for the integration instance URL, in FQDN format.
        :param pulumi.Input[str] certificate_secret_id: (Updatable) Optional OCID of a vault/secret containing a private SSL certificate bundle to be used for the custom hostname. All certificates should be stored in a single base64 encoded secret Note the update will fail if this is not a valid certificate.
        :param pulumi.Input[int] certificate_secret_version: The secret version used for the certificate-secret-id (if certificate-secret-id is specified).
        """
        pulumi.set(__self__, "hostname", hostname)
        if certificate_secret_id is not None:
            pulumi.set(__self__, "certificate_secret_id", certificate_secret_id)
        if certificate_secret_version is not None:
            pulumi.set(__self__, "certificate_secret_version", certificate_secret_version)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) A custom hostname to be used for the integration instance URL, in FQDN format.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="certificateSecretId")
    def certificate_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Optional OCID of a vault/secret containing a private SSL certificate bundle to be used for the custom hostname. All certificates should be stored in a single base64 encoded secret Note the update will fail if this is not a valid certificate.
        """
        return pulumi.get(self, "certificate_secret_id")

    @certificate_secret_id.setter
    def certificate_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_secret_id", value)

    @property
    @pulumi.getter(name="certificateSecretVersion")
    def certificate_secret_version(self) -> Optional[pulumi.Input[int]]:
        """
        The secret version used for the certificate-secret-id (if certificate-secret-id is specified).
        """
        return pulumi.get(self, "certificate_secret_version")

    @certificate_secret_version.setter
    def certificate_secret_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "certificate_secret_version", value)


@pulumi.input_type
class IntegrationIntegrationInstanceCustomEndpointArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 certificate_secret_id: Optional[pulumi.Input[str]] = None,
                 certificate_secret_version: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) A custom hostname to be used for the integration instance URL, in FQDN format.
        :param pulumi.Input[str] certificate_secret_id: (Updatable) Optional OCID of a vault/secret containing a private SSL certificate bundle to be used for the custom hostname. All certificates should be stored in a single base64 encoded secret Note the update will fail if this is not a valid certificate.
        :param pulumi.Input[int] certificate_secret_version: The secret version used for the certificate-secret-id (if certificate-secret-id is specified).
        """
        pulumi.set(__self__, "hostname", hostname)
        if certificate_secret_id is not None:
            pulumi.set(__self__, "certificate_secret_id", certificate_secret_id)
        if certificate_secret_version is not None:
            pulumi.set(__self__, "certificate_secret_version", certificate_secret_version)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) A custom hostname to be used for the integration instance URL, in FQDN format.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="certificateSecretId")
    def certificate_secret_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Optional OCID of a vault/secret containing a private SSL certificate bundle to be used for the custom hostname. All certificates should be stored in a single base64 encoded secret Note the update will fail if this is not a valid certificate.
        """
        return pulumi.get(self, "certificate_secret_id")

    @certificate_secret_id.setter
    def certificate_secret_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_secret_id", value)

    @property
    @pulumi.getter(name="certificateSecretVersion")
    def certificate_secret_version(self) -> Optional[pulumi.Input[int]]:
        """
        The secret version used for the certificate-secret-id (if certificate-secret-id is specified).
        """
        return pulumi.get(self, "certificate_secret_version")

    @certificate_secret_version.setter
    def certificate_secret_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "certificate_secret_version", value)


@pulumi.input_type
class IntegrationIntegrationInstanceNetworkEndpointDetailsArgs:
    def __init__(__self__, *,
                 network_endpoint_type: pulumi.Input[str],
                 allowlisted_http_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allowlisted_http_vcns: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationIntegrationInstanceNetworkEndpointDetailsAllowlistedHttpVcnArgs']]]] = None,
                 is_integration_vcn_allowlisted: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] network_endpoint_type: The type of network endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowlisted_http_ips: Source IP addresses or IP address ranges ingress rules.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationIntegrationInstanceNetworkEndpointDetailsAllowlistedHttpVcnArgs']]] allowlisted_http_vcns: Virtual Cloud Networks allowed to access this network endpoint.
        :param pulumi.Input[bool] is_integration_vcn_allowlisted: The Integration service's VCN is allow-listed to allow integrations to call back into other integrations
        """
        pulumi.set(__self__, "network_endpoint_type", network_endpoint_type)
        if allowlisted_http_ips is not None:
            pulumi.set(__self__, "allowlisted_http_ips", allowlisted_http_ips)
        if allowlisted_http_vcns is not None:
            pulumi.set(__self__, "allowlisted_http_vcns", allowlisted_http_vcns)
        if is_integration_vcn_allowlisted is not None:
            pulumi.set(__self__, "is_integration_vcn_allowlisted", is_integration_vcn_allowlisted)

    @property
    @pulumi.getter(name="networkEndpointType")
    def network_endpoint_type(self) -> pulumi.Input[str]:
        """
        The type of network endpoint.
        """
        return pulumi.get(self, "network_endpoint_type")

    @network_endpoint_type.setter
    def network_endpoint_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "network_endpoint_type", value)

    @property
    @pulumi.getter(name="allowlistedHttpIps")
    def allowlisted_http_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Source IP addresses or IP address ranges ingress rules.
        """
        return pulumi.get(self, "allowlisted_http_ips")

    @allowlisted_http_ips.setter
    def allowlisted_http_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowlisted_http_ips", value)

    @property
    @pulumi.getter(name="allowlistedHttpVcns")
    def allowlisted_http_vcns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationIntegrationInstanceNetworkEndpointDetailsAllowlistedHttpVcnArgs']]]]:
        """
        Virtual Cloud Networks allowed to access this network endpoint.
        """
        return pulumi.get(self, "allowlisted_http_vcns")

    @allowlisted_http_vcns.setter
    def allowlisted_http_vcns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationIntegrationInstanceNetworkEndpointDetailsAllowlistedHttpVcnArgs']]]]):
        pulumi.set(self, "allowlisted_http_vcns", value)

    @property
    @pulumi.getter(name="isIntegrationVcnAllowlisted")
    def is_integration_vcn_allowlisted(self) -> Optional[pulumi.Input[bool]]:
        """
        The Integration service's VCN is allow-listed to allow integrations to call back into other integrations
        """
        return pulumi.get(self, "is_integration_vcn_allowlisted")

    @is_integration_vcn_allowlisted.setter
    def is_integration_vcn_allowlisted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_integration_vcn_allowlisted", value)


@pulumi.input_type
class IntegrationIntegrationInstanceNetworkEndpointDetailsAllowlistedHttpVcnArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 allowlisted_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] id: The Virtual Cloud Network OCID.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowlisted_ips: Source IP addresses or IP address ranges ingress rules.
        """
        pulumi.set(__self__, "id", id)
        if allowlisted_ips is not None:
            pulumi.set(__self__, "allowlisted_ips", allowlisted_ips)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The Virtual Cloud Network OCID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="allowlistedIps")
    def allowlisted_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Source IP addresses or IP address ranges ingress rules.
        """
        return pulumi.get(self, "allowlisted_ips")

    @allowlisted_ips.setter
    def allowlisted_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowlisted_ips", value)


@pulumi.input_type
class KmsGeneratedKeyKeyShapeArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[str],
                 length: pulumi.Input[int],
                 curve_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: The algorithm used by a key's key versions to encrypt or decrypt.
        :param pulumi.Input[int] length: The length of the key in bytes, expressed as an integer. Supported values include the following:
               * AES: 16, 24, or 32
               * RSA: 256, 384, or 512
               * ECDSA: 32, 48, or 66
        :param pulumi.Input[str] curve_id: Supported curve IDs for ECDSA keys.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "length", length)
        if curve_id is not None:
            pulumi.set(__self__, "curve_id", curve_id)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[str]:
        """
        The algorithm used by a key's key versions to encrypt or decrypt.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        The length of the key in bytes, expressed as an integer. Supported values include the following:
        * AES: 16, 24, or 32
        * RSA: 256, 384, or 512
        * ECDSA: 32, 48, or 66
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter(name="curveId")
    def curve_id(self) -> Optional[pulumi.Input[str]]:
        """
        Supported curve IDs for ECDSA keys.
        """
        return pulumi.get(self, "curve_id")

    @curve_id.setter
    def curve_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "curve_id", value)


@pulumi.input_type
class KmsKeyKeyShapeArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input[str],
                 length: pulumi.Input[int],
                 curve_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: The algorithm used by a key's key versions to encrypt or decrypt.
        :param pulumi.Input[int] length: The length of the key in bytes, expressed as an integer. Supported values include the following:
               * AES: 16, 24, or 32
               * RSA: 256, 384, or 512
               * ECDSA: 32, 48, or 66
        :param pulumi.Input[str] curve_id: Supported curve IDs for ECDSA keys.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "length", length)
        if curve_id is not None:
            pulumi.set(__self__, "curve_id", curve_id)

    @property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input[str]:
        """
        The algorithm used by a key's key versions to encrypt or decrypt.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def length(self) -> pulumi.Input[int]:
        """
        The length of the key in bytes, expressed as an integer. Supported values include the following:
        * AES: 16, 24, or 32
        * RSA: 256, 384, or 512
        * ECDSA: 32, 48, or 66
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[int]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter(name="curveId")
    def curve_id(self) -> Optional[pulumi.Input[str]]:
        """
        Supported curve IDs for ECDSA keys.
        """
        return pulumi.get(self, "curve_id")

    @curve_id.setter
    def curve_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "curve_id", value)


@pulumi.input_type
class KmsKeyReplicaDetailsArgs:
    def __init__(__self__, *,
                 replication_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] replication_id: ReplicationId associated with a key operation
        """
        if replication_id is not None:
            pulumi.set(__self__, "replication_id", replication_id)

    @property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> Optional[pulumi.Input[str]]:
        """
        ReplicationId associated with a key operation
        """
        return pulumi.get(self, "replication_id")

    @replication_id.setter
    def replication_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_id", value)


@pulumi.input_type
class KmsKeyRestoreFromFileArgs:
    def __init__(__self__, *,
                 content_length: pulumi.Input[str],
                 restore_key_from_file_details: pulumi.Input[str],
                 content_md5: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_length: (Updatable) content length of key's backup binary file
        :param pulumi.Input[str] restore_key_from_file_details: Key backup file content.
        :param pulumi.Input[str] content_md5: (Updatable) content md5 hashed value of key's backup file
        """
        pulumi.set(__self__, "content_length", content_length)
        pulumi.set(__self__, "restore_key_from_file_details", restore_key_from_file_details)
        if content_md5 is not None:
            pulumi.set(__self__, "content_md5", content_md5)

    @property
    @pulumi.getter(name="contentLength")
    def content_length(self) -> pulumi.Input[str]:
        """
        (Updatable) content length of key's backup binary file
        """
        return pulumi.get(self, "content_length")

    @content_length.setter
    def content_length(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_length", value)

    @property
    @pulumi.getter(name="restoreKeyFromFileDetails")
    def restore_key_from_file_details(self) -> pulumi.Input[str]:
        """
        Key backup file content.
        """
        return pulumi.get(self, "restore_key_from_file_details")

    @restore_key_from_file_details.setter
    def restore_key_from_file_details(self, value: pulumi.Input[str]):
        pulumi.set(self, "restore_key_from_file_details", value)

    @property
    @pulumi.getter(name="contentMd5")
    def content_md5(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) content md5 hashed value of key's backup file
        """
        return pulumi.get(self, "content_md5")

    @content_md5.setter
    def content_md5(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_md5", value)


@pulumi.input_type
class KmsKeyRestoreFromObjectStoreArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 bucket: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 object: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: (Updatable) Type of backup to restore from. Values of "BUCKET", "PRE_AUTHENTICATED_REQUEST_URI" are supported
        :param pulumi.Input[str] bucket: (Updatable) Name of the bucket where key was backed up
        :param pulumi.Input[str] namespace: (Updatable) Namespace of the bucket where key was backed up
        :param pulumi.Input[str] object: (Updatable) Object containing the backup
        :param pulumi.Input[str] uri: (Updatable) Pre-authenticated-request-uri of the backup
        """
        pulumi.set(__self__, "destination", destination)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of backup to restore from. Values of "BUCKET", "PRE_AUTHENTICATED_REQUEST_URI" are supported
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the bucket where key was backed up
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Namespace of the bucket where key was backed up
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Object containing the backup
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Pre-authenticated-request-uri of the backup
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class KmsKeyVersionReplicaDetailsArgs:
    def __init__(__self__, *,
                 replication_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] replication_id: ReplicationId associated with a key version operation
        """
        if replication_id is not None:
            pulumi.set(__self__, "replication_id", replication_id)

    @property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> Optional[pulumi.Input[str]]:
        """
        ReplicationId associated with a key version operation
        """
        return pulumi.get(self, "replication_id")

    @replication_id.setter
    def replication_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_id", value)


@pulumi.input_type
class KmsVaultReplicaDetailsArgs:
    def __init__(__self__, *,
                 replication_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] replication_id: ReplicationId associated with a vault operation
        """
        if replication_id is not None:
            pulumi.set(__self__, "replication_id", replication_id)

    @property
    @pulumi.getter(name="replicationId")
    def replication_id(self) -> Optional[pulumi.Input[str]]:
        """
        ReplicationId associated with a vault operation
        """
        return pulumi.get(self, "replication_id")

    @replication_id.setter
    def replication_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_id", value)


@pulumi.input_type
class KmsVaultRestoreFromFileArgs:
    def __init__(__self__, *,
                 content_length: pulumi.Input[str],
                 restore_vault_from_file_details: pulumi.Input[str],
                 content_md5: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_length: content length of vault's backup binary file
        :param pulumi.Input[str] restore_vault_from_file_details: Vault backup file content
        :param pulumi.Input[str] content_md5: (Updatable) content md5 hashed value of vault's backup file
        """
        pulumi.set(__self__, "content_length", content_length)
        pulumi.set(__self__, "restore_vault_from_file_details", restore_vault_from_file_details)
        if content_md5 is not None:
            pulumi.set(__self__, "content_md5", content_md5)

    @property
    @pulumi.getter(name="contentLength")
    def content_length(self) -> pulumi.Input[str]:
        """
        content length of vault's backup binary file
        """
        return pulumi.get(self, "content_length")

    @content_length.setter
    def content_length(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_length", value)

    @property
    @pulumi.getter(name="restoreVaultFromFileDetails")
    def restore_vault_from_file_details(self) -> pulumi.Input[str]:
        """
        Vault backup file content
        """
        return pulumi.get(self, "restore_vault_from_file_details")

    @restore_vault_from_file_details.setter
    def restore_vault_from_file_details(self, value: pulumi.Input[str]):
        pulumi.set(self, "restore_vault_from_file_details", value)

    @property
    @pulumi.getter(name="contentMd5")
    def content_md5(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) content md5 hashed value of vault's backup file
        """
        return pulumi.get(self, "content_md5")

    @content_md5.setter
    def content_md5(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_md5", value)


@pulumi.input_type
class KmsVaultRestoreFromObjectStoreArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 bucket: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 object: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination: (Updatable) Type of backup to restore from. Values of "BUCKET", "PRE_AUTHENTICATED_REQUEST_URI" are supported
        :param pulumi.Input[str] bucket: (Updatable) Name of the bucket where vault was backed up
        :param pulumi.Input[str] namespace: (Updatable) Namespace of the bucket where vault was backed up
        :param pulumi.Input[str] object: (Updatable) Object containing the backup
        :param pulumi.Input[str] uri: (Updatable) Pre-authenticated-request-uri of the backup* `restore_trigger` - (Optional) (Updatable) An optional property when flipped triggers restore from restore option provided in config file.
        """
        pulumi.set(__self__, "destination", destination)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object is not None:
            pulumi.set(__self__, "object", object)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of backup to restore from. Values of "BUCKET", "PRE_AUTHENTICATED_REQUEST_URI" are supported
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the bucket where vault was backed up
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Namespace of the bucket where vault was backed up
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Object containing the backup
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Pre-authenticated-request-uri of the backup* `restore_trigger` - (Optional) (Updatable) An optional property when flipped triggers restore from restore option provided in config file.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class LoadBalancerBackendSetBackendArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[str],
                 port: pulumi.Input[int],
                 backup: Optional[pulumi.Input[bool]] = None,
                 drain: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 offline: Optional[pulumi.Input[bool]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ip_address: The IP address of the backend server.  Example: `10.0.0.3`
        :param pulumi.Input[int] port: (Updatable) The backend server port against which to run the health check. If the port is not specified, the load balancer uses the port information from the `Backend` object.  Example: `8080`
        :param pulumi.Input[bool] backup: Whether the load balancer should treat this server as a backup unit. If `true`, the load balancer forwards no ingress traffic to this backend server unless all other backend servers not marked as "backup" fail the health check policy.
        :param pulumi.Input[bool] drain: Whether the load balancer should drain this server. Servers marked "drain" receive no new incoming traffic.  Example: `false`
        :param pulumi.Input[str] name: A friendly name for the backend set. It must be unique and it cannot be changed.
        :param pulumi.Input[bool] offline: Whether the load balancer should treat this server as offline. Offline servers receive no incoming traffic.  Example: `false`
        :param pulumi.Input[int] weight: The load balancing policy weight assigned to the server. Backend servers with a higher weight receive a larger proportion of incoming traffic. For example, a server weighted '3' receives 3 times the number of new connections as a server weighted '1'. For more information on load balancing policies, see [How Load Balancing Policies Work](https://docs.cloud.oracle.com/iaas/Content/Balance/Reference/lbpolicies.htm).  Example: `3`
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "port", port)
        if backup is not None:
            pulumi.set(__self__, "backup", backup)
        if drain is not None:
            pulumi.set(__self__, "drain", drain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if offline is not None:
            pulumi.set(__self__, "offline", offline)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        """
        The IP address of the backend server.  Example: `10.0.0.3`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        (Updatable) The backend server port against which to run the health check. If the port is not specified, the load balancer uses the port information from the `Backend` object.  Example: `8080`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the load balancer should treat this server as a backup unit. If `true`, the load balancer forwards no ingress traffic to this backend server unless all other backend servers not marked as "backup" fail the health check policy.
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter
    def drain(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the load balancer should drain this server. Servers marked "drain" receive no new incoming traffic.  Example: `false`
        """
        return pulumi.get(self, "drain")

    @drain.setter
    def drain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A friendly name for the backend set. It must be unique and it cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def offline(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the load balancer should treat this server as offline. Offline servers receive no incoming traffic.  Example: `false`
        """
        return pulumi.get(self, "offline")

    @offline.setter
    def offline(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "offline", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The load balancing policy weight assigned to the server. Backend servers with a higher weight receive a larger proportion of incoming traffic. For example, a server weighted '3' receives 3 times the number of new connections as a server weighted '1'. For more information on load balancing policies, see [How Load Balancing Policies Work](https://docs.cloud.oracle.com/iaas/Content/Balance/Reference/lbpolicies.htm).  Example: `3`
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class LoadBalancerBackendSetHealthCheckerArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 interval_ms: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 response_body_regex: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 return_code: Optional[pulumi.Input[int]] = None,
                 timeout_in_millis: Optional[pulumi.Input[int]] = None,
                 url_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: (Updatable) The protocol the health check must use; either HTTP or TCP.  Example: `HTTP`
        :param pulumi.Input[int] interval_ms: (Updatable) The interval between health checks, in milliseconds.  Example: `10000`
        :param pulumi.Input[int] port: (Updatable) The backend server port against which to run the health check. If the port is not specified, the load balancer uses the port information from the `Backend` object.  Example: `8080`
        :param pulumi.Input[str] response_body_regex: (Updatable) A regular expression for parsing the response body from the backend server.  Example: `^((?!false).|\s)*$`
        :param pulumi.Input[int] retries: (Updatable) The number of retries to attempt before a backend server is considered "unhealthy". This number also applies when recovering a server to the "healthy" state.  Example: `3`
        :param pulumi.Input[int] return_code: (Updatable) The status code a healthy backend server should return.  Example: `200`
        :param pulumi.Input[int] timeout_in_millis: (Updatable) The maximum time, in milliseconds, to wait for a reply to a health check. A health check is successful only if a reply returns within this timeout period.  Example: `3000`
        :param pulumi.Input[str] url_path: (Updatable) The path against which to run the health check.  Example: `/healthcheck`
        """
        pulumi.set(__self__, "protocol", protocol)
        if interval_ms is not None:
            pulumi.set(__self__, "interval_ms", interval_ms)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if response_body_regex is not None:
            pulumi.set(__self__, "response_body_regex", response_body_regex)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if return_code is not None:
            pulumi.set(__self__, "return_code", return_code)
        if timeout_in_millis is not None:
            pulumi.set(__self__, "timeout_in_millis", timeout_in_millis)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The protocol the health check must use; either HTTP or TCP.  Example: `HTTP`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="intervalMs")
    def interval_ms(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The interval between health checks, in milliseconds.  Example: `10000`
        """
        return pulumi.get(self, "interval_ms")

    @interval_ms.setter
    def interval_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_ms", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The backend server port against which to run the health check. If the port is not specified, the load balancer uses the port information from the `Backend` object.  Example: `8080`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="responseBodyRegex")
    def response_body_regex(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A regular expression for parsing the response body from the backend server.  Example: `^((?!false).|\s)*$`
        """
        return pulumi.get(self, "response_body_regex")

    @response_body_regex.setter
    def response_body_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_body_regex", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of retries to attempt before a backend server is considered "unhealthy". This number also applies when recovering a server to the "healthy" state.  Example: `3`
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="returnCode")
    def return_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The status code a healthy backend server should return.  Example: `200`
        """
        return pulumi.get(self, "return_code")

    @return_code.setter
    def return_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "return_code", value)

    @property
    @pulumi.getter(name="timeoutInMillis")
    def timeout_in_millis(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum time, in milliseconds, to wait for a reply to a health check. A health check is successful only if a reply returns within this timeout period.  Example: `3000`
        """
        return pulumi.get(self, "timeout_in_millis")

    @timeout_in_millis.setter
    def timeout_in_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_millis", value)

    @property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The path against which to run the health check.  Example: `/healthcheck`
        """
        return pulumi.get(self, "url_path")

    @url_path.setter
    def url_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_path", value)


@pulumi.input_type
class LoadBalancerBackendSetLbCookieSessionPersistenceConfigurationArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[str]] = None,
                 disable_fallback: Optional[pulumi.Input[bool]] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 is_http_only: Optional[pulumi.Input[bool]] = None,
                 is_secure: Optional[pulumi.Input[bool]] = None,
                 max_age_in_seconds: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cookie_name: (Updatable) The name of the cookie used to detect a session initiated by the backend server. Use '*' to specify that any cookie set by the backend causes the session to persist.  Example: `example_cookie`
        :param pulumi.Input[bool] disable_fallback: (Updatable) Whether the load balancer is prevented from directing traffic from a persistent session client to a different backend server if the original server is unavailable. Defaults to false.  Example: `false`
        :param pulumi.Input[str] domain: (Updatable) The domain in which the cookie is valid. The `Set-cookie` header inserted by the load balancer contains a domain attribute with the specified value.
        :param pulumi.Input[bool] is_http_only: (Updatable) Whether the `Set-cookie` header should contain the `HttpOnly` attribute. If `true`, the `Set-cookie` header inserted by the load balancer contains the `HttpOnly` attribute, which limits the scope of the cookie to HTTP requests. This attribute directs the client or browser to omit the cookie when providing access to cookies through non-HTTP APIs. For example, it restricts the cookie from JavaScript channels.  Example: `true`
        :param pulumi.Input[bool] is_secure: (Updatable) Whether the `Set-cookie` header should contain the `Secure` attribute. If `true`, the `Set-cookie` header inserted by the load balancer contains the `Secure` attribute, which directs the client or browser to send the cookie only using a secure protocol.
        :param pulumi.Input[int] max_age_in_seconds: (Updatable) The amount of time the cookie remains valid. The `Set-cookie` header inserted by the load balancer contains a `Max-Age` attribute with the specified value.
        :param pulumi.Input[str] path: (Updatable) The path in which the cookie is valid. The `Set-cookie header` inserted by the load balancer contains a `Path` attribute with the specified value.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if disable_fallback is not None:
            pulumi.set(__self__, "disable_fallback", disable_fallback)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if is_http_only is not None:
            pulumi.set(__self__, "is_http_only", is_http_only)
        if is_secure is not None:
            pulumi.set(__self__, "is_secure", is_secure)
        if max_age_in_seconds is not None:
            pulumi.set(__self__, "max_age_in_seconds", max_age_in_seconds)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the cookie used to detect a session initiated by the backend server. Use '*' to specify that any cookie set by the backend causes the session to persist.  Example: `example_cookie`
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="disableFallback")
    def disable_fallback(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the load balancer is prevented from directing traffic from a persistent session client to a different backend server if the original server is unavailable. Defaults to false.  Example: `false`
        """
        return pulumi.get(self, "disable_fallback")

    @disable_fallback.setter
    def disable_fallback(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_fallback", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The domain in which the cookie is valid. The `Set-cookie` header inserted by the load balancer contains a domain attribute with the specified value.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="isHttpOnly")
    def is_http_only(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the `Set-cookie` header should contain the `HttpOnly` attribute. If `true`, the `Set-cookie` header inserted by the load balancer contains the `HttpOnly` attribute, which limits the scope of the cookie to HTTP requests. This attribute directs the client or browser to omit the cookie when providing access to cookies through non-HTTP APIs. For example, it restricts the cookie from JavaScript channels.  Example: `true`
        """
        return pulumi.get(self, "is_http_only")

    @is_http_only.setter
    def is_http_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_http_only", value)

    @property
    @pulumi.getter(name="isSecure")
    def is_secure(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the `Set-cookie` header should contain the `Secure` attribute. If `true`, the `Set-cookie` header inserted by the load balancer contains the `Secure` attribute, which directs the client or browser to send the cookie only using a secure protocol.
        """
        return pulumi.get(self, "is_secure")

    @is_secure.setter
    def is_secure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_secure", value)

    @property
    @pulumi.getter(name="maxAgeInSeconds")
    def max_age_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The amount of time the cookie remains valid. The `Set-cookie` header inserted by the load balancer contains a `Max-Age` attribute with the specified value.
        """
        return pulumi.get(self, "max_age_in_seconds")

    @max_age_in_seconds.setter
    def max_age_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_in_seconds", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The path in which the cookie is valid. The `Set-cookie header` inserted by the load balancer contains a `Path` attribute with the specified value.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


@pulumi.input_type
class LoadBalancerBackendSetSessionPersistenceConfigurationArgs:
    def __init__(__self__, *,
                 cookie_name: pulumi.Input[str],
                 disable_fallback: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cookie_name: (Updatable) The name of the cookie used to detect a session initiated by the backend server. Use '*' to specify that any cookie set by the backend causes the session to persist.  Example: `example_cookie`
        :param pulumi.Input[bool] disable_fallback: (Updatable) Whether the load balancer is prevented from directing traffic from a persistent session client to a different backend server if the original server is unavailable. Defaults to false.  Example: `false`
        """
        pulumi.set(__self__, "cookie_name", cookie_name)
        if disable_fallback is not None:
            pulumi.set(__self__, "disable_fallback", disable_fallback)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the cookie used to detect a session initiated by the backend server. Use '*' to specify that any cookie set by the backend causes the session to persist.  Example: `example_cookie`
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="disableFallback")
    def disable_fallback(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the load balancer is prevented from directing traffic from a persistent session client to a different backend server if the original server is unavailable. Defaults to false.  Example: `false`
        """
        return pulumi.get(self, "disable_fallback")

    @disable_fallback.setter
    def disable_fallback(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_fallback", value)


@pulumi.input_type
class LoadBalancerBackendSetSslConfigurationArgs:
    def __init__(__self__, *,
                 certificate_name: pulumi.Input[str],
                 cipher_suite_name: Optional[pulumi.Input[str]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_order_preference: Optional[pulumi.Input[str]] = None,
                 verify_depth: Optional[pulumi.Input[int]] = None,
                 verify_peer_certificate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] certificate_name: (Updatable) A friendly name for the certificate bundle. It must be unique and it cannot be changed. Valid certificate bundle names include only alphanumeric characters, dashes, and underscores. Certificate bundle names cannot contain spaces. Avoid entering confidential information.  Example: `example_certificate_bundle`
        :param pulumi.Input[str] cipher_suite_name: (Updatable) The name of the cipher suite to use for HTTPS or SSL connections.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: (Updatable) A list of SSL protocols the load balancer must support for HTTPS or SSL connections.
        :param pulumi.Input[str] server_order_preference: (Updatable) When this attribute is set to ENABLED, the system gives preference to the server ciphers over the client ciphers.
        :param pulumi.Input[int] verify_depth: (Updatable) The maximum depth for peer certificate chain verification.  Example: `3`
        :param pulumi.Input[bool] verify_peer_certificate: (Updatable) Whether the load balancer listener should verify peer certificates.  Example: `true`
        """
        pulumi.set(__self__, "certificate_name", certificate_name)
        if cipher_suite_name is not None:
            pulumi.set(__self__, "cipher_suite_name", cipher_suite_name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if server_order_preference is not None:
            pulumi.set(__self__, "server_order_preference", server_order_preference)
        if verify_depth is not None:
            pulumi.set(__self__, "verify_depth", verify_depth)
        if verify_peer_certificate is not None:
            pulumi.set(__self__, "verify_peer_certificate", verify_peer_certificate)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> pulumi.Input[str]:
        """
        (Updatable) A friendly name for the certificate bundle. It must be unique and it cannot be changed. Valid certificate bundle names include only alphanumeric characters, dashes, and underscores. Certificate bundle names cannot contain spaces. Avoid entering confidential information.  Example: `example_certificate_bundle`
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_name", value)

    @property
    @pulumi.getter(name="cipherSuiteName")
    def cipher_suite_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the cipher suite to use for HTTPS or SSL connections.
        """
        return pulumi.get(self, "cipher_suite_name")

    @cipher_suite_name.setter
    def cipher_suite_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cipher_suite_name", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of SSL protocols the load balancer must support for HTTPS or SSL connections.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="serverOrderPreference")
    def server_order_preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) When this attribute is set to ENABLED, the system gives preference to the server ciphers over the client ciphers.
        """
        return pulumi.get(self, "server_order_preference")

    @server_order_preference.setter
    def server_order_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_order_preference", value)

    @property
    @pulumi.getter(name="verifyDepth")
    def verify_depth(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum depth for peer certificate chain verification.  Example: `3`
        """
        return pulumi.get(self, "verify_depth")

    @verify_depth.setter
    def verify_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "verify_depth", value)

    @property
    @pulumi.getter(name="verifyPeerCertificate")
    def verify_peer_certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the load balancer listener should verify peer certificates.  Example: `true`
        """
        return pulumi.get(self, "verify_peer_certificate")

    @verify_peer_certificate.setter
    def verify_peer_certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify_peer_certificate", value)


@pulumi.input_type
class LoadBalancerIpAddressDetailArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 is_public: Optional[pulumi.Input[bool]] = None,
                 reserved_ip: Optional[pulumi.Input['LoadBalancerIpAddressDetailReservedIpArgs']] = None):
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if reserved_ip is not None:
            pulumi.set(__self__, "reserved_ip", reserved_ip)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_public", value)

    @property
    @pulumi.getter(name="reservedIp")
    def reserved_ip(self) -> Optional[pulumi.Input['LoadBalancerIpAddressDetailReservedIpArgs']]:
        return pulumi.get(self, "reserved_ip")

    @reserved_ip.setter
    def reserved_ip(self, value: Optional[pulumi.Input['LoadBalancerIpAddressDetailReservedIpArgs']]):
        pulumi.set(self, "reserved_ip", value)


@pulumi.input_type
class LoadBalancerIpAddressDetailReservedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class LoadBalancerListenerConnectionConfigurationArgs:
    def __init__(__self__, *,
                 idle_timeout_in_seconds: pulumi.Input[str],
                 backend_tcp_proxy_protocol_version: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] idle_timeout_in_seconds: (Updatable) The maximum idle time, in seconds, allowed between two successive receive or two successive send operations between the client and backend servers. A send operation does not reset the timer for receive operations. A receive operation does not reset the timer for send operations.
        :param pulumi.Input[int] backend_tcp_proxy_protocol_version: (Updatable) The backend TCP Proxy Protocol version.  Example: `1`
        """
        pulumi.set(__self__, "idle_timeout_in_seconds", idle_timeout_in_seconds)
        if backend_tcp_proxy_protocol_version is not None:
            pulumi.set(__self__, "backend_tcp_proxy_protocol_version", backend_tcp_proxy_protocol_version)

    @property
    @pulumi.getter(name="idleTimeoutInSeconds")
    def idle_timeout_in_seconds(self) -> pulumi.Input[str]:
        """
        (Updatable) The maximum idle time, in seconds, allowed between two successive receive or two successive send operations between the client and backend servers. A send operation does not reset the timer for receive operations. A receive operation does not reset the timer for send operations.
        """
        return pulumi.get(self, "idle_timeout_in_seconds")

    @idle_timeout_in_seconds.setter
    def idle_timeout_in_seconds(self, value: pulumi.Input[str]):
        pulumi.set(self, "idle_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="backendTcpProxyProtocolVersion")
    def backend_tcp_proxy_protocol_version(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The backend TCP Proxy Protocol version.  Example: `1`
        """
        return pulumi.get(self, "backend_tcp_proxy_protocol_version")

    @backend_tcp_proxy_protocol_version.setter
    def backend_tcp_proxy_protocol_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "backend_tcp_proxy_protocol_version", value)


@pulumi.input_type
class LoadBalancerListenerSslConfigurationArgs:
    def __init__(__self__, *,
                 certificate_name: pulumi.Input[str],
                 cipher_suite_name: Optional[pulumi.Input[str]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 server_order_preference: Optional[pulumi.Input[str]] = None,
                 verify_depth: Optional[pulumi.Input[int]] = None,
                 verify_peer_certificate: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] certificate_name: (Updatable) A friendly name for the certificate bundle. It must be unique and it cannot be changed. Valid certificate bundle names include only alphanumeric characters, dashes, and underscores. Certificate bundle names cannot contain spaces. Avoid entering confidential information.  Example: `example_certificate_bundle`
        :param pulumi.Input[str] cipher_suite_name: (Updatable) The name of the cipher suite to use for HTTPS or SSL connections.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] protocols: (Updatable) A list of SSL protocols the load balancer must support for HTTPS or SSL connections.
        :param pulumi.Input[str] server_order_preference: (Updatable) When this attribute is set to ENABLED, the system gives preference to the server ciphers over the client ciphers.
        :param pulumi.Input[int] verify_depth: (Updatable) The maximum depth for peer certificate chain verification.  Example: `3`
        :param pulumi.Input[bool] verify_peer_certificate: (Updatable) Whether the load balancer listener should verify peer certificates.  Example: `true`
        """
        pulumi.set(__self__, "certificate_name", certificate_name)
        if cipher_suite_name is not None:
            pulumi.set(__self__, "cipher_suite_name", cipher_suite_name)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if server_order_preference is not None:
            pulumi.set(__self__, "server_order_preference", server_order_preference)
        if verify_depth is not None:
            pulumi.set(__self__, "verify_depth", verify_depth)
        if verify_peer_certificate is not None:
            pulumi.set(__self__, "verify_peer_certificate", verify_peer_certificate)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> pulumi.Input[str]:
        """
        (Updatable) A friendly name for the certificate bundle. It must be unique and it cannot be changed. Valid certificate bundle names include only alphanumeric characters, dashes, and underscores. Certificate bundle names cannot contain spaces. Avoid entering confidential information.  Example: `example_certificate_bundle`
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_name", value)

    @property
    @pulumi.getter(name="cipherSuiteName")
    def cipher_suite_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the cipher suite to use for HTTPS or SSL connections.
        """
        return pulumi.get(self, "cipher_suite_name")

    @cipher_suite_name.setter
    def cipher_suite_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cipher_suite_name", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of SSL protocols the load balancer must support for HTTPS or SSL connections.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="serverOrderPreference")
    def server_order_preference(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) When this attribute is set to ENABLED, the system gives preference to the server ciphers over the client ciphers.
        """
        return pulumi.get(self, "server_order_preference")

    @server_order_preference.setter
    def server_order_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_order_preference", value)

    @property
    @pulumi.getter(name="verifyDepth")
    def verify_depth(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum depth for peer certificate chain verification.  Example: `3`
        """
        return pulumi.get(self, "verify_depth")

    @verify_depth.setter
    def verify_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "verify_depth", value)

    @property
    @pulumi.getter(name="verifyPeerCertificate")
    def verify_peer_certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether the load balancer listener should verify peer certificates.  Example: `true`
        """
        return pulumi.get(self, "verify_peer_certificate")

    @verify_peer_certificate.setter
    def verify_peer_certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "verify_peer_certificate", value)


@pulumi.input_type
class LoadBalancerLoadBalancerIpAddressDetailArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 is_public: Optional[pulumi.Input[bool]] = None,
                 reserved_ip: Optional[pulumi.Input['LoadBalancerLoadBalancerIpAddressDetailReservedIpArgs']] = None):
        """
        :param pulumi.Input[str] ip_address: An IP address.  Example: `192.168.0.3`
        :param pulumi.Input[bool] is_public: Whether the IP address is public or private.
        :param pulumi.Input['LoadBalancerLoadBalancerIpAddressDetailReservedIpArgs'] reserved_ip: Pre-created public IP that will be used as the IP of this load balancer. This reserved IP will not be deleted when load balancer is deleted. This ip should not be already mapped to any other resource.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if reserved_ip is not None:
            pulumi.set(__self__, "reserved_ip", reserved_ip)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        An IP address.  Example: `192.168.0.3`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the IP address is public or private.
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_public", value)

    @property
    @pulumi.getter(name="reservedIp")
    def reserved_ip(self) -> Optional[pulumi.Input['LoadBalancerLoadBalancerIpAddressDetailReservedIpArgs']]:
        """
        Pre-created public IP that will be used as the IP of this load balancer. This reserved IP will not be deleted when load balancer is deleted. This ip should not be already mapped to any other resource.
        """
        return pulumi.get(self, "reserved_ip")

    @reserved_ip.setter
    def reserved_ip(self, value: Optional[pulumi.Input['LoadBalancerLoadBalancerIpAddressDetailReservedIpArgs']]):
        pulumi.set(self, "reserved_ip", value)


@pulumi.input_type
class LoadBalancerLoadBalancerIpAddressDetailReservedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Ocid of the pre-created public IP. That should be attahed to this load balancer.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Ocid of the pre-created public IP. That should be attahed to this load balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class LoadBalancerLoadBalancerReservedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Ocid of the pre-created public IP. That should be attahed to this load balancer.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Ocid of the pre-created public IP. That should be attahed to this load balancer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class LoadBalancerLoadBalancerRoutingPolicyRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerRoutingPolicyRuleActionArgs']]],
                 condition: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerRoutingPolicyRuleActionArgs']]] actions: (Updatable) A list of actions to be applied when conditions of the routing rule are met.
        :param pulumi.Input[str] condition: (Updatable) A routing rule to evaluate defined conditions against the incoming HTTP request and perform an action.
        :param pulumi.Input[str] name: (Updatable) A unique name for the routing policy rule. Avoid entering confidential information.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerRoutingPolicyRuleActionArgs']]]:
        """
        (Updatable) A list of actions to be applied when conditions of the routing rule are met.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input['LoadBalancerLoadBalancerRoutingPolicyRuleActionArgs']]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        (Updatable) A routing rule to evaluate defined conditions against the incoming HTTP request and perform an action.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) A unique name for the routing policy rule. Avoid entering confidential information.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class LoadBalancerLoadBalancerRoutingPolicyRuleActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 backend_set_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) A unique name for the routing policy rule. Avoid entering confidential information.
        :param pulumi.Input[str] backend_set_name: (Updatable) Name of the backend set the listener will forward the traffic to.  Example: `backendSetForImages`
        """
        pulumi.set(__self__, "name", name)
        if backend_set_name is not None:
            pulumi.set(__self__, "backend_set_name", backend_set_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) A unique name for the routing policy rule. Avoid entering confidential information.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Name of the backend set the listener will forward the traffic to.  Example: `backendSetForImages`
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backend_set_name", value)


@pulumi.input_type
class LoadBalancerLoadBalancerShapeDetailsArgs:
    def __init__(__self__, *,
                 maximum_bandwidth_in_mbps: pulumi.Input[int],
                 minimum_bandwidth_in_mbps: pulumi.Input[int]):
        """
        :param pulumi.Input[int] maximum_bandwidth_in_mbps: (Updatable) Bandwidth in Mbps that determines the maximum bandwidth (ingress plus egress) that the load balancer can achieve. This bandwidth cannot be always guaranteed. For a guaranteed bandwidth use the minimumBandwidthInMbps parameter.
        :param pulumi.Input[int] minimum_bandwidth_in_mbps: (Updatable) Bandwidth in Mbps that determines the total pre-provisioned bandwidth (ingress plus egress). The values must be between 10 and the maximumBandwidthInMbps.  Example: `150`
        """
        pulumi.set(__self__, "maximum_bandwidth_in_mbps", maximum_bandwidth_in_mbps)
        pulumi.set(__self__, "minimum_bandwidth_in_mbps", minimum_bandwidth_in_mbps)

    @property
    @pulumi.getter(name="maximumBandwidthInMbps")
    def maximum_bandwidth_in_mbps(self) -> pulumi.Input[int]:
        """
        (Updatable) Bandwidth in Mbps that determines the maximum bandwidth (ingress plus egress) that the load balancer can achieve. This bandwidth cannot be always guaranteed. For a guaranteed bandwidth use the minimumBandwidthInMbps parameter.
        """
        return pulumi.get(self, "maximum_bandwidth_in_mbps")

    @maximum_bandwidth_in_mbps.setter
    def maximum_bandwidth_in_mbps(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum_bandwidth_in_mbps", value)

    @property
    @pulumi.getter(name="minimumBandwidthInMbps")
    def minimum_bandwidth_in_mbps(self) -> pulumi.Input[int]:
        """
        (Updatable) Bandwidth in Mbps that determines the total pre-provisioned bandwidth (ingress plus egress). The values must be between 10 and the maximumBandwidthInMbps.  Example: `150`
        """
        return pulumi.get(self, "minimum_bandwidth_in_mbps")

    @minimum_bandwidth_in_mbps.setter
    def minimum_bandwidth_in_mbps(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimum_bandwidth_in_mbps", value)


@pulumi.input_type
class LoadBalancerPathRouteSetPathRouteArgs:
    def __init__(__self__, *,
                 backend_set_name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 path_match_type: pulumi.Input['LoadBalancerPathRouteSetPathRoutePathMatchTypeArgs']):
        """
        :param pulumi.Input[str] backend_set_name: (Updatable) The name of the target backend set for requests where the incoming URI matches the specified path.  Example: `example_backend_set`
        :param pulumi.Input[str] path: (Updatable) The path string to match against the incoming URI path.
               *  Path strings are case-insensitive.
               *  Asterisk (*) wildcards are not supported.
               *  Regular expressions are not supported.
        :param pulumi.Input['LoadBalancerPathRouteSetPathRoutePathMatchTypeArgs'] path_match_type: (Updatable) The type of matching to apply to incoming URIs.
        """
        pulumi.set(__self__, "backend_set_name", backend_set_name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "path_match_type", path_match_type)

    @property
    @pulumi.getter(name="backendSetName")
    def backend_set_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the target backend set for requests where the incoming URI matches the specified path.  Example: `example_backend_set`
        """
        return pulumi.get(self, "backend_set_name")

    @backend_set_name.setter
    def backend_set_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backend_set_name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        (Updatable) The path string to match against the incoming URI path.
        *  Path strings are case-insensitive.
        *  Asterisk (*) wildcards are not supported.
        *  Regular expressions are not supported.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="pathMatchType")
    def path_match_type(self) -> pulumi.Input['LoadBalancerPathRouteSetPathRoutePathMatchTypeArgs']:
        """
        (Updatable) The type of matching to apply to incoming URIs.
        """
        return pulumi.get(self, "path_match_type")

    @path_match_type.setter
    def path_match_type(self, value: pulumi.Input['LoadBalancerPathRouteSetPathRoutePathMatchTypeArgs']):
        pulumi.set(self, "path_match_type", value)


@pulumi.input_type
class LoadBalancerPathRouteSetPathRoutePathMatchTypeArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] match_type: (Updatable) Specifies how the load balancing service compares a [PathRoute](https://docs.cloud.oracle.com/iaas/api/#/en/loadbalancer/20170115/requests/PathRoute) object's `path` string against the incoming URI.
               *  **EXACT_MATCH** - Looks for a `path` string that exactly matches the incoming URI path.
               *  **FORCE_LONGEST_PREFIX_MATCH** - Looks for the `path` string with the best, longest match of the beginning portion of the incoming URI path.
               *  **PREFIX_MATCH** - Looks for a `path` string that matches the beginning portion of the incoming URI path.
               *  **SUFFIX_MATCH** - Looks for a `path` string that matches the ending portion of the incoming URI path.
        """
        pulumi.set(__self__, "match_type", match_type)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies how the load balancing service compares a [PathRoute](https://docs.cloud.oracle.com/iaas/api/#/en/loadbalancer/20170115/requests/PathRoute) object's `path` string against the incoming URI.
        *  **EXACT_MATCH** - Looks for a `path` string that exactly matches the incoming URI path.
        *  **FORCE_LONGEST_PREFIX_MATCH** - Looks for the `path` string with the best, longest match of the beginning portion of the incoming URI path.
        *  **PREFIX_MATCH** - Looks for a `path` string that matches the beginning portion of the incoming URI path.
        *  **SUFFIX_MATCH** - Looks for a `path` string that matches the ending portion of the incoming URI path.
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "match_type", value)


@pulumi.input_type
class LoadBalancerReservedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class LoadBalancerRuleSetItemArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 allowed_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 are_invalid_characters_allowed: Optional[pulumi.Input[bool]] = None,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleSetItemConditionArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 header: Optional[pulumi.Input[str]] = None,
                 http_large_header_size_in_kb: Optional[pulumi.Input[int]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 redirect_uri: Optional[pulumi.Input['LoadBalancerRuleSetItemRedirectUriArgs']] = None,
                 response_code: Optional[pulumi.Input[int]] = None,
                 status_code: Optional[pulumi.Input[int]] = None,
                 suffix: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: (Updatable) The action can be one of these values: `ADD_HTTP_REQUEST_HEADER`, `ADD_HTTP_RESPONSE_HEADER`, `ALLOW`, `CONTROL_ACCESS_USING_HTTP_METHODS`, `EXTEND_HTTP_REQUEST_HEADER_VALUE`, `EXTEND_HTTP_RESPONSE_HEADER_VALUE`, `HTTP_HEADER`, `REDIRECT`, `REMOVE_HTTP_REQUEST_HEADER`, `REMOVE_HTTP_RESPONSE_HEADER`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: (Updatable) The list of HTTP methods allowed for this listener.
        :param pulumi.Input[bool] are_invalid_characters_allowed: (Updatable) Indicates whether or not invalid characters in client header fields will be allowed. Valid names are composed of English letters, digits, hyphens and underscores. If "true", invalid characters are allowed in the HTTP header. If "false", invalid characters are not allowed in the HTTP header
        :param pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleSetItemConditionArgs']]] conditions: (Updatable)
        :param pulumi.Input[str] description: (Updatable) A brief description of the access control rule. Avoid entering confidential information.
        :param pulumi.Input[str] header: (Updatable) A header name that conforms to RFC 7230.  Example: `example_header_name`
        :param pulumi.Input[int] http_large_header_size_in_kb: (Updatable) The maximum size of each buffer used for reading http client request header. This value indicates the maximum size allowed for each buffer. The allowed values for buffer size are 8, 16, 32 and 64.
        :param pulumi.Input[str] prefix: (Updatable) A string to prepend to the header value. The resulting header value must still conform to RFC 7230. With the following exceptions:
               *  value cannot contain `$`
               *  value cannot contain patterns like `{variable_name}`. They are reserved for future extensions. Currently, such values are invalid.
        :param pulumi.Input['LoadBalancerRuleSetItemRedirectUriArgs'] redirect_uri: (Updatable) An object that defines the redirect URI applied to the original request. The object property values compose the redirect URI.
        :param pulumi.Input[int] response_code: (Updatable) The HTTP status code to return when the incoming request is redirected.
        :param pulumi.Input[int] status_code: (Updatable) The HTTP status code to return when the requested HTTP method is not in the list of allowed methods. The associated status line returned with the code is mapped from the standard HTTP specification. The default value is `405 (Method Not Allowed)`.  Example: 403
        :param pulumi.Input[str] suffix: (Updatable) A string to append to the header value. The resulting header value must still conform to RFC 7230. With the following exceptions:
               *  value cannot contain `$`
               *  value cannot contain patterns like `{variable_name}`. They are reserved for future extensions. Currently, such values are invalid.
        :param pulumi.Input[str] value: (Updatable) A header value that conforms to RFC 7230. With the following exceptions:
               *  value cannot contain `$`
               *  value cannot contain patterns like `{variable_name}`. They are reserved for future extensions. Currently, such values are invalid.
        """
        pulumi.set(__self__, "action", action)
        if allowed_methods is not None:
            pulumi.set(__self__, "allowed_methods", allowed_methods)
        if are_invalid_characters_allowed is not None:
            pulumi.set(__self__, "are_invalid_characters_allowed", are_invalid_characters_allowed)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if http_large_header_size_in_kb is not None:
            pulumi.set(__self__, "http_large_header_size_in_kb", http_large_header_size_in_kb)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if status_code is not None:
            pulumi.set(__self__, "status_code", status_code)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        (Updatable) The action can be one of these values: `ADD_HTTP_REQUEST_HEADER`, `ADD_HTTP_RESPONSE_HEADER`, `ALLOW`, `CONTROL_ACCESS_USING_HTTP_METHODS`, `EXTEND_HTTP_REQUEST_HEADER_VALUE`, `EXTEND_HTTP_RESPONSE_HEADER_VALUE`, `HTTP_HEADER`, `REDIRECT`, `REMOVE_HTTP_REQUEST_HEADER`, `REMOVE_HTTP_RESPONSE_HEADER`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of HTTP methods allowed for this listener.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="areInvalidCharactersAllowed")
    def are_invalid_characters_allowed(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Indicates whether or not invalid characters in client header fields will be allowed. Valid names are composed of English letters, digits, hyphens and underscores. If "true", invalid characters are allowed in the HTTP header. If "false", invalid characters are not allowed in the HTTP header
        """
        return pulumi.get(self, "are_invalid_characters_allowed")

    @are_invalid_characters_allowed.setter
    def are_invalid_characters_allowed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_invalid_characters_allowed", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleSetItemConditionArgs']]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoadBalancerRuleSetItemConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A brief description of the access control rule. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A header name that conforms to RFC 7230.  Example: `example_header_name`
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="httpLargeHeaderSizeInKb")
    def http_large_header_size_in_kb(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum size of each buffer used for reading http client request header. This value indicates the maximum size allowed for each buffer. The allowed values for buffer size are 8, 16, 32 and 64.
        """
        return pulumi.get(self, "http_large_header_size_in_kb")

    @http_large_header_size_in_kb.setter
    def http_large_header_size_in_kb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_large_header_size_in_kb", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A string to prepend to the header value. The resulting header value must still conform to RFC 7230. With the following exceptions:
        *  value cannot contain `$`
        *  value cannot contain patterns like `{variable_name}`. They are reserved for future extensions. Currently, such values are invalid.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[pulumi.Input['LoadBalancerRuleSetItemRedirectUriArgs']]:
        """
        (Updatable) An object that defines the redirect URI applied to the original request. The object property values compose the redirect URI.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: Optional[pulumi.Input['LoadBalancerRuleSetItemRedirectUriArgs']]):
        pulumi.set(self, "redirect_uri", value)

    @property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The HTTP status code to return when the incoming request is redirected.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "response_code", value)

    @property
    @pulumi.getter(name="statusCode")
    def status_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The HTTP status code to return when the requested HTTP method is not in the list of allowed methods. The associated status line returned with the code is mapped from the standard HTTP specification. The default value is `405 (Method Not Allowed)`.  Example: 403
        """
        return pulumi.get(self, "status_code")

    @status_code.setter
    def status_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "status_code", value)

    @property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A string to append to the header value. The resulting header value must still conform to RFC 7230. With the following exceptions:
        *  value cannot contain `$`
        *  value cannot contain patterns like `{variable_name}`. They are reserved for future extensions. Currently, such values are invalid.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "suffix", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A header value that conforms to RFC 7230. With the following exceptions:
        *  value cannot contain `$`
        *  value cannot contain patterns like `{variable_name}`. They are reserved for future extensions. Currently, such values are invalid.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class LoadBalancerRuleSetItemConditionArgs:
    def __init__(__self__, *,
                 attribute_name: pulumi.Input[str],
                 attribute_value: pulumi.Input[str],
                 operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] attribute_name: (Updatable) The attribute_name can be one of these values: `PATH`, `SOURCE_IP_ADDRESS`, `SOURCE_VCN_ID`, `SOURCE_VCN_IP_ADDRESS`
        :param pulumi.Input[str] attribute_value: (Updatable) Depends on `attribute_name`:
               - when `attribute_name` = `SOURCE_IP_ADDRESS` | IPv4 or IPv6 address range to which the source IP address of incoming packet would be matched against
               - when `attribute_name` = `SOURCE_VCN_IP_ADDRESS` | IPv4 address range to which the original client IP address (in customer VCN) of incoming packet would be matched against
               - when `attribute_name` = `SOURCE_VCN_ID` | OCID of the customer VCN to which the service gateway embedded VCN ID of incoming packet would be matched against
        :param pulumi.Input[str] operator: (Updatable) A string that specifies how to compare the PathMatchCondition object's `attributeValue` string to the incoming URI.
               *  **EXACT_MATCH** - The incoming URI path must exactly and completely match the `attributeValue` string.
               *  **FORCE_LONGEST_PREFIX_MATCH** - The system looks for the `attributeValue` string with the best, longest match of the beginning portion of the incoming URI path.
               *  **PREFIX_MATCH** - The beginning portion of the incoming URI path must exactly match the `attributeValue` string.
               *  **SUFFIX_MATCH** - The ending portion of the incoming URI path must exactly match the `attributeValue` string.
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_value", attribute_value)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The attribute_name can be one of these values: `PATH`, `SOURCE_IP_ADDRESS`, `SOURCE_VCN_ID`, `SOURCE_VCN_IP_ADDRESS`
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> pulumi.Input[str]:
        """
        (Updatable) Depends on `attribute_name`:
        - when `attribute_name` = `SOURCE_IP_ADDRESS` | IPv4 or IPv6 address range to which the source IP address of incoming packet would be matched against
        - when `attribute_name` = `SOURCE_VCN_IP_ADDRESS` | IPv4 address range to which the original client IP address (in customer VCN) of incoming packet would be matched against
        - when `attribute_name` = `SOURCE_VCN_ID` | OCID of the customer VCN to which the service gateway embedded VCN ID of incoming packet would be matched against
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "attribute_value", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A string that specifies how to compare the PathMatchCondition object's `attributeValue` string to the incoming URI.
        *  **EXACT_MATCH** - The incoming URI path must exactly and completely match the `attributeValue` string.
        *  **FORCE_LONGEST_PREFIX_MATCH** - The system looks for the `attributeValue` string with the best, longest match of the beginning portion of the incoming URI path.
        *  **PREFIX_MATCH** - The beginning portion of the incoming URI path must exactly match the `attributeValue` string.
        *  **SUFFIX_MATCH** - The ending portion of the incoming URI path must exactly match the `attributeValue` string.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)


@pulumi.input_type
class LoadBalancerRuleSetItemRedirectUriArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: (Updatable) The valid domain name (hostname) or IP address to use in the redirect URI.
        :param pulumi.Input[str] path: (Updatable) The HTTP URI path to use in the redirect URI.
        :param pulumi.Input[int] port: (Updatable) The communication port to use in the redirect URI.
        :param pulumi.Input[str] protocol: (Updatable) The HTTP protocol to use in the redirect URI.
        :param pulumi.Input[str] query: (Updatable) The query string to use in the redirect URI.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The valid domain name (hostname) or IP address to use in the redirect URI.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The HTTP URI path to use in the redirect URI.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The communication port to use in the redirect URI.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The HTTP protocol to use in the redirect URI.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The query string to use in the redirect URI.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class LoadBalancerShapeDetailsArgs:
    def __init__(__self__, *,
                 maximum_bandwidth_in_mbps: pulumi.Input[int],
                 minimum_bandwidth_in_mbps: pulumi.Input[int]):
        pulumi.set(__self__, "maximum_bandwidth_in_mbps", maximum_bandwidth_in_mbps)
        pulumi.set(__self__, "minimum_bandwidth_in_mbps", minimum_bandwidth_in_mbps)

    @property
    @pulumi.getter(name="maximumBandwidthInMbps")
    def maximum_bandwidth_in_mbps(self) -> pulumi.Input[int]:
        return pulumi.get(self, "maximum_bandwidth_in_mbps")

    @maximum_bandwidth_in_mbps.setter
    def maximum_bandwidth_in_mbps(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum_bandwidth_in_mbps", value)

    @property
    @pulumi.getter(name="minimumBandwidthInMbps")
    def minimum_bandwidth_in_mbps(self) -> pulumi.Input[int]:
        return pulumi.get(self, "minimum_bandwidth_in_mbps")

    @minimum_bandwidth_in_mbps.setter
    def minimum_bandwidth_in_mbps(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimum_bandwidth_in_mbps", value)


@pulumi.input_type
class LogAnalyticsLogAnalyticsObjectCollectionRuleOverrideArgs:
    def __init__(__self__, *,
                 match_type: Optional[pulumi.Input[str]] = None,
                 match_value: Optional[pulumi.Input[str]] = None,
                 property_name: Optional[pulumi.Input[str]] = None,
                 property_value: Optional[pulumi.Input[str]] = None):
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)
        if match_value is not None:
            pulumi.set(__self__, "match_value", match_value)
        if property_name is not None:
            pulumi.set(__self__, "property_name", property_name)
        if property_value is not None:
            pulumi.set(__self__, "property_value", property_value)

    @property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_type", value)

    @property
    @pulumi.getter(name="matchValue")
    def match_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match_value")

    @match_value.setter
    def match_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_value", value)

    @property
    @pulumi.getter(name="propertyName")
    def property_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "property_name")

    @property_name.setter
    def property_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property_name", value)

    @property
    @pulumi.getter(name="propertyValue")
    def property_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "property_value")

    @property_value.setter
    def property_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property_value", value)


@pulumi.input_type
class LoggingLogConfigurationArgs:
    def __init__(__self__, *,
                 source: pulumi.Input['LoggingLogConfigurationSourceArgs'],
                 compartment_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LoggingLogConfigurationSourceArgs'] source: The source the log object comes from.
        :param pulumi.Input[str] compartment_id: The OCID of the compartment that the resource belongs to.
        """
        pulumi.set(__self__, "source", source)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input['LoggingLogConfigurationSourceArgs']:
        """
        The source the log object comes from.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input['LoggingLogConfigurationSourceArgs']):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compartment that the resource belongs to.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)


@pulumi.input_type
class LoggingLogConfigurationSourceArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[str],
                 resource: pulumi.Input[str],
                 service: pulumi.Input[str],
                 source_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] category: Log object category.
        :param pulumi.Input[str] resource: The unique identifier of the resource emitting the log.
        :param pulumi.Input[str] service: Service generating log.
        :param pulumi.Input[str] source_type: The log source.
               * **OCISERVICE:** Oracle Service.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[str]:
        """
        Log object category.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input[str]:
        """
        The unique identifier of the resource emitting the log.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        Service generating log.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The log source.
        * **OCISERVICE:** Oracle Service.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)


@pulumi.input_type
class LoggingUnifiedAgentConfigurationGroupAssociationArgs:
    def __init__(__self__, *,
                 group_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_lists: (Updatable) list of group/dynamic group ids associated with this configuration.
        """
        if group_lists is not None:
            pulumi.set(__self__, "group_lists", group_lists)

    @property
    @pulumi.getter(name="groupLists")
    def group_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) list of group/dynamic group ids associated with this configuration.
        """
        return pulumi.get(self, "group_lists")

    @group_lists.setter
    def group_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_lists", value)


@pulumi.input_type
class LoggingUnifiedAgentConfigurationServiceConfigurationArgs:
    def __init__(__self__, *,
                 configuration_type: pulumi.Input[str],
                 destination: pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationDestinationArgs'],
                 sources: pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceArgs']]]):
        """
        :param pulumi.Input[str] configuration_type: (Updatable) Type of Unified Agent service configuration.
        :param pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationDestinationArgs'] destination: (Updatable) Logging destination object.
        :param pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceArgs']]] sources: (Updatable)
        """
        pulumi.set(__self__, "configuration_type", configuration_type)
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter(name="configurationType")
    def configuration_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of Unified Agent service configuration.
        """
        return pulumi.get(self, "configuration_type")

    @configuration_type.setter
    def configuration_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "configuration_type", value)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationDestinationArgs']:
        """
        (Updatable) Logging destination object.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def sources(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceArgs']]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceArgs']]]):
        pulumi.set(self, "sources", value)


@pulumi.input_type
class LoggingUnifiedAgentConfigurationServiceConfigurationDestinationArgs:
    def __init__(__self__, *,
                 log_object_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] log_object_id: (Updatable) The OCID of the resource.
        """
        pulumi.set(__self__, "log_object_id", log_object_id)

    @property
    @pulumi.getter(name="logObjectId")
    def log_object_id(self) -> pulumi.Input[str]:
        """
        (Updatable) The OCID of the resource.
        """
        return pulumi.get(self, "log_object_id")

    @log_object_id.setter
    def log_object_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_object_id", value)


@pulumi.input_type
class LoggingUnifiedAgentConfigurationServiceConfigurationSourceArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parser: Optional[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserArgs']] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] source_type: (Updatable) Unified schema logging source type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] channels: (Updatable)
        :param pulumi.Input[str] name: (Updatable) The name key to tag this grok pattern.
        :param pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserArgs'] parser: (Updatable) source parser object.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] paths: (Updatable)
        """
        pulumi.set(__self__, "source_type", source_type)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parser is not None:
            pulumi.set(__self__, "parser", parser)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Unified schema logging source type.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter
    def channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "channels")

    @channels.setter
    def channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "channels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name key to tag this grok pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parser(self) -> Optional[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserArgs']]:
        """
        (Updatable) source parser object.
        """
        return pulumi.get(self, "parser")

    @parser.setter
    def parser(self, value: Optional[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserArgs']]):
        pulumi.set(self, "parser", value)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "paths", value)


@pulumi.input_type
class LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserArgs:
    def __init__(__self__, *,
                 parser_type: pulumi.Input[str],
                 delimiter: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 field_time_key: Optional[pulumi.Input[str]] = None,
                 format_firstline: Optional[pulumi.Input[str]] = None,
                 formats: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 grok_failure_key: Optional[pulumi.Input[str]] = None,
                 grok_name_key: Optional[pulumi.Input[str]] = None,
                 is_estimate_current_event: Optional[pulumi.Input[bool]] = None,
                 is_keep_time_key: Optional[pulumi.Input[bool]] = None,
                 is_null_empty_string: Optional[pulumi.Input[bool]] = None,
                 is_support_colonless_ident: Optional[pulumi.Input[bool]] = None,
                 is_with_priority: Optional[pulumi.Input[bool]] = None,
                 keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 message_format: Optional[pulumi.Input[str]] = None,
                 message_key: Optional[pulumi.Input[str]] = None,
                 multi_line_start_regexp: Optional[pulumi.Input[str]] = None,
                 null_value_pattern: Optional[pulumi.Input[str]] = None,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]]] = None,
                 rfc5424time_format: Optional[pulumi.Input[str]] = None,
                 syslog_parser_type: Optional[pulumi.Input[str]] = None,
                 time_format: Optional[pulumi.Input[str]] = None,
                 time_type: Optional[pulumi.Input[str]] = None,
                 timeout_in_milliseconds: Optional[pulumi.Input[int]] = None,
                 types: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[str] parser_type: (Updatable) Type of fluent parser.
        :param pulumi.Input[str] delimiter: (Updatable)
        :param pulumi.Input[str] expression: (Updatable)
        :param pulumi.Input[str] field_time_key: (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        :param pulumi.Input[str] format_firstline: (Updatable)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] formats: (Updatable)
        :param pulumi.Input[str] grok_failure_key: (Updatable)
        :param pulumi.Input[str] grok_name_key: (Updatable)
        :param pulumi.Input[bool] is_estimate_current_event: (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
        :param pulumi.Input[bool] is_keep_time_key: (Updatable) If true, keep time field in the record.
        :param pulumi.Input[bool] is_null_empty_string: (Updatable) If true, an empty string field is replaced with nil.
        :param pulumi.Input[bool] is_support_colonless_ident: (Updatable)
        :param pulumi.Input[bool] is_with_priority: (Updatable)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] keys: (Updatable)
        :param pulumi.Input[str] message_format: (Updatable)
        :param pulumi.Input[str] message_key: (Updatable)
        :param pulumi.Input[str] multi_line_start_regexp: (Updatable)
        :param pulumi.Input[str] null_value_pattern: (Updatable) Specify the null value pattern.
        :param pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]] patterns: (Updatable)
        :param pulumi.Input[str] rfc5424time_format: (Updatable)
        :param pulumi.Input[str] syslog_parser_type: (Updatable)
        :param pulumi.Input[str] time_format: (Updatable)
        :param pulumi.Input[str] time_type: (Updatable)
        :param pulumi.Input[int] timeout_in_milliseconds: (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
        :param pulumi.Input[Mapping[str, Any]] types: (Updatable) Specify types for converting a field into another type.
        """
        pulumi.set(__self__, "parser_type", parser_type)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if field_time_key is not None:
            pulumi.set(__self__, "field_time_key", field_time_key)
        if format_firstline is not None:
            pulumi.set(__self__, "format_firstline", format_firstline)
        if formats is not None:
            pulumi.set(__self__, "formats", formats)
        if grok_failure_key is not None:
            pulumi.set(__self__, "grok_failure_key", grok_failure_key)
        if grok_name_key is not None:
            pulumi.set(__self__, "grok_name_key", grok_name_key)
        if is_estimate_current_event is not None:
            pulumi.set(__self__, "is_estimate_current_event", is_estimate_current_event)
        if is_keep_time_key is not None:
            pulumi.set(__self__, "is_keep_time_key", is_keep_time_key)
        if is_null_empty_string is not None:
            pulumi.set(__self__, "is_null_empty_string", is_null_empty_string)
        if is_support_colonless_ident is not None:
            pulumi.set(__self__, "is_support_colonless_ident", is_support_colonless_ident)
        if is_with_priority is not None:
            pulumi.set(__self__, "is_with_priority", is_with_priority)
        if keys is not None:
            pulumi.set(__self__, "keys", keys)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if message_key is not None:
            pulumi.set(__self__, "message_key", message_key)
        if multi_line_start_regexp is not None:
            pulumi.set(__self__, "multi_line_start_regexp", multi_line_start_regexp)
        if null_value_pattern is not None:
            pulumi.set(__self__, "null_value_pattern", null_value_pattern)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if rfc5424time_format is not None:
            pulumi.set(__self__, "rfc5424time_format", rfc5424time_format)
        if syslog_parser_type is not None:
            pulumi.set(__self__, "syslog_parser_type", syslog_parser_type)
        if time_format is not None:
            pulumi.set(__self__, "time_format", time_format)
        if time_type is not None:
            pulumi.set(__self__, "time_type", time_type)
        if timeout_in_milliseconds is not None:
            pulumi.set(__self__, "timeout_in_milliseconds", timeout_in_milliseconds)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter(name="parserType")
    def parser_type(self) -> pulumi.Input[str]:
        """
        (Updatable) Type of fluent parser.
        """
        return pulumi.get(self, "parser_type")

    @parser_type.setter
    def parser_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "parser_type", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="fieldTimeKey")
    def field_time_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        """
        return pulumi.get(self, "field_time_key")

    @field_time_key.setter
    def field_time_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_key", value)

    @property
    @pulumi.getter(name="formatFirstline")
    def format_firstline(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "format_firstline")

    @format_firstline.setter
    def format_firstline(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format_firstline", value)

    @property
    @pulumi.getter
    def formats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "formats")

    @formats.setter
    def formats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "formats", value)

    @property
    @pulumi.getter(name="grokFailureKey")
    def grok_failure_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "grok_failure_key")

    @grok_failure_key.setter
    def grok_failure_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grok_failure_key", value)

    @property
    @pulumi.getter(name="grokNameKey")
    def grok_name_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "grok_name_key")

    @grok_name_key.setter
    def grok_name_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grok_name_key", value)

    @property
    @pulumi.getter(name="isEstimateCurrentEvent")
    def is_estimate_current_event(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
        """
        return pulumi.get(self, "is_estimate_current_event")

    @is_estimate_current_event.setter
    def is_estimate_current_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_estimate_current_event", value)

    @property
    @pulumi.getter(name="isKeepTimeKey")
    def is_keep_time_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, keep time field in the record.
        """
        return pulumi.get(self, "is_keep_time_key")

    @is_keep_time_key.setter
    def is_keep_time_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_keep_time_key", value)

    @property
    @pulumi.getter(name="isNullEmptyString")
    def is_null_empty_string(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) If true, an empty string field is replaced with nil.
        """
        return pulumi.get(self, "is_null_empty_string")

    @is_null_empty_string.setter
    def is_null_empty_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_null_empty_string", value)

    @property
    @pulumi.getter(name="isSupportColonlessIdent")
    def is_support_colonless_ident(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "is_support_colonless_ident")

    @is_support_colonless_ident.setter
    def is_support_colonless_ident(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_support_colonless_ident", value)

    @property
    @pulumi.getter(name="isWithPriority")
    def is_with_priority(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "is_with_priority")

    @is_with_priority.setter
    def is_with_priority(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_with_priority", value)

    @property
    @pulumi.getter
    def keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "keys", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)

    @property
    @pulumi.getter(name="messageKey")
    def message_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "message_key")

    @message_key.setter
    def message_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_key", value)

    @property
    @pulumi.getter(name="multiLineStartRegexp")
    def multi_line_start_regexp(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "multi_line_start_regexp")

    @multi_line_start_regexp.setter
    def multi_line_start_regexp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multi_line_start_regexp", value)

    @property
    @pulumi.getter(name="nullValuePattern")
    def null_value_pattern(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specify the null value pattern.
        """
        return pulumi.get(self, "null_value_pattern")

    @null_value_pattern.setter
    def null_value_pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "null_value_pattern", value)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs']]]]):
        pulumi.set(self, "patterns", value)

    @property
    @pulumi.getter(name="rfc5424timeFormat")
    def rfc5424time_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "rfc5424time_format")

    @rfc5424time_format.setter
    def rfc5424time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rfc5424time_format", value)

    @property
    @pulumi.getter(name="syslogParserType")
    def syslog_parser_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "syslog_parser_type")

    @syslog_parser_type.setter
    def syslog_parser_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "syslog_parser_type", value)

    @property
    @pulumi.getter(name="timeFormat")
    def time_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "time_format")

    @time_format.setter
    def time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_format", value)

    @property
    @pulumi.getter(name="timeType")
    def time_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "time_type")

    @time_type.setter
    def time_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_type", value)

    @property
    @pulumi.getter(name="timeoutInMilliseconds")
    def timeout_in_milliseconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
        """
        return pulumi.get(self, "timeout_in_milliseconds")

    @timeout_in_milliseconds.setter
    def timeout_in_milliseconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_milliseconds", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Specify types for converting a field into another type.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "types", value)


@pulumi.input_type
class LoggingUnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs:
    def __init__(__self__, *,
                 field_time_format: Optional[pulumi.Input[str]] = None,
                 field_time_key: Optional[pulumi.Input[str]] = None,
                 field_time_zone: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] field_time_format: (Updatable) Process value using the specified format. This is available only when time_type is a string.
        :param pulumi.Input[str] field_time_key: (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        :param pulumi.Input[str] field_time_zone: (Updatable) Use the specified time zone. The time value can be parsed or formatted in the specified time zone.
        :param pulumi.Input[str] name: (Updatable) The name key to tag this grok pattern.
        :param pulumi.Input[str] pattern: (Updatable) The grok pattern.
        """
        if field_time_format is not None:
            pulumi.set(__self__, "field_time_format", field_time_format)
        if field_time_key is not None:
            pulumi.set(__self__, "field_time_key", field_time_key)
        if field_time_zone is not None:
            pulumi.set(__self__, "field_time_zone", field_time_zone)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter(name="fieldTimeFormat")
    def field_time_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Process value using the specified format. This is available only when time_type is a string.
        """
        return pulumi.get(self, "field_time_format")

    @field_time_format.setter
    def field_time_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_format", value)

    @property
    @pulumi.getter(name="fieldTimeKey")
    def field_time_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specify the time field for the event time. If the event doesn't have this field, the current time is used.
        """
        return pulumi.get(self, "field_time_key")

    @field_time_key.setter
    def field_time_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_key", value)

    @property
    @pulumi.getter(name="fieldTimeZone")
    def field_time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Use the specified time zone. The time value can be parsed or formatted in the specified time zone.
        """
        return pulumi.get(self, "field_time_zone")

    @field_time_zone.setter
    def field_time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_time_zone", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name key to tag this grok pattern.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The grok pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class ManagementAgentManagementAgentPluginListArgs:
    def __init__(__self__, *,
                 plugin_display_name: Optional[pulumi.Input[str]] = None,
                 plugin_id: Optional[pulumi.Input[str]] = None,
                 plugin_name: Optional[pulumi.Input[str]] = None,
                 plugin_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] plugin_display_name: Management Agent Plugin Identifier, can be renamed
        :param pulumi.Input[str] plugin_id: Plugin Id
        :param pulumi.Input[str] plugin_name: Management Agent Plugin Name
        :param pulumi.Input[str] plugin_version: Plugin Version
        """
        if plugin_display_name is not None:
            pulumi.set(__self__, "plugin_display_name", plugin_display_name)
        if plugin_id is not None:
            pulumi.set(__self__, "plugin_id", plugin_id)
        if plugin_name is not None:
            pulumi.set(__self__, "plugin_name", plugin_name)
        if plugin_version is not None:
            pulumi.set(__self__, "plugin_version", plugin_version)

    @property
    @pulumi.getter(name="pluginDisplayName")
    def plugin_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Management Agent Plugin Identifier, can be renamed
        """
        return pulumi.get(self, "plugin_display_name")

    @plugin_display_name.setter
    def plugin_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plugin_display_name", value)

    @property
    @pulumi.getter(name="pluginId")
    def plugin_id(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin Id
        """
        return pulumi.get(self, "plugin_id")

    @plugin_id.setter
    def plugin_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plugin_id", value)

    @property
    @pulumi.getter(name="pluginName")
    def plugin_name(self) -> Optional[pulumi.Input[str]]:
        """
        Management Agent Plugin Name
        """
        return pulumi.get(self, "plugin_name")

    @plugin_name.setter
    def plugin_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plugin_name", value)

    @property
    @pulumi.getter(name="pluginVersion")
    def plugin_version(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin Version
        """
        return pulumi.get(self, "plugin_version")

    @plugin_version.setter
    def plugin_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plugin_version", value)


@pulumi.input_type
class MarketplacePublicationIconArgs:
    def __init__(__self__, *,
                 content_url: Optional[pulumi.Input[str]] = None,
                 file_extension: Optional[pulumi.Input[str]] = None,
                 mime_type: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_url: The content URL of the upload data.
        :param pulumi.Input[str] file_extension: The file extension of the upload data.
        :param pulumi.Input[str] mime_type: The MIME type of the upload data.
        :param pulumi.Input[str] name: (Updatable) The name of the contact.
        """
        if content_url is not None:
            pulumi.set(__self__, "content_url", content_url)
        if file_extension is not None:
            pulumi.set(__self__, "file_extension", file_extension)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="contentUrl")
    def content_url(self) -> Optional[pulumi.Input[str]]:
        """
        The content URL of the upload data.
        """
        return pulumi.get(self, "content_url")

    @content_url.setter
    def content_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_url", value)

    @property
    @pulumi.getter(name="fileExtension")
    def file_extension(self) -> Optional[pulumi.Input[str]]:
        """
        The file extension of the upload data.
        """
        return pulumi.get(self, "file_extension")

    @file_extension.setter
    def file_extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_extension", value)

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[str]]:
        """
        The MIME type of the upload data.
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mime_type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the contact.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class MarketplacePublicationPackageDetailsArgs:
    def __init__(__self__, *,
                 eulas: pulumi.Input[Sequence[pulumi.Input['MarketplacePublicationPackageDetailsEulaArgs']]],
                 operating_system: pulumi.Input['MarketplacePublicationPackageDetailsOperatingSystemArgs'],
                 package_type: pulumi.Input[str],
                 package_version: pulumi.Input[str],
                 image_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MarketplacePublicationPackageDetailsEulaArgs']]] eulas: End User License Agreeement that a consumer of this listing has to accept
        :param pulumi.Input['MarketplacePublicationPackageDetailsOperatingSystemArgs'] operating_system: OS used by the listing.
        :param pulumi.Input[str] package_type: Type of the artifact of the listing
        :param pulumi.Input[str] package_version: The version of the package
        :param pulumi.Input[str] image_id: base image id of the listing
        """
        pulumi.set(__self__, "eulas", eulas)
        pulumi.set(__self__, "operating_system", operating_system)
        pulumi.set(__self__, "package_type", package_type)
        pulumi.set(__self__, "package_version", package_version)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)

    @property
    @pulumi.getter
    def eulas(self) -> pulumi.Input[Sequence[pulumi.Input['MarketplacePublicationPackageDetailsEulaArgs']]]:
        """
        End User License Agreeement that a consumer of this listing has to accept
        """
        return pulumi.get(self, "eulas")

    @eulas.setter
    def eulas(self, value: pulumi.Input[Sequence[pulumi.Input['MarketplacePublicationPackageDetailsEulaArgs']]]):
        pulumi.set(self, "eulas", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> pulumi.Input['MarketplacePublicationPackageDetailsOperatingSystemArgs']:
        """
        OS used by the listing.
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: pulumi.Input['MarketplacePublicationPackageDetailsOperatingSystemArgs']):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter(name="packageType")
    def package_type(self) -> pulumi.Input[str]:
        """
        Type of the artifact of the listing
        """
        return pulumi.get(self, "package_type")

    @package_type.setter
    def package_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "package_type", value)

    @property
    @pulumi.getter(name="packageVersion")
    def package_version(self) -> pulumi.Input[str]:
        """
        The version of the package
        """
        return pulumi.get(self, "package_version")

    @package_version.setter
    def package_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "package_version", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        base image id of the listing
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)


@pulumi.input_type
class MarketplacePublicationPackageDetailsEulaArgs:
    def __init__(__self__, *,
                 eula_type: pulumi.Input[str],
                 license_text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] eula_type: the specified eula's type
        :param pulumi.Input[str] license_text: text of the eula
        """
        pulumi.set(__self__, "eula_type", eula_type)
        if license_text is not None:
            pulumi.set(__self__, "license_text", license_text)

    @property
    @pulumi.getter(name="eulaType")
    def eula_type(self) -> pulumi.Input[str]:
        """
        the specified eula's type
        """
        return pulumi.get(self, "eula_type")

    @eula_type.setter
    def eula_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "eula_type", value)

    @property
    @pulumi.getter(name="licenseText")
    def license_text(self) -> Optional[pulumi.Input[str]]:
        """
        text of the eula
        """
        return pulumi.get(self, "license_text")

    @license_text.setter
    def license_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "license_text", value)


@pulumi.input_type
class MarketplacePublicationPackageDetailsOperatingSystemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The name of the contact.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the contact.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class MarketplacePublicationSupportContactArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 phone: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] email: (Updatable) The email of the contact.
        :param pulumi.Input[str] name: (Updatable) The name of the contact.
        :param pulumi.Input[str] phone: (Updatable) The phone number of the contact.
        :param pulumi.Input[str] subject: (Updatable) The email subject line to use when contacting support.
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if phone is not None:
            pulumi.set(__self__, "phone", phone)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email of the contact.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the contact.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def phone(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The phone number of the contact.
        """
        return pulumi.get(self, "phone")

    @phone.setter
    def phone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "phone", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The email subject line to use when contacting support.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


@pulumi.input_type
class MarketplacePublicationSupportedOperatingSystemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The name of the contact.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the contact.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class MeteringComputationCustomTableSavedCustomTableArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 column_group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 compartment_depth: Optional[pulumi.Input[float]] = None,
                 group_by_tags: Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationCustomTableSavedCustomTableGroupByTagArgs']]]] = None,
                 row_group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 version: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) The name of the custom table.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] column_group_bies: (Updatable) The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param pulumi.Input[float] compartment_depth: (Updatable) The compartment depth level.
        :param pulumi.Input[Sequence[pulumi.Input['MeteringComputationCustomTableSavedCustomTableGroupByTagArgs']]] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] row_group_bies: (Updatable) The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param pulumi.Input[float] version: (Updatable) The version of the custom table.
        """
        pulumi.set(__self__, "display_name", display_name)
        if column_group_bies is not None:
            pulumi.set(__self__, "column_group_bies", column_group_bies)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if row_group_bies is not None:
            pulumi.set(__self__, "row_group_bies", row_group_bies)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the custom table.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="columnGroupBies")
    def column_group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The column groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "column_group_bies")

    @column_group_bies.setter
    def column_group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_group_bies", value)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @compartment_depth.setter
    def compartment_depth(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "compartment_depth", value)

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationCustomTableSavedCustomTableGroupByTagArgs']]]]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only one tag in the list is supported. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @group_by_tags.setter
    def group_by_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationCustomTableSavedCustomTableGroupByTagArgs']]]]):
        pulumi.set(self, "group_by_tags", value)

    @property
    @pulumi.getter(name="rowGroupBies")
    def row_group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The row groupBy key list. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "row_group_bies")

    @row_group_bies.setter
    def row_group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "row_group_bies", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The version of the custom table.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class MeteringComputationCustomTableSavedCustomTableGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: (Updatable) The tag key.
        :param pulumi.Input[str] namespace: (Updatable) The tag namespace.
        :param pulumi.Input[str] value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MeteringComputationQueryQueryDefinitionArgs:
    def __init__(__self__, *,
                 cost_analysis_ui: pulumi.Input['MeteringComputationQueryQueryDefinitionCostAnalysisUiArgs'],
                 display_name: pulumi.Input[str],
                 report_query: pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryArgs'],
                 version: pulumi.Input[float]):
        """
        :param pulumi.Input['MeteringComputationQueryQueryDefinitionCostAnalysisUiArgs'] cost_analysis_ui: (Updatable) The common fields for Cost Analysis UI rendering.
        :param pulumi.Input[str] display_name: (Updatable) The query display name. Avoid entering confidential information.
        :param pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryArgs'] report_query: (Updatable) The request of the generated Cost Analysis report.
        :param pulumi.Input[float] version: (Updatable) The saved query version.
        """
        pulumi.set(__self__, "cost_analysis_ui", cost_analysis_ui)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "report_query", report_query)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="costAnalysisUi")
    def cost_analysis_ui(self) -> pulumi.Input['MeteringComputationQueryQueryDefinitionCostAnalysisUiArgs']:
        """
        (Updatable) The common fields for Cost Analysis UI rendering.
        """
        return pulumi.get(self, "cost_analysis_ui")

    @cost_analysis_ui.setter
    def cost_analysis_ui(self, value: pulumi.Input['MeteringComputationQueryQueryDefinitionCostAnalysisUiArgs']):
        pulumi.set(self, "cost_analysis_ui", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The query display name. Avoid entering confidential information.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="reportQuery")
    def report_query(self) -> pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryArgs']:
        """
        (Updatable) The request of the generated Cost Analysis report.
        """
        return pulumi.get(self, "report_query")

    @report_query.setter
    def report_query(self, value: pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryArgs']):
        pulumi.set(self, "report_query", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[float]:
        """
        (Updatable) The saved query version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[float]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class MeteringComputationQueryQueryDefinitionCostAnalysisUiArgs:
    def __init__(__self__, *,
                 graph: Optional[pulumi.Input[str]] = None,
                 is_cumulative_graph: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] graph: (Updatable) The graph type.
        :param pulumi.Input[bool] is_cumulative_graph: (Updatable) A cumulative graph.
        """
        if graph is not None:
            pulumi.set(__self__, "graph", graph)
        if is_cumulative_graph is not None:
            pulumi.set(__self__, "is_cumulative_graph", is_cumulative_graph)

    @property
    @pulumi.getter
    def graph(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The graph type.
        """
        return pulumi.get(self, "graph")

    @graph.setter
    def graph(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graph", value)

    @property
    @pulumi.getter(name="isCumulativeGraph")
    def is_cumulative_graph(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) A cumulative graph.
        """
        return pulumi.get(self, "is_cumulative_graph")

    @is_cumulative_graph.setter
    def is_cumulative_graph(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cumulative_graph", value)


@pulumi.input_type
class MeteringComputationQueryQueryDefinitionReportQueryArgs:
    def __init__(__self__, *,
                 granularity: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 compartment_depth: Optional[pulumi.Input[float]] = None,
                 date_range_name: Optional[pulumi.Input[str]] = None,
                 filter: Optional[pulumi.Input[str]] = None,
                 forecast: Optional[pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryForecastArgs']] = None,
                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 group_by_tags: Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryGroupByTagArgs']]]] = None,
                 is_aggregate_by_time: Optional[pulumi.Input[bool]] = None,
                 query_type: Optional[pulumi.Input[str]] = None,
                 time_usage_ended: Optional[pulumi.Input[str]] = None,
                 time_usage_started: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] granularity: (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        :param pulumi.Input[str] tenant_id: (Updatable) Tenant ID.
        :param pulumi.Input[float] compartment_depth: (Updatable) The compartment depth level.
        :param pulumi.Input[str] date_range_name: (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        :param pulumi.Input[str] filter: (Updatable)
        :param pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryForecastArgs'] forecast: (Updatable) Forecast configuration of usage/cost.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: (Updatable) Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        :param pulumi.Input[Sequence[pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryGroupByTagArgs']]] group_by_tags: (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        :param pulumi.Input[bool] is_aggregate_by_time: (Updatable) Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        :param pulumi.Input[str] query_type: (Updatable) The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        :param pulumi.Input[str] time_usage_ended: (Updatable) The usage end time.
        :param pulumi.Input[str] time_usage_started: (Updatable) The usage start time.
        """
        pulumi.set(__self__, "granularity", granularity)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if compartment_depth is not None:
            pulumi.set(__self__, "compartment_depth", compartment_depth)
        if date_range_name is not None:
            pulumi.set(__self__, "date_range_name", date_range_name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if forecast is not None:
            pulumi.set(__self__, "forecast", forecast)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if group_by_tags is not None:
            pulumi.set(__self__, "group_by_tags", group_by_tags)
        if is_aggregate_by_time is not None:
            pulumi.set(__self__, "is_aggregate_by_time", is_aggregate_by_time)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)

    @property
    @pulumi.getter
    def granularity(self) -> pulumi.Input[str]:
        """
        (Updatable) The usage granularity. HOURLY - Hourly data aggregation. DAILY - Daily data aggregation. MONTHLY - Monthly data aggregation. TOTAL - Not yet supported.
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: pulumi.Input[str]):
        pulumi.set(self, "granularity", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="compartmentDepth")
    def compartment_depth(self) -> Optional[pulumi.Input[float]]:
        """
        (Updatable) The compartment depth level.
        """
        return pulumi.get(self, "compartment_depth")

    @compartment_depth.setter
    def compartment_depth(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "compartment_depth", value)

    @property
    @pulumi.getter(name="dateRangeName")
    def date_range_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The UI date range, for example, LAST_THREE_MONTHS. Conflicts with timeUsageStarted and timeUsageEnded.
        """
        return pulumi.get(self, "date_range_name")

    @date_range_name.setter
    def date_range_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_range_name", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable)
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def forecast(self) -> Optional[pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryForecastArgs']]:
        """
        (Updatable) Forecast configuration of usage/cost.
        """
        return pulumi.get(self, "forecast")

    @forecast.setter
    def forecast(self, value: Optional[pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryForecastArgs']]):
        pulumi.set(self, "forecast", value)

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) Aggregate the result by. example: `["tagNamespace", "tagKey", "tagValue", "service", "skuName", "skuPartNumber", "unit", "compartmentName", "compartmentPath", "compartmentId", "platform", "region", "logicalAd", "resourceId", "tenantId", "tenantName"]`
        """
        return pulumi.get(self, "group_bies")

    @group_bies.setter
    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "group_bies", value)

    @property
    @pulumi.getter(name="groupByTags")
    def group_by_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryGroupByTagArgs']]]]:
        """
        (Updatable) GroupBy a specific tagKey. Provide the tagNamespace and tagKey in the tag object. Only supports one tag in the list. For example: `[{"namespace":"oracle", "key":"createdBy"]`
        """
        return pulumi.get(self, "group_by_tags")

    @group_by_tags.setter
    def group_by_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationQueryQueryDefinitionReportQueryGroupByTagArgs']]]]):
        pulumi.set(self, "group_by_tags", value)

    @property
    @pulumi.getter(name="isAggregateByTime")
    def is_aggregate_by_time(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether aggregated by time. If isAggregateByTime is true, all usage/cost over the query time period will be added up.
        """
        return pulumi.get(self, "is_aggregate_by_time")

    @is_aggregate_by_time.setter
    def is_aggregate_by_time(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_aggregate_by_time", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The query usage type. COST by default if it is missing. Usage - Query the usage data. Cost - Query the cost/billing data. Credit - Query the credit adjustments data. ExpiredCredit - Query the expired credits data AllCredit - Query the credit adjustments and expired credit
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_type", value)

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @time_usage_ended.setter
    def time_usage_ended(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_usage_ended", value)

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @time_usage_started.setter
    def time_usage_started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_usage_started", value)


@pulumi.input_type
class MeteringComputationQueryQueryDefinitionReportQueryForecastArgs:
    def __init__(__self__, *,
                 time_forecast_ended: pulumi.Input[str],
                 forecast_type: Optional[pulumi.Input[str]] = None,
                 time_forecast_started: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] time_forecast_ended: (Updatable) The forecast end time.
        :param pulumi.Input[str] forecast_type: (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param pulumi.Input[str] time_forecast_started: (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        if forecast_type is not None:
            pulumi.set(__self__, "forecast_type", forecast_type)
        if time_forecast_started is not None:
            pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> pulumi.Input[str]:
        """
        (Updatable) The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @time_forecast_ended.setter
    def time_forecast_ended(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_forecast_ended", value)

    @property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @forecast_type.setter
    def forecast_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forecast_type", value)

    @property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")

    @time_forecast_started.setter
    def time_forecast_started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_forecast_started", value)


@pulumi.input_type
class MeteringComputationQueryQueryDefinitionReportQueryGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: (Updatable) The tag key.
        :param pulumi.Input[str] namespace: (Updatable) The tag namespace.
        :param pulumi.Input[str] value: (Updatable) The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MeteringComputationUsageForecastArgs:
    def __init__(__self__, *,
                 time_forecast_ended: pulumi.Input[str],
                 forecast_type: Optional[pulumi.Input[str]] = None,
                 time_forecast_started: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] time_forecast_ended: The forecast end time.
        :param pulumi.Input[str] forecast_type: BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        :param pulumi.Input[str] time_forecast_started: The forecast start time. Defaults to UTC-1 if not specified.
        """
        pulumi.set(__self__, "time_forecast_ended", time_forecast_ended)
        if forecast_type is not None:
            pulumi.set(__self__, "forecast_type", forecast_type)
        if time_forecast_started is not None:
            pulumi.set(__self__, "time_forecast_started", time_forecast_started)

    @property
    @pulumi.getter(name="timeForecastEnded")
    def time_forecast_ended(self) -> pulumi.Input[str]:
        """
        The forecast end time.
        """
        return pulumi.get(self, "time_forecast_ended")

    @time_forecast_ended.setter
    def time_forecast_ended(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_forecast_ended", value)

    @property
    @pulumi.getter(name="forecastType")
    def forecast_type(self) -> Optional[pulumi.Input[str]]:
        """
        BASIC uses the exponential smoothing (ETS) model to project future usage/costs based on history data. The basis for projections is a periodic set of equivalent historical days for which the projection is being made.
        """
        return pulumi.get(self, "forecast_type")

    @forecast_type.setter
    def forecast_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forecast_type", value)

    @property
    @pulumi.getter(name="timeForecastStarted")
    def time_forecast_started(self) -> Optional[pulumi.Input[str]]:
        """
        The forecast start time. Defaults to UTC-1 if not specified.
        """
        return pulumi.get(self, "time_forecast_started")

    @time_forecast_started.setter
    def time_forecast_started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_forecast_started", value)


@pulumi.input_type
class MeteringComputationUsageGroupByTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The tag key.
        :param pulumi.Input[str] namespace: The tag namespace.
        :param pulumi.Input[str] value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MeteringComputationUsageItemArgs:
    def __init__(__self__, *,
                 ad: Optional[pulumi.Input[str]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 compartment_name: Optional[pulumi.Input[str]] = None,
                 compartment_path: Optional[pulumi.Input[str]] = None,
                 computed_amount: Optional[pulumi.Input[float]] = None,
                 computed_quantity: Optional[pulumi.Input[float]] = None,
                 currency: Optional[pulumi.Input[str]] = None,
                 discount: Optional[pulumi.Input[float]] = None,
                 is_forecast: Optional[pulumi.Input[bool]] = None,
                 list_rate: Optional[pulumi.Input[float]] = None,
                 overage: Optional[pulumi.Input[str]] = None,
                 overages_flag: Optional[pulumi.Input[str]] = None,
                 platform: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_id: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 shape: Optional[pulumi.Input[str]] = None,
                 sku_name: Optional[pulumi.Input[str]] = None,
                 sku_part_number: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationUsageItemTagArgs']]]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 tenant_name: Optional[pulumi.Input[str]] = None,
                 time_usage_ended: Optional[pulumi.Input[str]] = None,
                 time_usage_started: Optional[pulumi.Input[str]] = None,
                 unit: Optional[pulumi.Input[str]] = None,
                 unit_price: Optional[pulumi.Input[float]] = None,
                 weight: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[str] ad: The availability domain of the usage.
        :param pulumi.Input[str] compartment_id: The compartment OCID.
        :param pulumi.Input[str] compartment_name: The compartment name.
        :param pulumi.Input[str] compartment_path: The compartment path, starting from root.
        :param pulumi.Input[float] computed_amount: The computed cost.
        :param pulumi.Input[float] computed_quantity: The usage number.
        :param pulumi.Input[str] currency: The price currency.
        :param pulumi.Input[float] discount: The discretionary discount applied to the SKU.
        :param pulumi.Input[bool] is_forecast: The forecasted data.
        :param pulumi.Input[float] list_rate: The SKU list rate (not discount).
        :param pulumi.Input[str] overage: The overage usage.
        :param pulumi.Input[str] overages_flag: The SPM OverageFlag.
        :param pulumi.Input[str] platform: Platform for the cost.
        :param pulumi.Input[str] region: The region of the usage.
        :param pulumi.Input[str] resource_id: The resource OCID that is incurring the cost.
        :param pulumi.Input[str] resource_name: The resource name that is incurring the cost.
        :param pulumi.Input[str] service: The service name that is incurring the cost.
        :param pulumi.Input[str] shape: The resource shape.
        :param pulumi.Input[str] sku_name: The SKU friendly name.
        :param pulumi.Input[str] sku_part_number: The SKU part number.
        :param pulumi.Input[str] subscription_id: The subscription ID.
        :param pulumi.Input[Sequence[pulumi.Input['MeteringComputationUsageItemTagArgs']]] tags: For grouping, a tag definition. For filtering, a definition and key.
        :param pulumi.Input[str] tenant_id: Tenant ID.
        :param pulumi.Input[str] tenant_name: The tenancy name.
        :param pulumi.Input[str] time_usage_ended: The usage end time.
        :param pulumi.Input[str] time_usage_started: The usage start time.
        :param pulumi.Input[str] unit: The usage unit.
        :param pulumi.Input[float] unit_price: The price per unit.
        :param pulumi.Input[float] weight: The resource size being metered.
        """
        if ad is not None:
            pulumi.set(__self__, "ad", ad)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if compartment_name is not None:
            pulumi.set(__self__, "compartment_name", compartment_name)
        if compartment_path is not None:
            pulumi.set(__self__, "compartment_path", compartment_path)
        if computed_amount is not None:
            pulumi.set(__self__, "computed_amount", computed_amount)
        if computed_quantity is not None:
            pulumi.set(__self__, "computed_quantity", computed_quantity)
        if currency is not None:
            pulumi.set(__self__, "currency", currency)
        if discount is not None:
            pulumi.set(__self__, "discount", discount)
        if is_forecast is not None:
            pulumi.set(__self__, "is_forecast", is_forecast)
        if list_rate is not None:
            pulumi.set(__self__, "list_rate", list_rate)
        if overage is not None:
            pulumi.set(__self__, "overage", overage)
        if overages_flag is not None:
            pulumi.set(__self__, "overages_flag", overages_flag)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if sku_name is not None:
            pulumi.set(__self__, "sku_name", sku_name)
        if sku_part_number is not None:
            pulumi.set(__self__, "sku_part_number", sku_part_number)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if time_usage_ended is not None:
            pulumi.set(__self__, "time_usage_ended", time_usage_ended)
        if time_usage_started is not None:
            pulumi.set(__self__, "time_usage_started", time_usage_started)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if unit_price is not None:
            pulumi.set(__self__, "unit_price", unit_price)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def ad(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain of the usage.
        """
        return pulumi.get(self, "ad")

    @ad.setter
    def ad(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ad", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The compartment OCID.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="compartmentName")
    def compartment_name(self) -> Optional[pulumi.Input[str]]:
        """
        The compartment name.
        """
        return pulumi.get(self, "compartment_name")

    @compartment_name.setter
    def compartment_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_name", value)

    @property
    @pulumi.getter(name="compartmentPath")
    def compartment_path(self) -> Optional[pulumi.Input[str]]:
        """
        The compartment path, starting from root.
        """
        return pulumi.get(self, "compartment_path")

    @compartment_path.setter
    def compartment_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_path", value)

    @property
    @pulumi.getter(name="computedAmount")
    def computed_amount(self) -> Optional[pulumi.Input[float]]:
        """
        The computed cost.
        """
        return pulumi.get(self, "computed_amount")

    @computed_amount.setter
    def computed_amount(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "computed_amount", value)

    @property
    @pulumi.getter(name="computedQuantity")
    def computed_quantity(self) -> Optional[pulumi.Input[float]]:
        """
        The usage number.
        """
        return pulumi.get(self, "computed_quantity")

    @computed_quantity.setter
    def computed_quantity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "computed_quantity", value)

    @property
    @pulumi.getter
    def currency(self) -> Optional[pulumi.Input[str]]:
        """
        The price currency.
        """
        return pulumi.get(self, "currency")

    @currency.setter
    def currency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "currency", value)

    @property
    @pulumi.getter
    def discount(self) -> Optional[pulumi.Input[float]]:
        """
        The discretionary discount applied to the SKU.
        """
        return pulumi.get(self, "discount")

    @discount.setter
    def discount(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "discount", value)

    @property
    @pulumi.getter(name="isForecast")
    def is_forecast(self) -> Optional[pulumi.Input[bool]]:
        """
        The forecasted data.
        """
        return pulumi.get(self, "is_forecast")

    @is_forecast.setter
    def is_forecast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_forecast", value)

    @property
    @pulumi.getter(name="listRate")
    def list_rate(self) -> Optional[pulumi.Input[float]]:
        """
        The SKU list rate (not discount).
        """
        return pulumi.get(self, "list_rate")

    @list_rate.setter
    def list_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "list_rate", value)

    @property
    @pulumi.getter
    def overage(self) -> Optional[pulumi.Input[str]]:
        """
        The overage usage.
        """
        return pulumi.get(self, "overage")

    @overage.setter
    def overage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overage", value)

    @property
    @pulumi.getter(name="overagesFlag")
    def overages_flag(self) -> Optional[pulumi.Input[str]]:
        """
        The SPM OverageFlag.
        """
        return pulumi.get(self, "overages_flag")

    @overages_flag.setter
    def overages_flag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overages_flag", value)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[str]]:
        """
        Platform for the cost.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the usage.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The resource OCID that is incurring the cost.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_id", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        The resource name that is incurring the cost.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        """
        The service name that is incurring the cost.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input[str]]:
        """
        The resource shape.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter(name="skuName")
    def sku_name(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU friendly name.
        """
        return pulumi.get(self, "sku_name")

    @sku_name.setter
    def sku_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku_name", value)

    @property
    @pulumi.getter(name="skuPartNumber")
    def sku_part_number(self) -> Optional[pulumi.Input[str]]:
        """
        The SKU part number.
        """
        return pulumi.get(self, "sku_part_number")

    @sku_part_number.setter
    def sku_part_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sku_part_number", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        The subscription ID.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationUsageItemTagArgs']]]]:
        """
        For grouping, a tag definition. For filtering, a definition and key.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MeteringComputationUsageItemTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Tenant ID.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[str]]:
        """
        The tenancy name.
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_name", value)

    @property
    @pulumi.getter(name="timeUsageEnded")
    def time_usage_ended(self) -> Optional[pulumi.Input[str]]:
        """
        The usage end time.
        """
        return pulumi.get(self, "time_usage_ended")

    @time_usage_ended.setter
    def time_usage_ended(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_usage_ended", value)

    @property
    @pulumi.getter(name="timeUsageStarted")
    def time_usage_started(self) -> Optional[pulumi.Input[str]]:
        """
        The usage start time.
        """
        return pulumi.get(self, "time_usage_started")

    @time_usage_started.setter
    def time_usage_started(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_usage_started", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The usage unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter(name="unitPrice")
    def unit_price(self) -> Optional[pulumi.Input[float]]:
        """
        The price per unit.
        """
        return pulumi.get(self, "unit_price")

    @unit_price.setter
    def unit_price(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unit_price", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[float]]:
        """
        The resource size being metered.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class MeteringComputationUsageItemTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The tag key.
        :param pulumi.Input[str] namespace: The tag namespace.
        :param pulumi.Input[str] value: The tag value.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The tag namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MonitoringAlarmSuppressionArgs:
    def __init__(__self__, *,
                 time_suppress_from: pulumi.Input[str],
                 time_suppress_until: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] time_suppress_from: (Updatable) The start date and time for the suppression to take place, inclusive. Format defined by RFC3339.  Example: `2019-02-01T01:02:29.600Z`
        :param pulumi.Input[str] time_suppress_until: (Updatable) The end date and time for the suppression to take place, inclusive. Format defined by RFC3339.  Example: `2019-02-01T02:02:29.600Z`
        :param pulumi.Input[str] description: (Updatable) Human-readable reason for suppressing alarm notifications. It does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        pulumi.set(__self__, "time_suppress_from", time_suppress_from)
        pulumi.set(__self__, "time_suppress_until", time_suppress_until)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="timeSuppressFrom")
    def time_suppress_from(self) -> pulumi.Input[str]:
        """
        (Updatable) The start date and time for the suppression to take place, inclusive. Format defined by RFC3339.  Example: `2019-02-01T01:02:29.600Z`
        """
        return pulumi.get(self, "time_suppress_from")

    @time_suppress_from.setter
    def time_suppress_from(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_suppress_from", value)

    @property
    @pulumi.getter(name="timeSuppressUntil")
    def time_suppress_until(self) -> pulumi.Input[str]:
        """
        (Updatable) The end date and time for the suppression to take place, inclusive. Format defined by RFC3339.  Example: `2019-02-01T02:02:29.600Z`
        """
        return pulumi.get(self, "time_suppress_until")

    @time_suppress_until.setter
    def time_suppress_until(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_suppress_until", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Human-readable reason for suppressing alarm notifications. It does not have to be unique, and it's changeable. Avoid entering confidential information.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class MysqlAnalyticsClusterClusterNodeArgs:
    def __init__(__self__, *,
                 node_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_id: The ID of the node within MySQL Analytics Cluster.
        :param pulumi.Input[str] state: (Updatable) The target state for the Analytics Cluster. Could be set to `ACTIVE` or `INACTIVE`.
        :param pulumi.Input[str] time_created: The date and time the Analytics Cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param pulumi.Input[str] time_updated: The time the Analytics Cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the node within MySQL Analytics Cluster.
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target state for the Analytics Cluster. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the Analytics Cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time the Analytics Cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class MysqlChannelSourceArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 password: pulumi.Input[str],
                 source_type: pulumi.Input[str],
                 ssl_mode: pulumi.Input[str],
                 username: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 ssl_ca_certificate: Optional[pulumi.Input['MysqlChannelSourceSslCaCertificateArgs']] = None):
        """
        :param pulumi.Input[str] hostname: (Updatable) The network address of the MySQL instance.
        :param pulumi.Input[str] password: (Updatable) The password for the replication user. The password must be between 8 and 32 characters long, and must contain at least 1 numeric character, 1 lowercase character, 1 uppercase character, and 1 special (nonalphanumeric) character.
        :param pulumi.Input[str] source_type: (Updatable) The specific source identifier.
        :param pulumi.Input[str] ssl_mode: (Updatable) The SSL mode of the Channel.
        :param pulumi.Input[str] username: (Updatable) The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        :param pulumi.Input[int] port: (Updatable) The port the source MySQL instance listens on.
        :param pulumi.Input['MysqlChannelSourceSslCaCertificateArgs'] ssl_ca_certificate: (Updatable) The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "ssl_mode", ssl_mode)
        pulumi.set(__self__, "username", username)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl_ca_certificate is not None:
            pulumi.set(__self__, "ssl_ca_certificate", ssl_ca_certificate)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        (Updatable) The network address of the MySQL instance.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        (Updatable) The password for the replication user. The password must be between 8 and 32 characters long, and must contain at least 1 numeric character, 1 lowercase character, 1 uppercase character, and 1 special (nonalphanumeric) character.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The specific source identifier.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> pulumi.Input[str]:
        """
        (Updatable) The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssl_mode", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The port the source MySQL instance listens on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sslCaCertificate")
    def ssl_ca_certificate(self) -> Optional[pulumi.Input['MysqlChannelSourceSslCaCertificateArgs']]:
        """
        (Updatable) The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificate")

    @ssl_ca_certificate.setter
    def ssl_ca_certificate(self, value: Optional[pulumi.Input['MysqlChannelSourceSslCaCertificateArgs']]):
        pulumi.set(self, "ssl_ca_certificate", value)


@pulumi.input_type
class MysqlChannelSourceSslCaCertificateArgs:
    def __init__(__self__, *,
                 certificate_type: pulumi.Input[str],
                 contents: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_type: (Updatable) The type of CA certificate.
        :param pulumi.Input[str] contents: (Updatable) The string containing the CA certificate in PEM format.
        """
        pulumi.set(__self__, "certificate_type", certificate_type)
        pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_type", value)

    @property
    @pulumi.getter
    def contents(self) -> pulumi.Input[str]:
        """
        (Updatable) The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: pulumi.Input[str]):
        pulumi.set(self, "contents", value)


@pulumi.input_type
class MysqlChannelTargetArgs:
    def __init__(__self__, *,
                 db_system_id: pulumi.Input[str],
                 target_type: pulumi.Input[str],
                 applier_username: Optional[pulumi.Input[str]] = None,
                 channel_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] db_system_id: The OCID of the target DB System.
        :param pulumi.Input[str] target_type: (Updatable) The specific target identifier.
        :param pulumi.Input[str] applier_username: (Updatable) The username for the replication applier of the target MySQL DB System.
        :param pulumi.Input[str] channel_name: (Updatable) The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        pulumi.set(__self__, "db_system_id", db_system_id)
        pulumi.set(__self__, "target_type", target_type)
        if applier_username is not None:
            pulumi.set(__self__, "applier_username", applier_username)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> pulumi.Input[str]:
        """
        The OCID of the target DB System.
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_system_id", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The specific target identifier.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_type", value)

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @applier_username.setter
    def applier_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "applier_username", value)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_name", value)


@pulumi.input_type
class MysqlHeatWaveClusterClusterNodeArgs:
    def __init__(__self__, *,
                 node_id: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] node_id: The ID of the node within MySQL HeatWave cluster.
        :param pulumi.Input[str] state: (Updatable) The target state for the HeatWave cluster. Could be set to `ACTIVE` or `INACTIVE`.
        :param pulumi.Input[str] time_created: The date and time the HeatWave cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        :param pulumi.Input[str] time_updated: The time the HeatWave cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the node within MySQL HeatWave cluster.
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target state for the HeatWave cluster. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the HeatWave cluster was created, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time the HeatWave cluster was last updated, as described by [RFC 3339](https://tools.ietf.org/rfc/rfc3339).
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class MysqlMysqlBackupDbSystemSnapshotArgs:
    def __init__(__self__, *,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 backup_policy: Optional[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotBackupPolicyArgs']] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 configuration_id: Optional[pulumi.Input[str]] = None,
                 data_storage_size_in_gb: Optional[pulumi.Input[int]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotEndpointArgs']]]] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 hostname_label: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 is_highly_available: Optional[pulumi.Input[bool]] = None,
                 maintenance: Optional[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotMaintenanceArgs']] = None,
                 mysql_version: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 port_x: Optional[pulumi.Input[int]] = None,
                 shape_name: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_username: The username for the administrative user.
        :param pulumi.Input[str] availability_domain: The Availability Domain where the primary DB System should be located.
        :param pulumi.Input['MysqlMysqlBackupDbSystemSnapshotBackupPolicyArgs'] backup_policy: The Backup policy for the DB System.
        :param pulumi.Input[str] compartment_id: (Updatable) The OCID of the compartment.
        :param pulumi.Input[str] configuration_id: The OCID of the Configuration to be used for Instances in this DB System.
        :param pulumi.Input[int] data_storage_size_in_gb: Initial size of the data volume in GiBs that will be created and attached.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param pulumi.Input[str] description: (Updatable) A user-supplied description for the backup.
        :param pulumi.Input[str] display_name: (Updatable) A user-supplied display name for the backup.
        :param pulumi.Input[Sequence[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotEndpointArgs']]] endpoints: The network endpoints available for this DB System.
        :param pulumi.Input[str] fault_domain: The name of the Fault Domain the DB System is located in.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param pulumi.Input[str] hostname_label: The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        :param pulumi.Input[str] id: OCID of the backup itself
        :param pulumi.Input[str] ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param pulumi.Input[bool] is_highly_available: If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        :param pulumi.Input['MysqlMysqlBackupDbSystemSnapshotMaintenanceArgs'] maintenance: The Maintenance Policy for the DB System.
        :param pulumi.Input[str] mysql_version: The MySQL server version of the DB System used for backup.
        :param pulumi.Input[int] port: The port for primary endpoint of the DB System to listen on.
        :param pulumi.Input[int] port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param pulumi.Input[str] shape_name: The shape of the DB System instance used for backup.
        :param pulumi.Input[str] subnet_id: The OCID of the subnet the DB System is associated with.
        """
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if backup_policy is not None:
            pulumi.set(__self__, "backup_policy", backup_policy)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if configuration_id is not None:
            pulumi.set(__self__, "configuration_id", configuration_id)
        if data_storage_size_in_gb is not None:
            pulumi.set(__self__, "data_storage_size_in_gb", data_storage_size_in_gb)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if hostname_label is not None:
            pulumi.set(__self__, "hostname_label", hostname_label)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_highly_available is not None:
            pulumi.set(__self__, "is_highly_available", is_highly_available)
        if maintenance is not None:
            pulumi.set(__self__, "maintenance", maintenance)
        if mysql_version is not None:
            pulumi.set(__self__, "mysql_version", mysql_version)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_x is not None:
            pulumi.set(__self__, "port_x", port_x)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        The username for the administrative user.
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The Availability Domain where the primary DB System should be located.
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="backupPolicy")
    def backup_policy(self) -> Optional[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotBackupPolicyArgs']]:
        """
        The Backup policy for the DB System.
        """
        return pulumi.get(self, "backup_policy")

    @backup_policy.setter
    def backup_policy(self, value: Optional[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotBackupPolicyArgs']]):
        pulumi.set(self, "backup_policy", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="configurationId")
    def configuration_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the Configuration to be used for Instances in this DB System.
        """
        return pulumi.get(self, "configuration_id")

    @configuration_id.setter
    def configuration_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration_id", value)

    @property
    @pulumi.getter(name="dataStorageSizeInGb")
    def data_storage_size_in_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Initial size of the data volume in GiBs that will be created and attached.
        """
        return pulumi.get(self, "data_storage_size_in_gb")

    @data_storage_size_in_gb.setter
    def data_storage_size_in_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "data_storage_size_in_gb", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-supplied description for the backup.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A user-supplied display name for the backup.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotEndpointArgs']]]]:
        """
        The network endpoints available for this DB System.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Fault Domain the DB System is located in.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="hostnameLabel")
    def hostname_label(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname for the primary endpoint of the DB System. Used for DNS. The value is the hostname portion of the primary private IP's fully qualified domain name (FQDN) (for example, "dbsystem-1" in FQDN "dbsystem-1.subnet123.vcn1.oraclevcn.com"). Must be unique across all VNICs in the subnet and comply with RFC 952 and RFC 1123.
        """
        return pulumi.get(self, "hostname_label")

    @hostname_label.setter
    def hostname_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_label", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        OCID of the backup itself
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="isHighlyAvailable")
    def is_highly_available(self) -> Optional[pulumi.Input[bool]]:
        """
        If the policy is to enable high availability of the instance, by maintaining secondary/failover capacity as necessary.
        """
        return pulumi.get(self, "is_highly_available")

    @is_highly_available.setter
    def is_highly_available(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_highly_available", value)

    @property
    @pulumi.getter
    def maintenance(self) -> Optional[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotMaintenanceArgs']]:
        """
        The Maintenance Policy for the DB System.
        """
        return pulumi.get(self, "maintenance")

    @maintenance.setter
    def maintenance(self, value: Optional[pulumi.Input['MysqlMysqlBackupDbSystemSnapshotMaintenanceArgs']]):
        pulumi.set(self, "maintenance", value)

    @property
    @pulumi.getter(name="mysqlVersion")
    def mysql_version(self) -> Optional[pulumi.Input[str]]:
        """
        The MySQL server version of the DB System used for backup.
        """
        return pulumi.get(self, "mysql_version")

    @mysql_version.setter
    def mysql_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mysql_version", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> Optional[pulumi.Input[int]]:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @port_x.setter
    def port_x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_x", value)

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[str]]:
        """
        The shape of the DB System instance used for backup.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape_name", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the subnet the DB System is associated with.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class MysqlMysqlBackupDbSystemSnapshotBackupPolicyArgs:
    def __init__(__self__, *,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 retention_in_days: Optional[pulumi.Input[int]] = None,
                 window_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param pulumi.Input[bool] is_enabled: If automated backups are enabled or disabled.
        :param pulumi.Input[int] retention_in_days: (Updatable) Number of days to retain this backup.
        :param pulumi.Input[str] window_start_time: The start time of the maintenance window.
        """
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If automated backups are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days to retain this backup.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")

    @window_start_time.setter
    def window_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "window_start_time", value)


@pulumi.input_type
class MysqlMysqlBackupDbSystemSnapshotEndpointArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 port_x: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 status_details: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: The network address of the DB System.
        :param pulumi.Input[str] ip_address: The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] modes: The access modes from the client that this endpoint supports.
        :param pulumi.Input[int] port: The port for primary endpoint of the DB System to listen on.
        :param pulumi.Input[int] port_x: The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        :param pulumi.Input[str] status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param pulumi.Input[str] status_details: Additional information about the current endpoint status.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if modes is not None:
            pulumi.set(__self__, "modes", modes)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_x is not None:
            pulumi.set(__self__, "port_x", port_x)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_details is not None:
            pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address the DB System is configured to listen on. A private IP address of the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. This will be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @modes.setter
    def modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "modes", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> Optional[pulumi.Input[int]]:
        """
        The network port on which X Plugin listens for TCP/IP connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @port_x.setter
    def port_x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_x", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")

    @status_details.setter
    def status_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_details", value)


@pulumi.input_type
class MysqlMysqlBackupDbSystemSnapshotMaintenanceArgs:
    def __init__(__self__, *,
                 window_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] window_start_time: The start time of the maintenance window.
        """
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The start time of the maintenance window.
        """
        return pulumi.get(self, "window_start_time")

    @window_start_time.setter
    def window_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "window_start_time", value)


@pulumi.input_type
class MysqlMysqlDbSystemAnalyticsClusterArgs:
    def __init__(__self__, *,
                 cluster_size: Optional[pulumi.Input[int]] = None,
                 shape_name: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param pulumi.Input[str] shape_name: The name of the shape. The shape determines the resources allocated
               * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        :param pulumi.Input[str] state: (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        :param pulumi.Input[str] time_created: The date and time the DB System was created.
        :param pulumi.Input[str] time_updated: The time the DB System was last updated.
        """
        if cluster_size is not None:
            pulumi.set(__self__, "cluster_size", cluster_size)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @cluster_size.setter
    def cluster_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_size", value)

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the shape. The shape determines the resources allocated
        * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape_name", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class MysqlMysqlDbSystemBackupPolicyArgs:
    def __init__(__self__, *,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 retention_in_days: Optional[pulumi.Input[int]] = None,
                 window_start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param pulumi.Input[bool] is_enabled: (Updatable) Specifies if automatic backups are enabled.
        :param pulumi.Input[int] retention_in_days: (Updatable) Number of days to retain an automatic backup.
        :param pulumi.Input[str] window_start_time: (Updatable) The start of the 2 hour maintenance window.
        """
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if retention_in_days is not None:
            pulumi.set(__self__, "retention_in_days", retention_in_days)
        if window_start_time is not None:
            pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Specifies if automatic backups are enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="retentionInDays")
    def retention_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of days to retain an automatic backup.
        """
        return pulumi.get(self, "retention_in_days")

    @retention_in_days.setter
    def retention_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_in_days", value)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The start of the 2 hour maintenance window.
        """
        return pulumi.get(self, "window_start_time")

    @window_start_time.setter
    def window_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "window_start_time", value)


@pulumi.input_type
class MysqlMysqlDbSystemChannelArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 defined_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 freeform_tags: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 lifecycle_details: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input['MysqlMysqlDbSystemChannelSourceArgs']] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input['MysqlMysqlDbSystemChannelTargetArgs']] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: The OCID of the compartment.
        :param pulumi.Input[Mapping[str, Any]] defined_tags: (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        :param pulumi.Input[str] display_name: (Updatable) The user-friendly name for the DB System. It does not have to be unique.
        :param pulumi.Input[Mapping[str, Any]] freeform_tags: (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        :param pulumi.Input[str] id: The OCID of the DB System.
        :param pulumi.Input[bool] is_enabled: (Updatable) Specifies if automatic backups are enabled.
        :param pulumi.Input[str] lifecycle_details: Additional information about the current lifecycleState.
        :param pulumi.Input['MysqlMysqlDbSystemChannelSourceArgs'] source: Parameters detailing how to provision the initial data of the system.
        :param pulumi.Input[str] state: (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        :param pulumi.Input['MysqlMysqlDbSystemChannelTargetArgs'] target: Details about the Channel target.
        :param pulumi.Input[str] time_created: The date and time the DB System was created.
        :param pulumi.Input[str] time_updated: The time the DB System was last updated.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if defined_tags is not None:
            pulumi.set(__self__, "defined_tags", defined_tags)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if freeform_tags is not None:
            pulumi.set(__self__, "freeform_tags", freeform_tags)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if lifecycle_details is not None:
            pulumi.set(__self__, "lifecycle_details", lifecycle_details)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compartment.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="definedTags")
    def defined_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Usage of predefined tag keys. These predefined keys are scoped to namespaces. Example: `{"foo-namespace.bar-key": "value"}`
        """
        return pulumi.get(self, "defined_tags")

    @defined_tags.setter
    def defined_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "defined_tags", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The user-friendly name for the DB System. It does not have to be unique.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="freeformTags")
    def freeform_tags(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) Simple key-value pair applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{"bar-key": "value"}`
        """
        return pulumi.get(self, "freeform_tags")

    @freeform_tags.setter
    def freeform_tags(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "freeform_tags", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the DB System.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Specifies if automatic backups are enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="lifecycleDetails")
    def lifecycle_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current lifecycleState.
        """
        return pulumi.get(self, "lifecycle_details")

    @lifecycle_details.setter
    def lifecycle_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_details", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['MysqlMysqlDbSystemChannelSourceArgs']]:
        """
        Parameters detailing how to provision the initial data of the system.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['MysqlMysqlDbSystemChannelSourceArgs']]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input['MysqlMysqlDbSystemChannelTargetArgs']]:
        """
        Details about the Channel target.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input['MysqlMysqlDbSystemChannelTargetArgs']]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class MysqlMysqlDbSystemChannelSourceArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 source_type: Optional[pulumi.Input[str]] = None,
                 ssl_ca_certificate: Optional[pulumi.Input['MysqlMysqlDbSystemChannelSourceSslCaCertificateArgs']] = None,
                 ssl_mode: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: The network address of the DB System.
        :param pulumi.Input[int] port: The port for primary endpoint of the DB System to listen on.
        :param pulumi.Input[str] source_type: The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        :param pulumi.Input['MysqlMysqlDbSystemChannelSourceSslCaCertificateArgs'] ssl_ca_certificate: The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        :param pulumi.Input[str] ssl_mode: The SSL mode of the Channel.
        :param pulumi.Input[str] username: The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)
        if ssl_ca_certificate is not None:
            pulumi.set(__self__, "ssl_ca_certificate", ssl_ca_certificate)
        if ssl_mode is not None:
            pulumi.set(__self__, "ssl_mode", ssl_mode)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="sslCaCertificate")
    def ssl_ca_certificate(self) -> Optional[pulumi.Input['MysqlMysqlDbSystemChannelSourceSslCaCertificateArgs']]:
        """
        The CA certificate of the server used for VERIFY_IDENTITY and VERIFY_CA ssl modes.
        """
        return pulumi.get(self, "ssl_ca_certificate")

    @ssl_ca_certificate.setter
    def ssl_ca_certificate(self, value: Optional[pulumi.Input['MysqlMysqlDbSystemChannelSourceSslCaCertificateArgs']]):
        pulumi.set(self, "ssl_ca_certificate", value)

    @property
    @pulumi.getter(name="sslMode")
    def ssl_mode(self) -> Optional[pulumi.Input[str]]:
        """
        The SSL mode of the Channel.
        """
        return pulumi.get(self, "ssl_mode")

    @ssl_mode.setter
    def ssl_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl_mode", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the replication user on the source MySQL instance. The username has a maximum length of 96 characters. For more information, please see the [MySQL documentation](https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class MysqlMysqlDbSystemChannelSourceSslCaCertificateArgs:
    def __init__(__self__, *,
                 certificate_type: Optional[pulumi.Input[str]] = None,
                 contents: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] certificate_type: The type of CA certificate.
        :param pulumi.Input[str] contents: The string containing the CA certificate in PEM format.
        """
        if certificate_type is not None:
            pulumi.set(__self__, "certificate_type", certificate_type)
        if contents is not None:
            pulumi.set(__self__, "contents", contents)

    @property
    @pulumi.getter(name="certificateType")
    def certificate_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of CA certificate.
        """
        return pulumi.get(self, "certificate_type")

    @certificate_type.setter
    def certificate_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_type", value)

    @property
    @pulumi.getter
    def contents(self) -> Optional[pulumi.Input[str]]:
        """
        The string containing the CA certificate in PEM format.
        """
        return pulumi.get(self, "contents")

    @contents.setter
    def contents(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "contents", value)


@pulumi.input_type
class MysqlMysqlDbSystemChannelTargetArgs:
    def __init__(__self__, *,
                 applier_username: Optional[pulumi.Input[str]] = None,
                 channel_name: Optional[pulumi.Input[str]] = None,
                 db_system_id: Optional[pulumi.Input[str]] = None,
                 target_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] applier_username: The username for the replication applier of the target MySQL DB System.
        :param pulumi.Input[str] channel_name: The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        :param pulumi.Input[str] db_system_id: The OCID of the source DB System.
        :param pulumi.Input[str] target_type: The specific target identifier.
        """
        if applier_username is not None:
            pulumi.set(__self__, "applier_username", applier_username)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if db_system_id is not None:
            pulumi.set(__self__, "db_system_id", db_system_id)
        if target_type is not None:
            pulumi.set(__self__, "target_type", target_type)

    @property
    @pulumi.getter(name="applierUsername")
    def applier_username(self) -> Optional[pulumi.Input[str]]:
        """
        The username for the replication applier of the target MySQL DB System.
        """
        return pulumi.get(self, "applier_username")

    @applier_username.setter
    def applier_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "applier_username", value)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[pulumi.Input[str]]:
        """
        The case-insensitive name that identifies the replication channel. Channel names must follow the rules defined for [MySQL identifiers](https://dev.mysql.com/doc/refman/8.0/en/identifiers.html). The names of non-Deleted Channels must be unique for each DB System.
        """
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_name", value)

    @property
    @pulumi.getter(name="dbSystemId")
    def db_system_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the source DB System.
        """
        return pulumi.get(self, "db_system_id")

    @db_system_id.setter
    def db_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_system_id", value)

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> Optional[pulumi.Input[str]]:
        """
        The specific target identifier.
        """
        return pulumi.get(self, "target_type")

    @target_type.setter
    def target_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_type", value)


@pulumi.input_type
class MysqlMysqlDbSystemCurrentPlacementArgs:
    def __init__(__self__, *,
                 availability_domain: Optional[pulumi.Input[str]] = None,
                 fault_domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] availability_domain: The availability domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        :param pulumi.Input[str] fault_domain: The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        if availability_domain is not None:
            pulumi.set(__self__, "availability_domain", availability_domain)
        if fault_domain is not None:
            pulumi.set(__self__, "fault_domain", fault_domain)

    @property
    @pulumi.getter(name="availabilityDomain")
    def availability_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        return pulumi.get(self, "availability_domain")

    @availability_domain.setter
    def availability_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_domain", value)

    @property
    @pulumi.getter(name="faultDomain")
    def fault_domain(self) -> Optional[pulumi.Input[str]]:
        """
        The fault domain on which to deploy the Read/Write endpoint. This defines the preferred primary instance.
        """
        return pulumi.get(self, "fault_domain")

    @fault_domain.setter
    def fault_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain", value)


@pulumi.input_type
class MysqlMysqlDbSystemEndpointArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 modes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 port_x: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 status_details: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: The network address of the DB System.
        :param pulumi.Input[str] ip_address: The IP address the DB System is configured to listen on. A private IP address of your choice to assign to the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This should be a "dotted-quad" style IPv4 address.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] modes: The access modes from the client that this endpoint supports.
        :param pulumi.Input[int] port: The port for primary endpoint of the DB System to listen on.
        :param pulumi.Input[int] port_x: The TCP network port on which X Plugin listens for connections. This is the X Plugin equivalent of port.
        :param pulumi.Input[str] status: The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        :param pulumi.Input[str] status_details: Additional information about the current endpoint status.
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if modes is not None:
            pulumi.set(__self__, "modes", modes)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_x is not None:
            pulumi.set(__self__, "port_x", port_x)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if status_details is not None:
            pulumi.set(__self__, "status_details", status_details)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The network address of the DB System.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address the DB System is configured to listen on. A private IP address of your choice to assign to the primary endpoint of the DB System. Must be an available IP address within the subnet's CIDR. If you don't specify a value, Oracle automatically assigns a private IP address from the subnet. This should be a "dotted-quad" style IPv4 address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def modes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The access modes from the client that this endpoint supports.
        """
        return pulumi.get(self, "modes")

    @modes.setter
    def modes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "modes", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port for primary endpoint of the DB System to listen on.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portX")
    def port_x(self) -> Optional[pulumi.Input[int]]:
        """
        The TCP network port on which X Plugin listens for connections. This is the X Plugin equivalent of port.
        """
        return pulumi.get(self, "port_x")

    @port_x.setter
    def port_x(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port_x", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The state of the endpoints, as far as it can seen from the DB System. There may be some inconsistency with the actual state of the MySQL service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="statusDetails")
    def status_details(self) -> Optional[pulumi.Input[str]]:
        """
        Additional information about the current endpoint status.
        """
        return pulumi.get(self, "status_details")

    @status_details.setter
    def status_details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status_details", value)


@pulumi.input_type
class MysqlMysqlDbSystemHeatWaveClusterArgs:
    def __init__(__self__, *,
                 cluster_size: Optional[pulumi.Input[int]] = None,
                 shape_name: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_updated: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] cluster_size: The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        :param pulumi.Input[str] shape_name: The name of the shape. The shape determines the resources allocated
               * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        :param pulumi.Input[str] state: (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        :param pulumi.Input[str] time_created: The date and time the DB System was created.
        :param pulumi.Input[str] time_updated: The time the DB System was last updated.
        """
        if cluster_size is not None:
            pulumi.set(__self__, "cluster_size", cluster_size)
        if shape_name is not None:
            pulumi.set(__self__, "shape_name", shape_name)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_updated is not None:
            pulumi.set(__self__, "time_updated", time_updated)

    @property
    @pulumi.getter(name="clusterSize")
    def cluster_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of analytics-processing compute instances, of the specified shape, in the HeatWave cluster.
        """
        return pulumi.get(self, "cluster_size")

    @cluster_size.setter
    def cluster_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cluster_size", value)

    @property
    @pulumi.getter(name="shapeName")
    def shape_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the shape. The shape determines the resources allocated
        * CPU cores and memory for VM shapes; CPU cores, memory and storage for non-VM (or bare metal) shapes. To get a list of shapes, use the [ListShapes](https://docs.cloud.oracle.com/iaas/api/#/en/mysql/20190415/ShapeSummary/ListShapes) operation.
        """
        return pulumi.get(self, "shape_name")

    @shape_name.setter
    def shape_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shape_name", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target state for the DB System. Could be set to `ACTIVE` or `INACTIVE`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the DB System was created.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeUpdated")
    def time_updated(self) -> Optional[pulumi.Input[str]]:
        """
        The time the DB System was last updated.
        """
        return pulumi.get(self, "time_updated")

    @time_updated.setter
    def time_updated(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_updated", value)


@pulumi.input_type
class MysqlMysqlDbSystemMaintenanceArgs:
    def __init__(__self__, *,
                 window_start_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] window_start_time: (Updatable) The start of the 2 hour maintenance window.
        """
        pulumi.set(__self__, "window_start_time", window_start_time)

    @property
    @pulumi.getter(name="windowStartTime")
    def window_start_time(self) -> pulumi.Input[str]:
        """
        (Updatable) The start of the 2 hour maintenance window.
        """
        return pulumi.get(self, "window_start_time")

    @window_start_time.setter
    def window_start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "window_start_time", value)


@pulumi.input_type
class MysqlMysqlDbSystemSourceArgs:
    def __init__(__self__, *,
                 source_type: pulumi.Input[str],
                 backup_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] source_type: The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        :param pulumi.Input[str] backup_id: The OCID of the backup to be used as the source for the new DB System.
        """
        pulumi.set(__self__, "source_type", source_type)
        if backup_id is not None:
            pulumi.set(__self__, "backup_id", backup_id)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        The specific source identifier. Use `BACKUP` for creating a new database by restoring from a backup.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)

    @property
    @pulumi.getter(name="backupId")
    def backup_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the backup to be used as the source for the new DB System.
        """
        return pulumi.get(self, "backup_id")

    @backup_id.setter
    def backup_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_id", value)


@pulumi.input_type
class NetworkLoadBalancerBackendSetBackendArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 ip_address: Optional[pulumi.Input[str]] = None,
                 is_backup: Optional[pulumi.Input[bool]] = None,
                 is_drain: Optional[pulumi.Input[bool]] = None,
                 is_offline: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 target_id: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] port: (Updatable) The backend server port against which to run the health check. If the port is not specified, then the network load balancer uses the port information from the `Backend` object. The port must be specified if the backend port is 0.  Example: `8080`
        :param pulumi.Input[str] ip_address: The IP address of the backend server. Example: `10.0.0.3`
        :param pulumi.Input[bool] is_backup: Whether the network load balancer should treat this server as a backup unit. If `true`, then the network load balancer forwards no ingress traffic to this backend server unless all other backend servers not marked as "isBackup" fail the health check policy.  Example: `false`
        :param pulumi.Input[bool] is_drain: Whether the network load balancer should drain this server. Servers marked "isDrain" receive no  incoming traffic.  Example: `false`
        :param pulumi.Input[bool] is_offline: Whether the network load balancer should treat this server as offline. Offline servers receive no incoming traffic.  Example: `false`
        :param pulumi.Input[str] name: A user-friendly name for the backend set that must be unique and cannot be changed.
        :param pulumi.Input[str] target_id: The IP OCID/Instance OCID associated with the backend server. Example: `ocid1.privateip..oc1.<var>&lt;unique_ID&gt;</var>`
        :param pulumi.Input[int] weight: The network load balancing policy weight assigned to the server. Backend servers with a higher weight receive a larger proportion of incoming traffic. For example, a server weighted '3' receives three times the number of new connections as a server weighted '1'. For more information about load balancing policies, see [How Network Load Balancing Policies Work](https://docs.cloud.oracle.com/iaas/Content/Balance/Reference/lbpolicies.htm).  Example: `3`
        """
        pulumi.set(__self__, "port", port)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_backup is not None:
            pulumi.set(__self__, "is_backup", is_backup)
        if is_drain is not None:
            pulumi.set(__self__, "is_drain", is_drain)
        if is_offline is not None:
            pulumi.set(__self__, "is_offline", is_offline)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_id is not None:
            pulumi.set(__self__, "target_id", target_id)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        (Updatable) The backend server port against which to run the health check. If the port is not specified, then the network load balancer uses the port information from the `Backend` object. The port must be specified if the backend port is 0.  Example: `8080`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of the backend server. Example: `10.0.0.3`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="isBackup")
    def is_backup(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the network load balancer should treat this server as a backup unit. If `true`, then the network load balancer forwards no ingress traffic to this backend server unless all other backend servers not marked as "isBackup" fail the health check policy.  Example: `false`
        """
        return pulumi.get(self, "is_backup")

    @is_backup.setter
    def is_backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_backup", value)

    @property
    @pulumi.getter(name="isDrain")
    def is_drain(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the network load balancer should drain this server. Servers marked "isDrain" receive no  incoming traffic.  Example: `false`
        """
        return pulumi.get(self, "is_drain")

    @is_drain.setter
    def is_drain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_drain", value)

    @property
    @pulumi.getter(name="isOffline")
    def is_offline(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the network load balancer should treat this server as offline. Offline servers receive no incoming traffic.  Example: `false`
        """
        return pulumi.get(self, "is_offline")

    @is_offline.setter
    def is_offline(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_offline", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A user-friendly name for the backend set that must be unique and cannot be changed.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="targetId")
    def target_id(self) -> Optional[pulumi.Input[str]]:
        """
        The IP OCID/Instance OCID associated with the backend server. Example: `ocid1.privateip..oc1.<var>&lt;unique_ID&gt;</var>`
        """
        return pulumi.get(self, "target_id")

    @target_id.setter
    def target_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_id", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The network load balancing policy weight assigned to the server. Backend servers with a higher weight receive a larger proportion of incoming traffic. For example, a server weighted '3' receives three times the number of new connections as a server weighted '1'. For more information about load balancing policies, see [How Network Load Balancing Policies Work](https://docs.cloud.oracle.com/iaas/Content/Balance/Reference/lbpolicies.htm).  Example: `3`
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class NetworkLoadBalancerBackendSetHealthCheckerArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 interval_in_millis: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 request_data: Optional[pulumi.Input[str]] = None,
                 response_body_regex: Optional[pulumi.Input[str]] = None,
                 response_data: Optional[pulumi.Input[str]] = None,
                 retries: Optional[pulumi.Input[int]] = None,
                 return_code: Optional[pulumi.Input[int]] = None,
                 timeout_in_millis: Optional[pulumi.Input[int]] = None,
                 url_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: (Updatable) The protocol the health check must use; either HTTP or HTTPS, or UDP or TCP.  Example: `HTTP`
        :param pulumi.Input[int] interval_in_millis: (Updatable) The interval between health checks, in milliseconds. The default value is 10000 (10 seconds).  Example: `10000`
        :param pulumi.Input[int] port: (Updatable) The backend server port against which to run the health check. If the port is not specified, then the network load balancer uses the port information from the `Backend` object. The port must be specified if the backend port is 0.  Example: `8080`
        :param pulumi.Input[str] request_data: (Updatable) Base64 encoded pattern to be sent as UDP or TCP health check probe.
        :param pulumi.Input[str] response_body_regex: (Updatable) A regular expression for parsing the response body from the backend server.  Example: `^((?!false).|\s)*$`
        :param pulumi.Input[str] response_data: (Updatable) Base64 encoded pattern to be validated as UDP or TCP health check probe response.
        :param pulumi.Input[int] retries: (Updatable) The number of retries to attempt before a backend server is considered "unhealthy". This number also applies when recovering a server to the "healthy" state. The default value is 3.  Example: `3`
        :param pulumi.Input[int] return_code: (Updatable) The status code a healthy backend server should return. If you configure the health check policy to use the HTTP protocol, then you can use common HTTP status codes such as "200".  Example: `200`
        :param pulumi.Input[int] timeout_in_millis: (Updatable) The maximum time, in milliseconds, to wait for a reply to a health check. A health check is successful only if a reply returns within this timeout period. The default value is 3000 (3 seconds).  Example: `3000`
        :param pulumi.Input[str] url_path: (Updatable) The path against which to run the health check.  Example: `/healthcheck`
        """
        pulumi.set(__self__, "protocol", protocol)
        if interval_in_millis is not None:
            pulumi.set(__self__, "interval_in_millis", interval_in_millis)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if request_data is not None:
            pulumi.set(__self__, "request_data", request_data)
        if response_body_regex is not None:
            pulumi.set(__self__, "response_body_regex", response_body_regex)
        if response_data is not None:
            pulumi.set(__self__, "response_data", response_data)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if return_code is not None:
            pulumi.set(__self__, "return_code", return_code)
        if timeout_in_millis is not None:
            pulumi.set(__self__, "timeout_in_millis", timeout_in_millis)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The protocol the health check must use; either HTTP or HTTPS, or UDP or TCP.  Example: `HTTP`
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="intervalInMillis")
    def interval_in_millis(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The interval between health checks, in milliseconds. The default value is 10000 (10 seconds).  Example: `10000`
        """
        return pulumi.get(self, "interval_in_millis")

    @interval_in_millis.setter
    def interval_in_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_millis", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The backend server port against which to run the health check. If the port is not specified, then the network load balancer uses the port information from the `Backend` object. The port must be specified if the backend port is 0.  Example: `8080`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="requestData")
    def request_data(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Base64 encoded pattern to be sent as UDP or TCP health check probe.
        """
        return pulumi.get(self, "request_data")

    @request_data.setter
    def request_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_data", value)

    @property
    @pulumi.getter(name="responseBodyRegex")
    def response_body_regex(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A regular expression for parsing the response body from the backend server.  Example: `^((?!false).|\s)*$`
        """
        return pulumi.get(self, "response_body_regex")

    @response_body_regex.setter
    def response_body_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_body_regex", value)

    @property
    @pulumi.getter(name="responseData")
    def response_data(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Base64 encoded pattern to be validated as UDP or TCP health check probe response.
        """
        return pulumi.get(self, "response_data")

    @response_data.setter
    def response_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_data", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of retries to attempt before a backend server is considered "unhealthy". This number also applies when recovering a server to the "healthy" state. The default value is 3.  Example: `3`
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="returnCode")
    def return_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The status code a healthy backend server should return. If you configure the health check policy to use the HTTP protocol, then you can use common HTTP status codes such as "200".  Example: `200`
        """
        return pulumi.get(self, "return_code")

    @return_code.setter
    def return_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "return_code", value)

    @property
    @pulumi.getter(name="timeoutInMillis")
    def timeout_in_millis(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum time, in milliseconds, to wait for a reply to a health check. A health check is successful only if a reply returns within this timeout period. The default value is 3000 (3 seconds).  Example: `3000`
        """
        return pulumi.get(self, "timeout_in_millis")

    @timeout_in_millis.setter
    def timeout_in_millis(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_millis", value)

    @property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The path against which to run the health check.  Example: `/healthcheck`
        """
        return pulumi.get(self, "url_path")

    @url_path.setter
    def url_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url_path", value)


@pulumi.input_type
class NetworkLoadBalancerNetworkLoadBalancerIpAddressArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 is_public: Optional[pulumi.Input[bool]] = None,
                 reserved_ip: Optional[pulumi.Input['NetworkLoadBalancerNetworkLoadBalancerIpAddressReservedIpArgs']] = None):
        """
        :param pulumi.Input[str] ip_address: An IP address.  Example: `192.168.0.3`
        :param pulumi.Input[bool] is_public: Whether the IP address is public or private.
        :param pulumi.Input['NetworkLoadBalancerNetworkLoadBalancerIpAddressReservedIpArgs'] reserved_ip: An object representing a reserved IP address to be attached or that is already attached to a network load balancer.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if reserved_ip is not None:
            pulumi.set(__self__, "reserved_ip", reserved_ip)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        An IP address.  Example: `192.168.0.3`
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the IP address is public or private.
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_public", value)

    @property
    @pulumi.getter(name="reservedIp")
    def reserved_ip(self) -> Optional[pulumi.Input['NetworkLoadBalancerNetworkLoadBalancerIpAddressReservedIpArgs']]:
        """
        An object representing a reserved IP address to be attached or that is already attached to a network load balancer.
        """
        return pulumi.get(self, "reserved_ip")

    @reserved_ip.setter
    def reserved_ip(self, value: Optional[pulumi.Input['NetworkLoadBalancerNetworkLoadBalancerIpAddressReservedIpArgs']]):
        pulumi.set(self, "reserved_ip", value)


@pulumi.input_type
class NetworkLoadBalancerNetworkLoadBalancerIpAddressReservedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: OCID of the reserved public IP address created with the virtual cloud network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        OCID of the reserved public IP address created with the virtual cloud network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class NetworkLoadBalancerNetworkLoadBalancerReservedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: OCID of the reserved public IP address created with the virtual cloud network.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        OCID of the reserved public IP address created with the virtual cloud network.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class NosqlIndexKeyArgs:
    def __init__(__self__, *,
                 column_name: pulumi.Input[str],
                 json_field_type: Optional[pulumi.Input[str]] = None,
                 json_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] column_name: The name of a column to be included as an index key.
        :param pulumi.Input[str] json_field_type: If the specified column is of type JSON, jsonFieldType contains the type of the field indicated by jsonPath.
        :param pulumi.Input[str] json_path: If the specified column is of type JSON, jsonPath contains a dotted path indicating the field within the JSON object that will be the index key.
        """
        pulumi.set(__self__, "column_name", column_name)
        if json_field_type is not None:
            pulumi.set(__self__, "json_field_type", json_field_type)
        if json_path is not None:
            pulumi.set(__self__, "json_path", json_path)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> pulumi.Input[str]:
        """
        The name of a column to be included as an index key.
        """
        return pulumi.get(self, "column_name")

    @column_name.setter
    def column_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "column_name", value)

    @property
    @pulumi.getter(name="jsonFieldType")
    def json_field_type(self) -> Optional[pulumi.Input[str]]:
        """
        If the specified column is of type JSON, jsonFieldType contains the type of the field indicated by jsonPath.
        """
        return pulumi.get(self, "json_field_type")

    @json_field_type.setter
    def json_field_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_field_type", value)

    @property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> Optional[pulumi.Input[str]]:
        """
        If the specified column is of type JSON, jsonPath contains a dotted path indicating the field within the JSON object that will be the index key.
        """
        return pulumi.get(self, "json_path")

    @json_path.setter
    def json_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_path", value)


@pulumi.input_type
class NosqlTableSchemaArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['NosqlTableSchemaColumnArgs']]]] = None,
                 primary_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 shard_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ttl: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NosqlTableSchemaColumnArgs']]] columns: The columns of a table.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] primary_keys: A list of column names that make up a key.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] shard_keys: A list of column names that make up a key.
        :param pulumi.Input[int] ttl: The default Time-to-Live for the table, in days.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if primary_keys is not None:
            pulumi.set(__self__, "primary_keys", primary_keys)
        if shard_keys is not None:
            pulumi.set(__self__, "shard_keys", shard_keys)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NosqlTableSchemaColumnArgs']]]]:
        """
        The columns of a table.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NosqlTableSchemaColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter(name="primaryKeys")
    def primary_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of column names that make up a key.
        """
        return pulumi.get(self, "primary_keys")

    @primary_keys.setter
    def primary_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "primary_keys", value)

    @property
    @pulumi.getter(name="shardKeys")
    def shard_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of column names that make up a key.
        """
        return pulumi.get(self, "shard_keys")

    @shard_keys.setter
    def shard_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "shard_keys", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[int]]:
        """
        The default Time-to-Live for the table, in days.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class NosqlTableSchemaColumnArgs:
    def __init__(__self__, *,
                 default_value: Optional[pulumi.Input[str]] = None,
                 is_nullable: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_value: The column default value.
        :param pulumi.Input[bool] is_nullable: The column nullable flag.
        :param pulumi.Input[str] name: Table name.
        :param pulumi.Input[str] type: The column type.
        """
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if is_nullable is not None:
            pulumi.set(__self__, "is_nullable", is_nullable)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        The column default value.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter(name="isNullable")
    def is_nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        The column nullable flag.
        """
        return pulumi.get(self, "is_nullable")

    @is_nullable.setter
    def is_nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_nullable", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Table name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The column type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class NosqlTableTableLimitsArgs:
    def __init__(__self__, *,
                 max_read_units: pulumi.Input[int],
                 max_storage_in_gbs: pulumi.Input[int],
                 max_write_units: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_read_units: (Updatable) Maximum sustained read throughput limit for the table.
        :param pulumi.Input[int] max_storage_in_gbs: (Updatable) Maximum size of storage used by the table.
        :param pulumi.Input[int] max_write_units: (Updatable) Maximum sustained write throughput limit for the table.
        """
        pulumi.set(__self__, "max_read_units", max_read_units)
        pulumi.set(__self__, "max_storage_in_gbs", max_storage_in_gbs)
        pulumi.set(__self__, "max_write_units", max_write_units)

    @property
    @pulumi.getter(name="maxReadUnits")
    def max_read_units(self) -> pulumi.Input[int]:
        """
        (Updatable) Maximum sustained read throughput limit for the table.
        """
        return pulumi.get(self, "max_read_units")

    @max_read_units.setter
    def max_read_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_read_units", value)

    @property
    @pulumi.getter(name="maxStorageInGbs")
    def max_storage_in_gbs(self) -> pulumi.Input[int]:
        """
        (Updatable) Maximum size of storage used by the table.
        """
        return pulumi.get(self, "max_storage_in_gbs")

    @max_storage_in_gbs.setter
    def max_storage_in_gbs(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_storage_in_gbs", value)

    @property
    @pulumi.getter(name="maxWriteUnits")
    def max_write_units(self) -> pulumi.Input[int]:
        """
        (Updatable) Maximum sustained write throughput limit for the table.
        """
        return pulumi.get(self, "max_write_units")

    @max_write_units.setter
    def max_write_units(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_write_units", value)


@pulumi.input_type
class ObjectstorageBucketRetentionRuleArgs:
    def __init__(__self__, *,
                 display_name: pulumi.Input[str],
                 duration: Optional[pulumi.Input['ObjectstorageBucketRetentionRuleDurationArgs']] = None,
                 retention_rule_id: Optional[pulumi.Input[str]] = None,
                 time_created: Optional[pulumi.Input[str]] = None,
                 time_modified: Optional[pulumi.Input[str]] = None,
                 time_rule_locked: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: A user-specified name for the retention rule. Names can be helpful in identifying retention rules. The name should be unique. This attribute is a forcenew attribute
        :param pulumi.Input['ObjectstorageBucketRetentionRuleDurationArgs'] duration: (Updatable)
        :param pulumi.Input[str] retention_rule_id: Unique identifier for the retention rule.
        :param pulumi.Input[str] time_created: The date and time the bucket was created, as described in [RFC 2616](https://tools.ietf.org/html/rfc2616#section-14.29).
        :param pulumi.Input[str] time_modified: The date and time that the retention rule was modified as per [RFC3339](https://tools.ietf.org/html/rfc3339).
        :param pulumi.Input[str] time_rule_locked: (Updatable) The date and time as per [RFC 3339](https://tools.ietf.org/html/rfc3339) after which this rule is locked and can only be deleted by deleting the bucket. Once a rule is locked, only increases in the duration are allowed and no other properties can be changed. This property cannot be updated for rules that are in a locked state. Specifying it when a duration is not specified is considered an error.
        """
        pulumi.set(__self__, "display_name", display_name)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if retention_rule_id is not None:
            pulumi.set(__self__, "retention_rule_id", retention_rule_id)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if time_modified is not None:
            pulumi.set(__self__, "time_modified", time_modified)
        if time_rule_locked is not None:
            pulumi.set(__self__, "time_rule_locked", time_rule_locked)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        A user-specified name for the retention rule. Names can be helpful in identifying retention rules. The name should be unique. This attribute is a forcenew attribute
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input['ObjectstorageBucketRetentionRuleDurationArgs']]:
        """
        (Updatable)
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input['ObjectstorageBucketRetentionRuleDurationArgs']]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="retentionRuleId")
    def retention_rule_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the retention rule.
        """
        return pulumi.get(self, "retention_rule_id")

    @retention_rule_id.setter
    def retention_rule_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_rule_id", value)

    @property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time the bucket was created, as described in [RFC 2616](https://tools.ietf.org/html/rfc2616#section-14.29).
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_created", value)

    @property
    @pulumi.getter(name="timeModified")
    def time_modified(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time that the retention rule was modified as per [RFC3339](https://tools.ietf.org/html/rfc3339).
        """
        return pulumi.get(self, "time_modified")

    @time_modified.setter
    def time_modified(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_modified", value)

    @property
    @pulumi.getter(name="timeRuleLocked")
    def time_rule_locked(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The date and time as per [RFC 3339](https://tools.ietf.org/html/rfc3339) after which this rule is locked and can only be deleted by deleting the bucket. Once a rule is locked, only increases in the duration are allowed and no other properties can be changed. This property cannot be updated for rules that are in a locked state. Specifying it when a duration is not specified is considered an error.
        """
        return pulumi.get(self, "time_rule_locked")

    @time_rule_locked.setter
    def time_rule_locked(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_rule_locked", value)


@pulumi.input_type
class ObjectstorageBucketRetentionRuleDurationArgs:
    def __init__(__self__, *,
                 time_amount: pulumi.Input[str],
                 time_unit: pulumi.Input[str]):
        """
        :param pulumi.Input[str] time_amount: (Updatable) The timeAmount is interpreted in units defined by the timeUnit parameter, and is calculated in relation to each object's Last-Modified timestamp.
        :param pulumi.Input[str] time_unit: (Updatable) The unit that should be used to interpret timeAmount.
        """
        pulumi.set(__self__, "time_amount", time_amount)
        pulumi.set(__self__, "time_unit", time_unit)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> pulumi.Input[str]:
        """
        (Updatable) The timeAmount is interpreted in units defined by the timeUnit parameter, and is calculated in relation to each object's Last-Modified timestamp.
        """
        return pulumi.get(self, "time_amount")

    @time_amount.setter
    def time_amount(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_amount", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> pulumi.Input[str]:
        """
        (Updatable) The unit that should be used to interpret timeAmount.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_unit", value)


@pulumi.input_type
class ObjectstorageObjectLifecyclePolicyRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 name: pulumi.Input[str],
                 time_amount: pulumi.Input[str],
                 time_unit: pulumi.Input[str],
                 object_name_filter: Optional[pulumi.Input['ObjectstorageObjectLifecyclePolicyRuleObjectNameFilterArgs']] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: (Updatable) The action of the object lifecycle policy rule. Rules using the action 'ARCHIVE' move objects from Standard and InfrequentAccess storage tiers into the [Archive storage tier](https://docs.cloud.oracle.com/iaas/Content/Archive/Concepts/archivestorageoverview.htm). Rules using the action 'INFREQUENT_ACCESS' move objects from Standard storage tier into the Infrequent Access Storage tier. Objects that are already in InfrequentAccess tier or in Archive tier are left untouched. Rules using the action 'DELETE' permanently delete objects from buckets. Rules using 'ABORT' abort the uncommitted multipart-uploads and permanently delete their parts from buckets.
        :param pulumi.Input[bool] is_enabled: (Updatable) A Boolean that determines whether this rule is currently enabled.
        :param pulumi.Input[str] name: (Updatable) The name of the lifecycle rule to be applied.
        :param pulumi.Input[str] time_amount: (Updatable) Specifies the age of objects to apply the rule to. The timeAmount is interpreted in units defined by the timeUnit parameter, and is calculated in relation to each object's Last-Modified time.
        :param pulumi.Input[str] time_unit: (Updatable) The unit that should be used to interpret timeAmount.  Days are defined as starting and ending at midnight UTC. Years are defined as 365.2425 days long and likewise round up to the next midnight UTC.
        :param pulumi.Input['ObjectstorageObjectLifecyclePolicyRuleObjectNameFilterArgs'] object_name_filter: (Updatable) A filter that compares object names to a set of prefixes or patterns to determine if a rule applies to a given object. The filter can contain include glob patterns, exclude glob patterns and inclusion prefixes. The inclusion prefixes property is kept for backward compatibility. It is recommended to use inclusion patterns instead of prefixes. Exclusions take precedence over inclusions.
        :param pulumi.Input[str] target: (Updatable) The target of the object lifecycle policy rule. The values of target can be either "objects", "multipart-uploads" or "previous-object-versions". This field when declared as "objects" is used to specify ARCHIVE, INFREQUENT_ACCESS or DELETE rule for objects. This field when declared as "previous-object-versions" is used to specify ARCHIVE, INFREQUENT_ACCESS or DELETE rule for previous versions of existing objects. This field when declared as "multipart-uploads" is used to specify the ABORT (only) rule for uncommitted multipart-uploads.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "time_amount", time_amount)
        pulumi.set(__self__, "time_unit", time_unit)
        if object_name_filter is not None:
            pulumi.set(__self__, "object_name_filter", object_name_filter)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        (Updatable) The action of the object lifecycle policy rule. Rules using the action 'ARCHIVE' move objects from Standard and InfrequentAccess storage tiers into the [Archive storage tier](https://docs.cloud.oracle.com/iaas/Content/Archive/Concepts/archivestorageoverview.htm). Rules using the action 'INFREQUENT_ACCESS' move objects from Standard storage tier into the Infrequent Access Storage tier. Objects that are already in InfrequentAccess tier or in Archive tier are left untouched. Rules using the action 'DELETE' permanently delete objects from buckets. Rules using 'ABORT' abort the uncommitted multipart-uploads and permanently delete their parts from buckets.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) A Boolean that determines whether this rule is currently enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the lifecycle rule to be applied.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="timeAmount")
    def time_amount(self) -> pulumi.Input[str]:
        """
        (Updatable) Specifies the age of objects to apply the rule to. The timeAmount is interpreted in units defined by the timeUnit parameter, and is calculated in relation to each object's Last-Modified time.
        """
        return pulumi.get(self, "time_amount")

    @time_amount.setter
    def time_amount(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_amount", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> pulumi.Input[str]:
        """
        (Updatable) The unit that should be used to interpret timeAmount.  Days are defined as starting and ending at midnight UTC. Years are defined as 365.2425 days long and likewise round up to the next midnight UTC.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_unit", value)

    @property
    @pulumi.getter(name="objectNameFilter")
    def object_name_filter(self) -> Optional[pulumi.Input['ObjectstorageObjectLifecyclePolicyRuleObjectNameFilterArgs']]:
        """
        (Updatable) A filter that compares object names to a set of prefixes or patterns to determine if a rule applies to a given object. The filter can contain include glob patterns, exclude glob patterns and inclusion prefixes. The inclusion prefixes property is kept for backward compatibility. It is recommended to use inclusion patterns instead of prefixes. Exclusions take precedence over inclusions.
        """
        return pulumi.get(self, "object_name_filter")

    @object_name_filter.setter
    def object_name_filter(self, value: Optional[pulumi.Input['ObjectstorageObjectLifecyclePolicyRuleObjectNameFilterArgs']]):
        pulumi.set(self, "object_name_filter", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target of the object lifecycle policy rule. The values of target can be either "objects", "multipart-uploads" or "previous-object-versions". This field when declared as "objects" is used to specify ARCHIVE, INFREQUENT_ACCESS or DELETE rule for objects. This field when declared as "previous-object-versions" is used to specify ARCHIVE, INFREQUENT_ACCESS or DELETE rule for previous versions of existing objects. This field when declared as "multipart-uploads" is used to specify the ABORT (only) rule for uncommitted multipart-uploads.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class ObjectstorageObjectLifecyclePolicyRuleObjectNameFilterArgs:
    def __init__(__self__, *,
                 exclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 inclusion_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_patterns: (Updatable) An array of glob patterns to match the object names to exclude. An empty array is ignored. Exclusion patterns take precedence over inclusion patterns. A Glob pattern is a sequence of characters to match text. Any character that appears in the pattern, other than the special pattern characters described below, matches itself. Glob patterns must be between 1 and 1024 characters.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_patterns: (Updatable) An array of glob patterns to match the object names to include. An empty array includes all objects in the bucket. Exclusion patterns take precedence over inclusion patterns. A Glob pattern is a sequence of characters to match text. Any character that appears in the pattern, other than the special pattern characters described below, matches itself. Glob patterns must be between 1 and 1024 characters.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_prefixes: (Updatable) An array of object name prefixes that the rule will apply to. An empty array means to include all objects.
        """
        if exclusion_patterns is not None:
            pulumi.set(__self__, "exclusion_patterns", exclusion_patterns)
        if inclusion_patterns is not None:
            pulumi.set(__self__, "inclusion_patterns", inclusion_patterns)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @property
    @pulumi.getter(name="exclusionPatterns")
    def exclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) An array of glob patterns to match the object names to exclude. An empty array is ignored. Exclusion patterns take precedence over inclusion patterns. A Glob pattern is a sequence of characters to match text. Any character that appears in the pattern, other than the special pattern characters described below, matches itself. Glob patterns must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "exclusion_patterns")

    @exclusion_patterns.setter
    def exclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_patterns", value)

    @property
    @pulumi.getter(name="inclusionPatterns")
    def inclusion_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) An array of glob patterns to match the object names to include. An empty array includes all objects in the bucket. Exclusion patterns take precedence over inclusion patterns. A Glob pattern is a sequence of characters to match text. Any character that appears in the pattern, other than the special pattern characters described below, matches itself. Glob patterns must be between 1 and 1024 characters.
        """
        return pulumi.get(self, "inclusion_patterns")

    @inclusion_patterns.setter
    def inclusion_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_patterns", value)

    @property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) An array of object name prefixes that the rule will apply to. An empty array means to include all objects.
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


@pulumi.input_type
class ObjectstorageObjectSourceUriDetailsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 namespace: pulumi.Input[str],
                 object: pulumi.Input[str],
                 region: pulumi.Input[str],
                 destination_object_if_match_etag: Optional[pulumi.Input[str]] = None,
                 destination_object_if_none_match_etag: Optional[pulumi.Input[str]] = None,
                 source_object_if_match_etag: Optional[pulumi.Input[str]] = None,
                 source_version_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The name of the bucket for the source object.
        :param pulumi.Input[str] namespace: The top-level namespace of the source object.
        :param pulumi.Input[str] object: The name of the source object.
        :param pulumi.Input[str] region: The region of the source object.
        :param pulumi.Input[str] destination_object_if_match_etag: The entity tag to match the target object.
        :param pulumi.Input[str] destination_object_if_none_match_etag: The entity tag to not match the target object.
        :param pulumi.Input[str] source_object_if_match_etag: The entity tag to match the source object.
        :param pulumi.Input[str] source_version_id: The version id of the object to be restored.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "object", object)
        pulumi.set(__self__, "region", region)
        if destination_object_if_match_etag is not None:
            pulumi.set(__self__, "destination_object_if_match_etag", destination_object_if_match_etag)
        if destination_object_if_none_match_etag is not None:
            pulumi.set(__self__, "destination_object_if_none_match_etag", destination_object_if_none_match_etag)
        if source_object_if_match_etag is not None:
            pulumi.set(__self__, "source_object_if_match_etag", source_object_if_match_etag)
        if source_version_id is not None:
            pulumi.set(__self__, "source_version_id", source_version_id)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the bucket for the source object.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[str]:
        """
        The top-level namespace of the source object.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        The name of the source object.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The region of the source object.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="destinationObjectIfMatchEtag")
    def destination_object_if_match_etag(self) -> Optional[pulumi.Input[str]]:
        """
        The entity tag to match the target object.
        """
        return pulumi.get(self, "destination_object_if_match_etag")

    @destination_object_if_match_etag.setter
    def destination_object_if_match_etag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_object_if_match_etag", value)

    @property
    @pulumi.getter(name="destinationObjectIfNoneMatchEtag")
    def destination_object_if_none_match_etag(self) -> Optional[pulumi.Input[str]]:
        """
        The entity tag to not match the target object.
        """
        return pulumi.get(self, "destination_object_if_none_match_etag")

    @destination_object_if_none_match_etag.setter
    def destination_object_if_none_match_etag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_object_if_none_match_etag", value)

    @property
    @pulumi.getter(name="sourceObjectIfMatchEtag")
    def source_object_if_match_etag(self) -> Optional[pulumi.Input[str]]:
        """
        The entity tag to match the source object.
        """
        return pulumi.get(self, "source_object_if_match_etag")

    @source_object_if_match_etag.setter
    def source_object_if_match_etag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_object_if_match_etag", value)

    @property
    @pulumi.getter(name="sourceVersionId")
    def source_version_id(self) -> Optional[pulumi.Input[str]]:
        """
        The version id of the object to be restored.
        """
        return pulumi.get(self, "source_version_id")

    @source_version_id.setter
    def source_version_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_version_id", value)


@pulumi.input_type
class OcvpSddcHcxOnPremLicenseArgs:
    def __init__(__self__, *,
                 activation_key: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 system_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] activation_key: HCX on-premise license key value
        :param pulumi.Input[str] status: status of HCX on-premise license
        :param pulumi.Input[str] system_name: Name of the system that consumed the HCX on-premise license
        """
        if activation_key is not None:
            pulumi.set(__self__, "activation_key", activation_key)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if system_name is not None:
            pulumi.set(__self__, "system_name", system_name)

    @property
    @pulumi.getter(name="activationKey")
    def activation_key(self) -> Optional[pulumi.Input[str]]:
        """
        HCX on-premise license key value
        """
        return pulumi.get(self, "activation_key")

    @activation_key.setter
    def activation_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "activation_key", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        status of HCX on-premise license
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="systemName")
    def system_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the system that consumed the HCX on-premise license
        """
        return pulumi.get(self, "system_name")

    @system_name.setter
    def system_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "system_name", value)


@pulumi.input_type
class OptimizerProfileLevelsConfigurationArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['OptimizerProfileLevelsConfigurationItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OptimizerProfileLevelsConfigurationItemArgs']]] items: (Updatable) The list of target tags attached to the current profile override.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptimizerProfileLevelsConfigurationItemArgs']]]]:
        """
        (Updatable) The list of target tags attached to the current profile override.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptimizerProfileLevelsConfigurationItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class OptimizerProfileLevelsConfigurationItemArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[str]] = None,
                 recommendation_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] level: (Updatable) The pre-defined profile level.
        :param pulumi.Input[str] recommendation_id: (Updatable) The unique OCID of the recommendation.
        """
        if level is not None:
            pulumi.set(__self__, "level", level)
        if recommendation_id is not None:
            pulumi.set(__self__, "recommendation_id", recommendation_id)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The pre-defined profile level.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "level", value)

    @property
    @pulumi.getter(name="recommendationId")
    def recommendation_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The unique OCID of the recommendation.
        """
        return pulumi.get(self, "recommendation_id")

    @recommendation_id.setter
    def recommendation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recommendation_id", value)


@pulumi.input_type
class OptimizerProfileTargetCompartmentsArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] items: (Updatable) The list of target tags attached to the current profile override.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        (Updatable) The list of target tags attached to the current profile override.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class OptimizerProfileTargetTagsArgs:
    def __init__(__self__, *,
                 items: pulumi.Input[Sequence[pulumi.Input['OptimizerProfileTargetTagsItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OptimizerProfileTargetTagsItemArgs']]] items: (Updatable) The list of target tags attached to the current profile override.
        """
        pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> pulumi.Input[Sequence[pulumi.Input['OptimizerProfileTargetTagsItemArgs']]]:
        """
        (Updatable) The list of target tags attached to the current profile override.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: pulumi.Input[Sequence[pulumi.Input['OptimizerProfileTargetTagsItemArgs']]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class OptimizerProfileTargetTagsItemArgs:
    def __init__(__self__, *,
                 tag_definition_name: pulumi.Input[str],
                 tag_namespace_name: pulumi.Input[str],
                 tag_value_type: pulumi.Input[str],
                 tag_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] tag_definition_name: (Updatable) The name of the tag definition.
        :param pulumi.Input[str] tag_namespace_name: (Updatable) The name of the tag namespace.
        :param pulumi.Input[str] tag_value_type: (Updatable) The tag value type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_values: (Updatable) The list of tag values.
        """
        pulumi.set(__self__, "tag_definition_name", tag_definition_name)
        pulumi.set(__self__, "tag_namespace_name", tag_namespace_name)
        pulumi.set(__self__, "tag_value_type", tag_value_type)
        if tag_values is not None:
            pulumi.set(__self__, "tag_values", tag_values)

    @property
    @pulumi.getter(name="tagDefinitionName")
    def tag_definition_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the tag definition.
        """
        return pulumi.get(self, "tag_definition_name")

    @tag_definition_name.setter
    def tag_definition_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_definition_name", value)

    @property
    @pulumi.getter(name="tagNamespaceName")
    def tag_namespace_name(self) -> pulumi.Input[str]:
        """
        (Updatable) The name of the tag namespace.
        """
        return pulumi.get(self, "tag_namespace_name")

    @tag_namespace_name.setter
    def tag_namespace_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_namespace_name", value)

    @property
    @pulumi.getter(name="tagValueType")
    def tag_value_type(self) -> pulumi.Input[str]:
        """
        (Updatable) The tag value type.
        """
        return pulumi.get(self, "tag_value_type")

    @tag_value_type.setter
    def tag_value_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "tag_value_type", value)

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of tag values.
        """
        return pulumi.get(self, "tag_values")

    @tag_values.setter
    def tag_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_values", value)


@pulumi.input_type
class OptimizerRecommendationResourceCountArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] count: The count of resources.
        :param pulumi.Input[str] status: (Updatable) The status of the recommendation.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The count of resources.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The status of the recommendation.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class OptimizerRecommendationSupportedLevelsArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['OptimizerRecommendationSupportedLevelsItemArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OptimizerRecommendationSupportedLevelsItemArgs']]] items: The list of supported levels.
        """
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OptimizerRecommendationSupportedLevelsItemArgs']]]]:
        """
        The list of supported levels.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OptimizerRecommendationSupportedLevelsItemArgs']]]]):
        pulumi.set(self, "items", value)


@pulumi.input_type
class OptimizerRecommendationSupportedLevelsItemArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the profile level.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the profile level.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class OptimizerResourceActionActionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Text describing the recommended action.
        :param pulumi.Input[str] type: The status of the resource action.
        :param pulumi.Input[str] url: The URL path to documentation that explains how to perform the action.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Text describing the recommended action.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the resource action.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL path to documentation that explains how to perform the action.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class OsmanagementManagedInstanceGroupManagedInstanceArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) Managed Instance Group identifier
        :param pulumi.Input[str] id: unique identifier that is immutable on creation
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Managed Instance Group identifier
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        unique identifier that is immutable on creation
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class OsmanagementManagedInstanceManagementChildSoftwareSourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: software source identifier
        :param pulumi.Input[str] name: software source name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        software source name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class OsmanagementManagedInstanceManagementManagedInstanceGroupArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: User friendly name
        :param pulumi.Input[str] id: software source identifier
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        User friendly name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class OsmanagementManagedInstanceManagementParentSoftwareSourceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: software source identifier
        :param pulumi.Input[str] name: software source name
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        software source identifier
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        software source name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class OsmanagementSoftwareSourceAssociatedManagedInstanceArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] display_name: (Updatable) User friendly name for the software source
        :param pulumi.Input[str] id: OCID for the Software Source
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) User friendly name for the software source
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        OCID for the Software Source
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class SchServiceConnectorSourceArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 cursor: Optional[pulumi.Input['SchServiceConnectorSourceCursorArgs']] = None,
                 log_sources: Optional[pulumi.Input[Sequence[pulumi.Input['SchServiceConnectorSourceLogSourceArgs']]]] = None,
                 stream_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) The type descriminator.
        :param pulumi.Input['SchServiceConnectorSourceCursorArgs'] cursor: (Updatable) The type of [cursor](https://docs.cloud.oracle.com/iaas/Content/Streaming/Tasks/using_a_single_consumer.htm#usingcursors), which determines the starting point from which the stream will be consumed.
        :param pulumi.Input[Sequence[pulumi.Input['SchServiceConnectorSourceLogSourceArgs']]] log_sources: (Updatable) The resources affected by this work request.
        :param pulumi.Input[str] stream_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream.
        """
        pulumi.set(__self__, "kind", kind)
        if cursor is not None:
            pulumi.set(__self__, "cursor", cursor)
        if log_sources is not None:
            pulumi.set(__self__, "log_sources", log_sources)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) The type descriminator.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def cursor(self) -> Optional[pulumi.Input['SchServiceConnectorSourceCursorArgs']]:
        """
        (Updatable) The type of [cursor](https://docs.cloud.oracle.com/iaas/Content/Streaming/Tasks/using_a_single_consumer.htm#usingcursors), which determines the starting point from which the stream will be consumed.
        """
        return pulumi.get(self, "cursor")

    @cursor.setter
    def cursor(self, value: Optional[pulumi.Input['SchServiceConnectorSourceCursorArgs']]):
        pulumi.set(self, "cursor", value)

    @property
    @pulumi.getter(name="logSources")
    def log_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SchServiceConnectorSourceLogSourceArgs']]]]:
        """
        (Updatable) The resources affected by this work request.
        """
        return pulumi.get(self, "log_sources")

    @log_sources.setter
    def log_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SchServiceConnectorSourceLogSourceArgs']]]]):
        pulumi.set(self, "log_sources", value)

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_id", value)


@pulumi.input_type
class SchServiceConnectorSourceCursorArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) The type descriminator.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The type descriminator.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)


@pulumi.input_type
class SchServiceConnectorSourceLogSourceArgs:
    def __init__(__self__, *,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None,
                 log_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the metric.
        :param pulumi.Input[str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Logging Analytics log group.
        :param pulumi.Input[str] log_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if log_id is not None:
            pulumi.set(__self__, "log_id", log_id)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the metric.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Logging Analytics log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter(name="logId")
    def log_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the log.
        """
        return pulumi.get(self, "log_id")

    @log_id.setter
    def log_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_id", value)


@pulumi.input_type
class SchServiceConnectorTargetArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 batch_rollover_size_in_mbs: Optional[pulumi.Input[int]] = None,
                 batch_rollover_time_in_ms: Optional[pulumi.Input[int]] = None,
                 bucket: Optional[pulumi.Input[str]] = None,
                 compartment_id: Optional[pulumi.Input[str]] = None,
                 enable_formatted_messaging: Optional[pulumi.Input[bool]] = None,
                 function_id: Optional[pulumi.Input[str]] = None,
                 log_group_id: Optional[pulumi.Input[str]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 metric_namespace: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 object_name_prefix: Optional[pulumi.Input[str]] = None,
                 stream_id: Optional[pulumi.Input[str]] = None,
                 topic_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) The type descriminator.
        :param pulumi.Input[int] batch_rollover_size_in_mbs: (Updatable) The batch rollover size in megabytes.
        :param pulumi.Input[int] batch_rollover_time_in_ms: (Updatable) The batch rollover time in milliseconds.
        :param pulumi.Input[str] bucket: (Updatable) The name of the bucket. Avoid entering confidential information.
        :param pulumi.Input[str] compartment_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the metric.
        :param pulumi.Input[bool] enable_formatted_messaging: (Updatable) Whether to apply a simplified, user-friendly format to the message. Applies only when friendly formatting is supported by the service connector source and the subscription protocol.  Example: `true`
        :param pulumi.Input[str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the function to be used as a task.
        :param pulumi.Input[str] log_group_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Logging Analytics log group.
        :param pulumi.Input[str] metric: (Updatable) The name of the metric.  Example: `CpuUtilization`
        :param pulumi.Input[str] metric_namespace: (Updatable) The namespace of the metric.  Example: `oci_computeagent`
        :param pulumi.Input[str] namespace: (Updatable) The namespace.
        :param pulumi.Input[str] object_name_prefix: (Updatable) The prefix of the objects. Avoid entering confidential information.
        :param pulumi.Input[str] stream_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream.
        :param pulumi.Input[str] topic_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the topic.
        """
        pulumi.set(__self__, "kind", kind)
        if batch_rollover_size_in_mbs is not None:
            pulumi.set(__self__, "batch_rollover_size_in_mbs", batch_rollover_size_in_mbs)
        if batch_rollover_time_in_ms is not None:
            pulumi.set(__self__, "batch_rollover_time_in_ms", batch_rollover_time_in_ms)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if compartment_id is not None:
            pulumi.set(__self__, "compartment_id", compartment_id)
        if enable_formatted_messaging is not None:
            pulumi.set(__self__, "enable_formatted_messaging", enable_formatted_messaging)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)
        if log_group_id is not None:
            pulumi.set(__self__, "log_group_id", log_group_id)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_namespace is not None:
            pulumi.set(__self__, "metric_namespace", metric_namespace)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if object_name_prefix is not None:
            pulumi.set(__self__, "object_name_prefix", object_name_prefix)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if topic_id is not None:
            pulumi.set(__self__, "topic_id", topic_id)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) The type descriminator.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="batchRolloverSizeInMbs")
    def batch_rollover_size_in_mbs(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The batch rollover size in megabytes.
        """
        return pulumi.get(self, "batch_rollover_size_in_mbs")

    @batch_rollover_size_in_mbs.setter
    def batch_rollover_size_in_mbs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_rollover_size_in_mbs", value)

    @property
    @pulumi.getter(name="batchRolloverTimeInMs")
    def batch_rollover_time_in_ms(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The batch rollover time in milliseconds.
        """
        return pulumi.get(self, "batch_rollover_time_in_ms")

    @batch_rollover_time_in_ms.setter
    def batch_rollover_time_in_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_rollover_time_in_ms", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the bucket. Avoid entering confidential information.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the compartment containing the metric.
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter(name="enableFormattedMessaging")
    def enable_formatted_messaging(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Whether to apply a simplified, user-friendly format to the message. Applies only when friendly formatting is supported by the service connector source and the subscription protocol.  Example: `true`
        """
        return pulumi.get(self, "enable_formatted_messaging")

    @enable_formatted_messaging.setter
    def enable_formatted_messaging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_formatted_messaging", value)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the function to be used as a task.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_id", value)

    @property
    @pulumi.getter(name="logGroupId")
    def log_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the Logging Analytics log group.
        """
        return pulumi.get(self, "log_group_id")

    @log_group_id.setter
    def log_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group_id", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the metric.  Example: `CpuUtilization`
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The namespace of the metric.  Example: `oci_computeagent`
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_namespace", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="objectNamePrefix")
    def object_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The prefix of the objects. Avoid entering confidential information.
        """
        return pulumi.get(self, "object_name_prefix")

    @object_name_prefix.setter
    def object_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_name_prefix", value)

    @property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the stream.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_id", value)

    @property
    @pulumi.getter(name="topicId")
    def topic_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the topic.
        """
        return pulumi.get(self, "topic_id")

    @topic_id.setter
    def topic_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic_id", value)


@pulumi.input_type
class SchServiceConnectorTaskArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 batch_size_in_kbs: Optional[pulumi.Input[int]] = None,
                 batch_time_in_sec: Optional[pulumi.Input[int]] = None,
                 condition: Optional[pulumi.Input[str]] = None,
                 function_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: (Updatable) The type descriminator.
        :param pulumi.Input[int] batch_size_in_kbs: (Updatable) Size limit (kilobytes) for batch sent to invoke the function.
        :param pulumi.Input[int] batch_time_in_sec: (Updatable) Time limit (seconds) for batch sent to invoke the function.
        :param pulumi.Input[str] condition: (Updatable) A filter or mask to limit the source used in the flow defined by the service connector.
        :param pulumi.Input[str] function_id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the function to be used as a task.
        """
        pulumi.set(__self__, "kind", kind)
        if batch_size_in_kbs is not None:
            pulumi.set(__self__, "batch_size_in_kbs", batch_size_in_kbs)
        if batch_time_in_sec is not None:
            pulumi.set(__self__, "batch_time_in_sec", batch_time_in_sec)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if function_id is not None:
            pulumi.set(__self__, "function_id", function_id)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        (Updatable) The type descriminator.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="batchSizeInKbs")
    def batch_size_in_kbs(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Size limit (kilobytes) for batch sent to invoke the function.
        """
        return pulumi.get(self, "batch_size_in_kbs")

    @batch_size_in_kbs.setter
    def batch_size_in_kbs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size_in_kbs", value)

    @property
    @pulumi.getter(name="batchTimeInSec")
    def batch_time_in_sec(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Time limit (seconds) for batch sent to invoke the function.
        """
        return pulumi.get(self, "batch_time_in_sec")

    @batch_time_in_sec.setter
    def batch_time_in_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_time_in_sec", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) A filter or mask to limit the source used in the flow defined by the service connector.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the function to be used as a task.
        """
        return pulumi.get(self, "function_id")

    @function_id.setter
    def function_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_id", value)


@pulumi.input_type
class ServiceCatalogPrivateApplicationLogoArgs:
    def __init__(__self__, *,
                 content_url: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 mime_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content_url: The content URL of the uploaded data.
        :param pulumi.Input[str] display_name: (Updatable) The name of the private application.
        :param pulumi.Input[str] mime_type: The MIME type of the uploaded data.
        """
        if content_url is not None:
            pulumi.set(__self__, "content_url", content_url)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)

    @property
    @pulumi.getter(name="contentUrl")
    def content_url(self) -> Optional[pulumi.Input[str]]:
        """
        The content URL of the uploaded data.
        """
        return pulumi.get(self, "content_url")

    @content_url.setter
    def content_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_url", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The name of the private application.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[str]]:
        """
        The MIME type of the uploaded data.
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mime_type", value)


@pulumi.input_type
class ServiceCatalogPrivateApplicationPackageDetailsArgs:
    def __init__(__self__, *,
                 package_type: pulumi.Input[str],
                 version: pulumi.Input[str],
                 zip_file_base64encoded: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] package_type: The package's type.
        :param pulumi.Input[str] version: The package version.
        """
        pulumi.set(__self__, "package_type", package_type)
        pulumi.set(__self__, "version", version)
        if zip_file_base64encoded is not None:
            pulumi.set(__self__, "zip_file_base64encoded", zip_file_base64encoded)

    @property
    @pulumi.getter(name="packageType")
    def package_type(self) -> pulumi.Input[str]:
        """
        The package's type.
        """
        return pulumi.get(self, "package_type")

    @package_type.setter
    def package_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "package_type", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The package version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter(name="zipFileBase64encoded")
    def zip_file_base64encoded(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zip_file_base64encoded")

    @zip_file_base64encoded.setter
    def zip_file_base64encoded(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zip_file_base64encoded", value)


@pulumi.input_type
class StreamingStreamPoolCustomEncryptionKeyArgs:
    def __init__(__self__, *,
                 kms_key_id: pulumi.Input[str],
                 key_state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_id: (Updatable) Custom Encryption Key (Master Key) ocid.
        :param pulumi.Input[str] key_state: Life cycle State of the custom key
        """
        pulumi.set(__self__, "kms_key_id", kms_key_id)
        if key_state is not None:
            pulumi.set(__self__, "key_state", key_state)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Input[str]:
        """
        (Updatable) Custom Encryption Key (Master Key) ocid.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="keyState")
    def key_state(self) -> Optional[pulumi.Input[str]]:
        """
        Life cycle State of the custom key
        """
        return pulumi.get(self, "key_state")

    @key_state.setter
    def key_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_state", value)


@pulumi.input_type
class StreamingStreamPoolKafkaSettingsArgs:
    def __init__(__self__, *,
                 auto_create_topics_enable: Optional[pulumi.Input[bool]] = None,
                 bootstrap_servers: Optional[pulumi.Input[str]] = None,
                 log_retention_hours: Optional[pulumi.Input[int]] = None,
                 num_partitions: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] auto_create_topics_enable: (Updatable) Enable auto creation of topic on the server.
        :param pulumi.Input[str] bootstrap_servers: (Updatable) Bootstrap servers.
        :param pulumi.Input[int] log_retention_hours: (Updatable) The number of hours to keep a log file before deleting it (in hours).
        :param pulumi.Input[int] num_partitions: (Updatable) The default number of log partitions per topic.
        """
        if auto_create_topics_enable is not None:
            pulumi.set(__self__, "auto_create_topics_enable", auto_create_topics_enable)
        if bootstrap_servers is not None:
            pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        if log_retention_hours is not None:
            pulumi.set(__self__, "log_retention_hours", log_retention_hours)
        if num_partitions is not None:
            pulumi.set(__self__, "num_partitions", num_partitions)

    @property
    @pulumi.getter(name="autoCreateTopicsEnable")
    def auto_create_topics_enable(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enable auto creation of topic on the server.
        """
        return pulumi.get(self, "auto_create_topics_enable")

    @auto_create_topics_enable.setter
    def auto_create_topics_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_create_topics_enable", value)

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Bootstrap servers.
        """
        return pulumi.get(self, "bootstrap_servers")

    @bootstrap_servers.setter
    def bootstrap_servers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bootstrap_servers", value)

    @property
    @pulumi.getter(name="logRetentionHours")
    def log_retention_hours(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of hours to keep a log file before deleting it (in hours).
        """
        return pulumi.get(self, "log_retention_hours")

    @log_retention_hours.setter
    def log_retention_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "log_retention_hours", value)

    @property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The default number of log partitions per topic.
        """
        return pulumi.get(self, "num_partitions")

    @num_partitions.setter
    def num_partitions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_partitions", value)


@pulumi.input_type
class StreamingStreamPoolPrivateEndpointSettingsArgs:
    def __init__(__self__, *,
                 nsg_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_endpoint_ip: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] nsg_ids: The optional list of network security groups to be used with the private endpoint of the stream pool. That value cannot be changed.
        :param pulumi.Input[str] private_endpoint_ip: The optional private IP you want to be associated with your private stream pool. That parameter can only be specified when the subnetId parameter is set. It cannot be changed. The private IP needs to be part of the CIDR range of the specified subnetId or the creation will fail. If not specified a random IP inside the subnet will be chosen. After the stream pool is created, a custom FQDN, pointing to this private IP, is created. The FQDN is then used to access the service instead of the private IP.
        :param pulumi.Input[str] subnet_id: If specified, the stream pool will be private and only accessible from inside that subnet. Producing-to and consuming-from a stream inside a private stream pool can also only be done from inside the subnet. That value cannot be changed.
        """
        if nsg_ids is not None:
            pulumi.set(__self__, "nsg_ids", nsg_ids)
        if private_endpoint_ip is not None:
            pulumi.set(__self__, "private_endpoint_ip", private_endpoint_ip)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="nsgIds")
    def nsg_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The optional list of network security groups to be used with the private endpoint of the stream pool. That value cannot be changed.
        """
        return pulumi.get(self, "nsg_ids")

    @nsg_ids.setter
    def nsg_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "nsg_ids", value)

    @property
    @pulumi.getter(name="privateEndpointIp")
    def private_endpoint_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The optional private IP you want to be associated with your private stream pool. That parameter can only be specified when the subnetId parameter is set. It cannot be changed. The private IP needs to be part of the CIDR range of the specified subnetId or the creation will fail. If not specified a random IP inside the subnet will be chosen. After the stream pool is created, a custom FQDN, pointing to this private IP, is created. The FQDN is then used to access the service instead of the private IP.
        """
        return pulumi.get(self, "private_endpoint_ip")

    @private_endpoint_ip.setter
    def private_endpoint_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_endpoint_ip", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        If specified, the stream pool will be private and only accessible from inside that subnet. Producing-to and consuming-from a stream inside a private stream pool can also only be done from inside the subnet. That value cannot be changed.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)


@pulumi.input_type
class VulnerabilityScanningHostScanRecipeAgentSettingsArgs:
    def __init__(__self__, *,
                 scan_level: pulumi.Input[str],
                 agent_configuration: Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationArgs']] = None):
        """
        :param pulumi.Input[str] scan_level: (Updatable) The scan level
        :param pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationArgs'] agent_configuration: (Updatable) Agent configuration for host scan agent settings. This model is polymorphic, presenting different configuration options based on selected agent vendor.
        """
        pulumi.set(__self__, "scan_level", scan_level)
        if agent_configuration is not None:
            pulumi.set(__self__, "agent_configuration", agent_configuration)

    @property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> pulumi.Input[str]:
        """
        (Updatable) The scan level
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "scan_level", value)

    @property
    @pulumi.getter(name="agentConfiguration")
    def agent_configuration(self) -> Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationArgs']]:
        """
        (Updatable) Agent configuration for host scan agent settings. This model is polymorphic, presenting different configuration options based on selected agent vendor.
        """
        return pulumi.get(self, "agent_configuration")

    @agent_configuration.setter
    def agent_configuration(self, value: Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationArgs']]):
        pulumi.set(self, "agent_configuration", value)


@pulumi.input_type
class VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationArgs:
    def __init__(__self__, *,
                 vendor: pulumi.Input[str],
                 cis_benchmark_settings: Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs']] = None,
                 endpoint_protection_settings: Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs']] = None):
        """
        :param pulumi.Input[str] vendor: (Updatable) Vendor to use for the host scan agent.
        :param pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs'] cis_benchmark_settings: (Updatable) CIS (Center for Internet Security) Benchmark scan settings for a host scan
        :param pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs'] endpoint_protection_settings: (Updatable) Endpoint Protection scan settings for a host scan
        """
        pulumi.set(__self__, "vendor", vendor)
        if cis_benchmark_settings is not None:
            pulumi.set(__self__, "cis_benchmark_settings", cis_benchmark_settings)
        if endpoint_protection_settings is not None:
            pulumi.set(__self__, "endpoint_protection_settings", endpoint_protection_settings)

    @property
    @pulumi.getter
    def vendor(self) -> pulumi.Input[str]:
        """
        (Updatable) Vendor to use for the host scan agent.
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: pulumi.Input[str]):
        pulumi.set(self, "vendor", value)

    @property
    @pulumi.getter(name="cisBenchmarkSettings")
    def cis_benchmark_settings(self) -> Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs']]:
        """
        (Updatable) CIS (Center for Internet Security) Benchmark scan settings for a host scan
        """
        return pulumi.get(self, "cis_benchmark_settings")

    @cis_benchmark_settings.setter
    def cis_benchmark_settings(self, value: Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs']]):
        pulumi.set(self, "cis_benchmark_settings", value)

    @property
    @pulumi.getter(name="endpointProtectionSettings")
    def endpoint_protection_settings(self) -> Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs']]:
        """
        (Updatable) Endpoint Protection scan settings for a host scan
        """
        return pulumi.get(self, "endpoint_protection_settings")

    @endpoint_protection_settings.setter
    def endpoint_protection_settings(self, value: Optional[pulumi.Input['VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs']]):
        pulumi.set(self, "endpoint_protection_settings", value)


@pulumi.input_type
class VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationCisBenchmarkSettingsArgs:
    def __init__(__self__, *,
                 scan_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scan_level: (Updatable) The scan level
        """
        if scan_level is not None:
            pulumi.set(__self__, "scan_level", scan_level)

    @property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The scan level
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_level", value)


@pulumi.input_type
class VulnerabilityScanningHostScanRecipeAgentSettingsAgentConfigurationEndpointProtectionSettingsArgs:
    def __init__(__self__, *,
                 scan_level: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scan_level: (Updatable) The scan level
        """
        if scan_level is not None:
            pulumi.set(__self__, "scan_level", scan_level)

    @property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The scan level
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_level", value)


@pulumi.input_type
class VulnerabilityScanningHostScanRecipePortSettingsArgs:
    def __init__(__self__, *,
                 scan_level: pulumi.Input[str]):
        """
        :param pulumi.Input[str] scan_level: (Updatable) The scan level
        """
        pulumi.set(__self__, "scan_level", scan_level)

    @property
    @pulumi.getter(name="scanLevel")
    def scan_level(self) -> pulumi.Input[str]:
        """
        (Updatable) The scan level
        """
        return pulumi.get(self, "scan_level")

    @scan_level.setter
    def scan_level(self, value: pulumi.Input[str]):
        pulumi.set(self, "scan_level", value)


@pulumi.input_type
class VulnerabilityScanningHostScanRecipeScheduleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 day_of_week: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: (Updatable) How often the scan occurs
        :param pulumi.Input[str] day_of_week: (Updatable) Day of week the scheduled scan occurs (not applicable for DAILY type)
        """
        pulumi.set(__self__, "type", type)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        (Updatable) How often the scan occurs
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Day of week the scheduled scan occurs (not applicable for DAILY type)
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)


@pulumi.input_type
class WaasCertificateExtensionArgs:
    def __init__(__self__, *,
                 is_critical: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_critical: The critical flag of the extension. Critical extensions must be processed, non-critical extensions can be ignored.
        :param pulumi.Input[str] name: The certificate extension name.
        :param pulumi.Input[str] value: The certificate extension value.
        """
        if is_critical is not None:
            pulumi.set(__self__, "is_critical", is_critical)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[pulumi.Input[bool]]:
        """
        The critical flag of the extension. Critical extensions must be processed, non-critical extensions can be ignored.
        """
        return pulumi.get(self, "is_critical")

    @is_critical.setter
    def is_critical(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_critical", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate extension name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The certificate extension value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WaasCertificateIssuerNameArgs:
    def __init__(__self__, *,
                 common_name: Optional[pulumi.Input[str]] = None,
                 country: Optional[pulumi.Input[str]] = None,
                 email_address: Optional[pulumi.Input[str]] = None,
                 locality: Optional[pulumi.Input[str]] = None,
                 organization: Optional[pulumi.Input[str]] = None,
                 organizational_unit: Optional[pulumi.Input[str]] = None,
                 state_province: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] common_name: The fully qualified domain name used for DNS lookups of the server.
        :param pulumi.Input[str] country: ISO 3166-1 alpha-2 code of the country where the organization is located. For a list of codes, see [ISO's website](https://www.iso.org/obp/ui/#search/code/).
        :param pulumi.Input[str] email_address: The email address of the server's administrator.
        :param pulumi.Input[str] locality: The city in which the organization is located.
        :param pulumi.Input[str] organization: The organization name.
        :param pulumi.Input[str] organizational_unit: The field to differentiate between divisions within an organization.
        :param pulumi.Input[str] state_province: The province where the organization is located.
        """
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if state_province is not None:
            pulumi.set(__self__, "state_province", state_province)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name used for DNS lookups of the server.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[str]]:
        """
        ISO 3166-1 alpha-2 code of the country where the organization is located. For a list of codes, see [ISO's website](https://www.iso.org/obp/ui/#search/code/).
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The email address of the server's administrator.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[str]]:
        """
        The city in which the organization is located.
        """
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[str]]:
        """
        The organization name.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The field to differentiate between divisions within an organization.
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="stateProvince")
    def state_province(self) -> Optional[pulumi.Input[str]]:
        """
        The province where the organization is located.
        """
        return pulumi.get(self, "state_province")

    @state_province.setter
    def state_province(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_province", value)


@pulumi.input_type
class WaasCertificatePublicKeyInfoArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 exponent: Optional[pulumi.Input[int]] = None,
                 key_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] algorithm: The algorithm identifier and parameters for the public key.
        :param pulumi.Input[int] exponent: The private key exponent.
        :param pulumi.Input[int] key_size: The number of bits in a key used by a cryptographic algorithm.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if exponent is not None:
            pulumi.set(__self__, "exponent", exponent)
        if key_size is not None:
            pulumi.set(__self__, "key_size", key_size)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        The algorithm identifier and parameters for the public key.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter
    def exponent(self) -> Optional[pulumi.Input[int]]:
        """
        The private key exponent.
        """
        return pulumi.get(self, "exponent")

    @exponent.setter
    def exponent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "exponent", value)

    @property
    @pulumi.getter(name="keySize")
    def key_size(self) -> Optional[pulumi.Input[int]]:
        """
        The number of bits in a key used by a cryptographic algorithm.
        """
        return pulumi.get(self, "key_size")

    @key_size.setter
    def key_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "key_size", value)


@pulumi.input_type
class WaasCertificateSubjectNameArgs:
    def __init__(__self__, *,
                 common_name: Optional[pulumi.Input[str]] = None,
                 country: Optional[pulumi.Input[str]] = None,
                 email_address: Optional[pulumi.Input[str]] = None,
                 locality: Optional[pulumi.Input[str]] = None,
                 organization: Optional[pulumi.Input[str]] = None,
                 organizational_unit: Optional[pulumi.Input[str]] = None,
                 state_province: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] common_name: The fully qualified domain name used for DNS lookups of the server.
        :param pulumi.Input[str] country: ISO 3166-1 alpha-2 code of the country where the organization is located. For a list of codes, see [ISO's website](https://www.iso.org/obp/ui/#search/code/).
        :param pulumi.Input[str] email_address: The email address of the server's administrator.
        :param pulumi.Input[str] locality: The city in which the organization is located.
        :param pulumi.Input[str] organization: The organization name.
        :param pulumi.Input[str] organizational_unit: The field to differentiate between divisions within an organization.
        :param pulumi.Input[str] state_province: The province where the organization is located.
        """
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if organization is not None:
            pulumi.set(__self__, "organization", organization)
        if organizational_unit is not None:
            pulumi.set(__self__, "organizational_unit", organizational_unit)
        if state_province is not None:
            pulumi.set(__self__, "state_province", state_province)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified domain name used for DNS lookups of the server.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[str]]:
        """
        ISO 3166-1 alpha-2 code of the country where the organization is located. For a list of codes, see [ISO's website](https://www.iso.org/obp/ui/#search/code/).
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "country", value)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        """
        The email address of the server's administrator.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[str]]:
        """
        The city in which the organization is located.
        """
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[str]]:
        """
        The organization name.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter(name="organizationalUnit")
    def organizational_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The field to differentiate between divisions within an organization.
        """
        return pulumi.get(self, "organizational_unit")

    @organizational_unit.setter
    def organizational_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit", value)

    @property
    @pulumi.getter(name="stateProvince")
    def state_province(self) -> Optional[pulumi.Input[str]]:
        """
        The province where the organization is located.
        """
        return pulumi.get(self, "state_province")

    @state_province.setter
    def state_province(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state_province", value)


@pulumi.input_type
class WaasHttpRedirectTargetArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[str],
                 path: pulumi.Input[str],
                 protocol: pulumi.Input[str],
                 query: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] host: (Updatable) The host portion of the redirect.
        :param pulumi.Input[str] path: (Updatable) The path component of the target URL (e.g., "/path/to/resource" in "https://target.example.com/path/to/resource?redirected"), which can be empty, static, or request-copying, or request-prefixing. Use of \ is not permitted except to escape a following \, {, or }. An empty value is treated the same as static "/". A static value must begin with a leading "/", optionally followed by other path characters. A request-copying value must exactly match "{path}", and will be replaced with the path component of the request URL (including its initial "/"). A request-prefixing value must start with "/" and end with a non-escaped "{path}", which will be replaced with the path component of the request URL (including its initial "/"). Only one such replacement token is allowed.
        :param pulumi.Input[str] protocol: (Updatable) The protocol used for the target, http or https.
        :param pulumi.Input[str] query: (Updatable) The query component of the target URL (e.g., "?redirected" in "https://target.example.com/path/to/resource?redirected"), which can be empty, static, or request-copying. Use of \ is not permitted except to escape a following \, {, or }. An empty value results in a redirection target URL with no query component. A static value must begin with a leading "?", optionally followed by other query characters. A request-copying value must exactly match "{query}", and will be replaced with the query component of the request URL (including a leading "?" if and only if the request URL includes a query component).
        :param pulumi.Input[int] port: (Updatable) Port number of the target destination of the redirect, default to match protocol
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "query", query)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        (Updatable) The host portion of the redirect.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        (Updatable) The path component of the target URL (e.g., "/path/to/resource" in "https://target.example.com/path/to/resource?redirected"), which can be empty, static, or request-copying, or request-prefixing. Use of \ is not permitted except to escape a following \, {, or }. An empty value is treated the same as static "/". A static value must begin with a leading "/", optionally followed by other path characters. A request-copying value must exactly match "{path}", and will be replaced with the path component of the request URL (including its initial "/"). A request-prefixing value must start with "/" and end with a non-escaped "{path}", which will be replaced with the path component of the request URL (including its initial "/"). Only one such replacement token is allowed.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        (Updatable) The protocol used for the target, http or https.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        (Updatable) The query component of the target URL (e.g., "?redirected" in "https://target.example.com/path/to/resource?redirected"), which can be empty, static, or request-copying. Use of \ is not permitted except to escape a following \, {, or }. An empty value results in a redirection target URL with no query component. A static value must begin with a leading "?", optionally followed by other query characters. A request-copying value must exactly match "{query}", and will be replaced with the query component of the request URL (including a leading "?" if and only if the request URL includes a query component).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Port number of the target destination of the redirect, default to match protocol
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class WaasProtectionRuleExclusionArgs:
    def __init__(__self__, *,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusions: An array of The target property of a request that would allow it to bypass the protection rule. For example, when `target` is `REQUEST_COOKIE_NAMES`, the list may include names of cookies to exclude from the protection rule. When the target is `ARGS`, the list may include strings of URL query parameters and values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from the protection rule. `Exclusions` properties must not contain whitespace, comma or |. **Note:** If protection rules have been enabled that utilize the `maxArgumentCount` or `maxTotalNameLengthOfArguments` properties, and the `target` property has been set to `ARGS`, it is important that the `exclusions` properties be defined to honor those protection rule settings in a consistent manner.
        :param pulumi.Input[str] target: The target of the exclusion.
        """
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of The target property of a request that would allow it to bypass the protection rule. For example, when `target` is `REQUEST_COOKIE_NAMES`, the list may include names of cookies to exclude from the protection rule. When the target is `ARGS`, the list may include strings of URL query parameters and values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from the protection rule. `Exclusions` properties must not contain whitespace, comma or |. **Note:** If protection rules have been enabled that utilize the `maxArgumentCount` or `maxTotalNameLengthOfArguments` properties, and the `target` property has been set to `ARGS`, it is important that the `exclusions` properties be defined to honor those protection rule settings in a consistent manner.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The target of the exclusion.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class WaasWaasPolicyOriginArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 uri: pulumi.Input[str],
                 custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyOriginCustomHeaderArgs']]]] = None,
                 http_port: Optional[pulumi.Input[int]] = None,
                 https_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] uri: (Updatable) The URI of the origin. Does not support paths. Port numbers should be specified in the `httpPort` and `httpsPort` fields.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyOriginCustomHeaderArgs']]] custom_headers: (Updatable) A list of HTTP headers to forward to your origin.
        :param pulumi.Input[int] http_port: (Updatable) The HTTP port on the origin that the web application listens on. If unspecified, defaults to `80`. If `0` is specified - the origin is not used for HTTP traffic.
        :param pulumi.Input[int] https_port: (Updatable) The HTTPS port on the origin that the web application listens on. If unspecified, defaults to `443`. If `0` is specified - the origin is not used for HTTPS traffic.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "uri", uri)
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        (Updatable) The URI of the origin. Does not support paths. Port numbers should be specified in the `httpPort` and `httpsPort` fields.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyOriginCustomHeaderArgs']]]]:
        """
        (Updatable) A list of HTTP headers to forward to your origin.
        """
        return pulumi.get(self, "custom_headers")

    @custom_headers.setter
    def custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyOriginCustomHeaderArgs']]]]):
        pulumi.set(self, "custom_headers", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The HTTP port on the origin that the web application listens on. If unspecified, defaults to `80`. If `0` is specified - the origin is not used for HTTP traffic.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The HTTPS port on the origin that the web application listens on. If unspecified, defaults to `443`. If `0` is specified - the origin is not used for HTTPS traffic.
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_port", value)


@pulumi.input_type
class WaasWaasPolicyOriginCustomHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) The unique name of the whitelist.
        :param pulumi.Input[str] value: (Updatable) The value of the header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WaasWaasPolicyOriginGroupArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 origin_groups: pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyOriginGroupOriginGroupArgs']]]):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "origin_groups", origin_groups)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter(name="originGroups")
    def origin_groups(self) -> pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyOriginGroupOriginGroupArgs']]]:
        return pulumi.get(self, "origin_groups")

    @origin_groups.setter
    def origin_groups(self, value: pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyOriginGroupOriginGroupArgs']]]):
        pulumi.set(self, "origin_groups", value)


@pulumi.input_type
class WaasWaasPolicyOriginGroupOriginGroupArgs:
    def __init__(__self__, *,
                 origin: pulumi.Input[str],
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] origin: (Updatable) The key in the map of origins referencing the origin used for the Web Application Firewall. The origin must already be included in `Origins`. Required when creating the `WafConfig` resource, but is not required upon updating the configuration.
        """
        pulumi.set(__self__, "origin", origin)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def origin(self) -> pulumi.Input[str]:
        """
        (Updatable) The key in the map of origins referencing the origin used for the Web Application Firewall. The origin must already be included in `Origins`. Required when creating the `WafConfig` resource, but is not required upon updating the configuration.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: pulumi.Input[str]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class WaasWaasPolicyPolicyConfigArgs:
    def __init__(__self__, *,
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 cipher_group: Optional[pulumi.Input[str]] = None,
                 client_address_header: Optional[pulumi.Input[str]] = None,
                 health_checks: Optional[pulumi.Input['WaasWaasPolicyPolicyConfigHealthChecksArgs']] = None,
                 is_behind_cdn: Optional[pulumi.Input[bool]] = None,
                 is_cache_control_respected: Optional[pulumi.Input[bool]] = None,
                 is_https_enabled: Optional[pulumi.Input[bool]] = None,
                 is_https_forced: Optional[pulumi.Input[bool]] = None,
                 is_origin_compression_enabled: Optional[pulumi.Input[bool]] = None,
                 is_response_buffering_enabled: Optional[pulumi.Input[bool]] = None,
                 is_sni_enabled: Optional[pulumi.Input[bool]] = None,
                 load_balancing_method: Optional[pulumi.Input['WaasWaasPolicyPolicyConfigLoadBalancingMethodArgs']] = None,
                 tls_protocols: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 websocket_path_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] certificate_id: (Updatable) The OCID of the SSL certificate to use if HTTPS is supported.
        :param pulumi.Input[str] cipher_group: (Updatable) The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
               * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
        :param pulumi.Input[str] client_address_header: (Updatable) Specifies an HTTP header name which is treated as the connecting client's IP address. Applicable only if `isBehindCdn` is enabled.
        :param pulumi.Input['WaasWaasPolicyPolicyConfigHealthChecksArgs'] health_checks: (Updatable) Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as "healthy".
        :param pulumi.Input[bool] is_behind_cdn: (Updatable) Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
        :param pulumi.Input[bool] is_cache_control_respected: (Updatable) Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
        :param pulumi.Input[bool] is_https_enabled: (Updatable) Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
        :param pulumi.Input[bool] is_https_forced: (Updatable) Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
        :param pulumi.Input[bool] is_origin_compression_enabled: (Updatable) Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
        :param pulumi.Input[bool] is_response_buffering_enabled: (Updatable) Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
        :param pulumi.Input[bool] is_sni_enabled: (Updatable) SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the 'handshake'-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
        :param pulumi.Input['WaasWaasPolicyPolicyConfigLoadBalancingMethodArgs'] load_balancing_method: (Updatable) An object that represents a load balancing method and its properties.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tls_protocols: (Updatable) A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
               * **TLS_V1:** corresponds to TLS 1.0 specification.
               * **TLS_V1_1:** corresponds to TLS 1.1 specification.
               * **TLS_V1_2:** corresponds to TLS 1.2 specification.
               * **TLS_V1_3:** corresponds to TLS 1.3 specification.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] websocket_path_prefixes: (Updatable) ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
        """
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if cipher_group is not None:
            pulumi.set(__self__, "cipher_group", cipher_group)
        if client_address_header is not None:
            pulumi.set(__self__, "client_address_header", client_address_header)
        if health_checks is not None:
            pulumi.set(__self__, "health_checks", health_checks)
        if is_behind_cdn is not None:
            pulumi.set(__self__, "is_behind_cdn", is_behind_cdn)
        if is_cache_control_respected is not None:
            pulumi.set(__self__, "is_cache_control_respected", is_cache_control_respected)
        if is_https_enabled is not None:
            pulumi.set(__self__, "is_https_enabled", is_https_enabled)
        if is_https_forced is not None:
            pulumi.set(__self__, "is_https_forced", is_https_forced)
        if is_origin_compression_enabled is not None:
            pulumi.set(__self__, "is_origin_compression_enabled", is_origin_compression_enabled)
        if is_response_buffering_enabled is not None:
            pulumi.set(__self__, "is_response_buffering_enabled", is_response_buffering_enabled)
        if is_sni_enabled is not None:
            pulumi.set(__self__, "is_sni_enabled", is_sni_enabled)
        if load_balancing_method is not None:
            pulumi.set(__self__, "load_balancing_method", load_balancing_method)
        if tls_protocols is not None:
            pulumi.set(__self__, "tls_protocols", tls_protocols)
        if websocket_path_prefixes is not None:
            pulumi.set(__self__, "websocket_path_prefixes", websocket_path_prefixes)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The OCID of the SSL certificate to use if HTTPS is supported.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="cipherGroup")
    def cipher_group(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The set cipher group for the configured TLS protocol. This sets the configuration for the TLS connections between clients and edge nodes only.
        * **DEFAULT:** Cipher group supports TLS 1.0, TLS 1.1, TLS 1.2, TLS 1.3 protocols. It has the following ciphers enabled: `ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:!DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA`
        """
        return pulumi.get(self, "cipher_group")

    @cipher_group.setter
    def cipher_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cipher_group", value)

    @property
    @pulumi.getter(name="clientAddressHeader")
    def client_address_header(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Specifies an HTTP header name which is treated as the connecting client's IP address. Applicable only if `isBehindCdn` is enabled.
        """
        return pulumi.get(self, "client_address_header")

    @client_address_header.setter
    def client_address_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_address_header", value)

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Optional[pulumi.Input['WaasWaasPolicyPolicyConfigHealthChecksArgs']]:
        """
        (Updatable) Health checks monitor the status of your origin servers and only route traffic to the origins that pass the health check. If the health check fails, origin is automatically removed from the load balancing. There is roughly one health check per EDGE POP per period. Any checks that pass will be reported as "healthy".
        """
        return pulumi.get(self, "health_checks")

    @health_checks.setter
    def health_checks(self, value: Optional[pulumi.Input['WaasWaasPolicyPolicyConfigHealthChecksArgs']]):
        pulumi.set(self, "health_checks", value)

    @property
    @pulumi.getter(name="isBehindCdn")
    def is_behind_cdn(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enabling `isBehindCdn` allows for the collection of IP addresses from client requests if the WAF is connected to a CDN.
        """
        return pulumi.get(self, "is_behind_cdn")

    @is_behind_cdn.setter
    def is_behind_cdn(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_behind_cdn", value)

    @property
    @pulumi.getter(name="isCacheControlRespected")
    def is_cache_control_respected(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enable or disable automatic content caching based on the response `cache-control` header. This feature enables the origin to act as a proxy cache. Caching is usually defined using `cache-control` header. For example `cache-control: max-age=120` means that the returned resource is valid for 120 seconds. Caching rules will overwrite this setting.
        """
        return pulumi.get(self, "is_cache_control_respected")

    @is_cache_control_respected.setter
    def is_cache_control_respected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_cache_control_respected", value)

    @property
    @pulumi.getter(name="isHttpsEnabled")
    def is_https_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enable or disable HTTPS support. If true, a `certificateId` is required. If unspecified, defaults to `false`.
        """
        return pulumi.get(self, "is_https_enabled")

    @is_https_enabled.setter
    def is_https_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_https_enabled", value)

    @property
    @pulumi.getter(name="isHttpsForced")
    def is_https_forced(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Force HTTP to HTTPS redirection. If unspecified, defaults to `false`.
        """
        return pulumi.get(self, "is_https_forced")

    @is_https_forced.setter
    def is_https_forced(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_https_forced", value)

    @property
    @pulumi.getter(name="isOriginCompressionEnabled")
    def is_origin_compression_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enable or disable GZIP compression of origin responses. If enabled, the header `Accept-Encoding: gzip` is sent to origin, otherwise, the empty `Accept-Encoding:` header is used.
        """
        return pulumi.get(self, "is_origin_compression_enabled")

    @is_origin_compression_enabled.setter
    def is_origin_compression_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_origin_compression_enabled", value)

    @property
    @pulumi.getter(name="isResponseBufferingEnabled")
    def is_response_buffering_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enable or disable buffering of responses from the origin. Buffering improves overall stability in case of network issues, but slightly increases Time To First Byte.
        """
        return pulumi.get(self, "is_response_buffering_enabled")

    @is_response_buffering_enabled.setter
    def is_response_buffering_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_response_buffering_enabled", value)

    @property
    @pulumi.getter(name="isSniEnabled")
    def is_sni_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) SNI stands for Server Name Indication and is an extension of the TLS protocol. It indicates which hostname is being contacted by the browser at the beginning of the 'handshake'-process. This allows a server to connect multiple SSL Certificates to one IP address and port.
        """
        return pulumi.get(self, "is_sni_enabled")

    @is_sni_enabled.setter
    def is_sni_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_sni_enabled", value)

    @property
    @pulumi.getter(name="loadBalancingMethod")
    def load_balancing_method(self) -> Optional[pulumi.Input['WaasWaasPolicyPolicyConfigLoadBalancingMethodArgs']]:
        """
        (Updatable) An object that represents a load balancing method and its properties.
        """
        return pulumi.get(self, "load_balancing_method")

    @load_balancing_method.setter
    def load_balancing_method(self, value: Optional[pulumi.Input['WaasWaasPolicyPolicyConfigLoadBalancingMethodArgs']]):
        pulumi.set(self, "load_balancing_method", value)

    @property
    @pulumi.getter(name="tlsProtocols")
    def tls_protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of allowed TLS protocols. Only applicable when HTTPS support is enabled. The TLS protocol is negotiated while the request is connecting and the most recent protocol supported by both the edge node and client browser will be selected. If no such version exists, the connection will be aborted.
        * **TLS_V1:** corresponds to TLS 1.0 specification.
        * **TLS_V1_1:** corresponds to TLS 1.1 specification.
        * **TLS_V1_2:** corresponds to TLS 1.2 specification.
        * **TLS_V1_3:** corresponds to TLS 1.3 specification.
        """
        return pulumi.get(self, "tls_protocols")

    @tls_protocols.setter
    def tls_protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tls_protocols", value)

    @property
    @pulumi.getter(name="websocketPathPrefixes")
    def websocket_path_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) ModSecurity is not capable to inspect WebSockets. Therefore paths specified here have WAF disabled if Connection request header from the client has the value Upgrade (case insensitive matching) and Upgrade request header has the value websocket (case insensitive matching). Paths matches if the concatenation of request URL path and query starts with the contents of the one of `websocketPathPrefixes` array value. In All other cases challenges, like JSC, HIC and etc., remain active.
        """
        return pulumi.get(self, "websocket_path_prefixes")

    @websocket_path_prefixes.setter
    def websocket_path_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "websocket_path_prefixes", value)


@pulumi.input_type
class WaasWaasPolicyPolicyConfigHealthChecksArgs:
    def __init__(__self__, *,
                 expected_response_code_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expected_response_text: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 interval_in_seconds: Optional[pulumi.Input[int]] = None,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 is_response_text_check_enabled: Optional[pulumi.Input[bool]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expected_response_code_groups: (Updatable) The HTTP response codes that signify a healthy state.
               * **2XX:** Success response code group.
               * **3XX:** Redirection response code group.
               * **4XX:** Client errors response code group.
               * **5XX:** Server errors response code group.
        :param pulumi.Input[str] expected_response_text: (Updatable) Health check will search for the given text in a case-sensitive manner within the response body and will fail if the text is not found.
        :param pulumi.Input[Mapping[str, Any]] headers: (Updatable) HTTP header fields to include in health check requests, expressed as `"name": "value"` properties. Because HTTP header field names are case-insensitive, any use of names that are case-insensitive equal to other names will be rejected. If Host is not specified, requests will include a Host header field with value matching the policy's protected domain. If User-Agent is not specified, requests will include a User-Agent header field with value "waf health checks".
        :param pulumi.Input[int] healthy_threshold: (Updatable) Number of successful health checks after which the server is marked up.
        :param pulumi.Input[int] interval_in_seconds: (Updatable) Time between health checks of an individual origin server, in seconds.
        :param pulumi.Input[bool] is_enabled: (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        :param pulumi.Input[bool] is_response_text_check_enabled: (Updatable) Enables or disables additional check for predefined text in addition to response code.
        :param pulumi.Input[str] method: (Updatable) Load balancing methods are algorithms used to efficiently distribute traffic among origin servers.
               * **[IP_HASH](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/IPHashLoadBalancingMethod):** All the incoming requests from the same client IP address should go to the same content origination server. IP_HASH load balancing method uses origin weights when choosing which origin should the hash be assigned to initially.
               * **[ROUND_ROBIN](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/RoundRobinLoadBalancingMethod):** Forwards requests sequentially to the available origin servers. The first request - to the first origin server, the second request - to the next origin server, and so on. After it sends a request to the last origin server, it starts again with the first origin server. When using weights on origins, Weighted Round Robin assigns more requests to origins with a greater weight. Over a period of time, origins will receive a number of requests in proportion to their weight.
               * **[STICKY_COOKIE](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/StickyCookieLoadBalancingMethod):** Adds a session cookie to the first response from the origin server and identifies the server that sent the response. The client's next request contains the cookie value, and nginx routes the request to the origin server that responded to the first request. STICKY_COOKIE load balancing method falls back to Round Robin for the first request.
        :param pulumi.Input[str] path: (Updatable) Path to visit on your origins when performing the health check.
        :param pulumi.Input[int] timeout_in_seconds: (Updatable) Response timeout represents wait time until request is considered failed, in seconds.
        :param pulumi.Input[int] unhealthy_threshold: (Updatable) Number of failed health checks after which the server is marked down.
        """
        if expected_response_code_groups is not None:
            pulumi.set(__self__, "expected_response_code_groups", expected_response_code_groups)
        if expected_response_text is not None:
            pulumi.set(__self__, "expected_response_text", expected_response_text)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if interval_in_seconds is not None:
            pulumi.set(__self__, "interval_in_seconds", interval_in_seconds)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_response_text_check_enabled is not None:
            pulumi.set(__self__, "is_response_text_check_enabled", is_response_text_check_enabled)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter(name="expectedResponseCodeGroups")
    def expected_response_code_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The HTTP response codes that signify a healthy state.
        * **2XX:** Success response code group.
        * **3XX:** Redirection response code group.
        * **4XX:** Client errors response code group.
        * **5XX:** Server errors response code group.
        """
        return pulumi.get(self, "expected_response_code_groups")

    @expected_response_code_groups.setter
    def expected_response_code_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expected_response_code_groups", value)

    @property
    @pulumi.getter(name="expectedResponseText")
    def expected_response_text(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Health check will search for the given text in a case-sensitive manner within the response body and will fail if the text is not found.
        """
        return pulumi.get(self, "expected_response_text")

    @expected_response_text.setter
    def expected_response_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expected_response_text", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        (Updatable) HTTP header fields to include in health check requests, expressed as `"name": "value"` properties. Because HTTP header field names are case-insensitive, any use of names that are case-insensitive equal to other names will be rejected. If Host is not specified, requests will include a Host header field with value matching the policy's protected domain. If User-Agent is not specified, requests will include a User-Agent header field with value "waf health checks".
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of successful health checks after which the server is marked up.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter(name="intervalInSeconds")
    def interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Time between health checks of an individual origin server, in seconds.
        """
        return pulumi.get(self, "interval_in_seconds")

    @interval_in_seconds.setter
    def interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_in_seconds", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="isResponseTextCheckEnabled")
    def is_response_text_check_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables additional check for predefined text in addition to response code.
        """
        return pulumi.get(self, "is_response_text_check_enabled")

    @is_response_text_check_enabled.setter
    def is_response_text_check_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_response_text_check_enabled", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Load balancing methods are algorithms used to efficiently distribute traffic among origin servers.
        * **[IP_HASH](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/IPHashLoadBalancingMethod):** All the incoming requests from the same client IP address should go to the same content origination server. IP_HASH load balancing method uses origin weights when choosing which origin should the hash be assigned to initially.
        * **[ROUND_ROBIN](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/RoundRobinLoadBalancingMethod):** Forwards requests sequentially to the available origin servers. The first request - to the first origin server, the second request - to the next origin server, and so on. After it sends a request to the last origin server, it starts again with the first origin server. When using weights on origins, Weighted Round Robin assigns more requests to origins with a greater weight. Over a period of time, origins will receive a number of requests in proportion to their weight.
        * **[STICKY_COOKIE](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/StickyCookieLoadBalancingMethod):** Adds a session cookie to the first response from the origin server and identifies the server that sent the response. The client's next request contains the cookie value, and nginx routes the request to the origin server that responded to the first request. STICKY_COOKIE load balancing method falls back to Round Robin for the first request.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) Path to visit on your origins when performing the health check.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Response timeout represents wait time until request is considered failed, in seconds.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) Number of failed health checks after which the server is marked down.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


@pulumi.input_type
class WaasWaasPolicyPolicyConfigLoadBalancingMethodArgs:
    def __init__(__self__, *,
                 method: pulumi.Input[str],
                 domain: Optional[pulumi.Input[str]] = None,
                 expiration_time_in_seconds: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] method: (Updatable) Load balancing methods are algorithms used to efficiently distribute traffic among origin servers.
               * **[IP_HASH](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/IPHashLoadBalancingMethod):** All the incoming requests from the same client IP address should go to the same content origination server. IP_HASH load balancing method uses origin weights when choosing which origin should the hash be assigned to initially.
               * **[ROUND_ROBIN](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/RoundRobinLoadBalancingMethod):** Forwards requests sequentially to the available origin servers. The first request - to the first origin server, the second request - to the next origin server, and so on. After it sends a request to the last origin server, it starts again with the first origin server. When using weights on origins, Weighted Round Robin assigns more requests to origins with a greater weight. Over a period of time, origins will receive a number of requests in proportion to their weight.
               * **[STICKY_COOKIE](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/StickyCookieLoadBalancingMethod):** Adds a session cookie to the first response from the origin server and identifies the server that sent the response. The client's next request contains the cookie value, and nginx routes the request to the origin server that responded to the first request. STICKY_COOKIE load balancing method falls back to Round Robin for the first request.
        :param pulumi.Input[str] domain: (Updatable) The domain for which the cookie is set, defaults to WAAS policy domain.
        :param pulumi.Input[int] expiration_time_in_seconds: (Updatable) The time for which a browser should keep the cookie in seconds. Empty value will cause the cookie to expire at the end of a browser session.
        :param pulumi.Input[str] name: (Updatable) The unique name of the whitelist.
        """
        pulumi.set(__self__, "method", method)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if expiration_time_in_seconds is not None:
            pulumi.set(__self__, "expiration_time_in_seconds", expiration_time_in_seconds)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def method(self) -> pulumi.Input[str]:
        """
        (Updatable) Load balancing methods are algorithms used to efficiently distribute traffic among origin servers.
        * **[IP_HASH](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/IPHashLoadBalancingMethod):** All the incoming requests from the same client IP address should go to the same content origination server. IP_HASH load balancing method uses origin weights when choosing which origin should the hash be assigned to initially.
        * **[ROUND_ROBIN](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/RoundRobinLoadBalancingMethod):** Forwards requests sequentially to the available origin servers. The first request - to the first origin server, the second request - to the next origin server, and so on. After it sends a request to the last origin server, it starts again with the first origin server. When using weights on origins, Weighted Round Robin assigns more requests to origins with a greater weight. Over a period of time, origins will receive a number of requests in proportion to their weight.
        * **[STICKY_COOKIE](https://www.terraform.io/iaas/api/#/en/waas/latest/datatypes/StickyCookieLoadBalancingMethod):** Adds a session cookie to the first response from the origin server and identifies the server that sent the response. The client's next request contains the cookie value, and nginx routes the request to the origin server that responded to the first request. STICKY_COOKIE load balancing method falls back to Round Robin for the first request.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input[str]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The domain for which the cookie is set, defaults to WAAS policy domain.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="expirationTimeInSeconds")
    def expiration_time_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The time for which a browser should keep the cookie in seconds. Empty value will cause the cookie to expire at the end of a browser session.
        """
        return pulumi.get(self, "expiration_time_in_seconds")

    @expiration_time_in_seconds.setter
    def expiration_time_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration_time_in_seconds", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigArgs:
    def __init__(__self__, *,
                 access_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleArgs']]]] = None,
                 address_rate_limiting: Optional[pulumi.Input['WaasWaasPolicyWafConfigAddressRateLimitingArgs']] = None,
                 caching_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleArgs']]]] = None,
                 captchas: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCaptchaArgs']]]] = None,
                 custom_protection_rules: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleArgs']]]] = None,
                 device_fingerprint_challenge: Optional[pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeArgs']] = None,
                 human_interaction_challenge: Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeArgs']] = None,
                 js_challenge: Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeArgs']] = None,
                 origin: Optional[pulumi.Input[str]] = None,
                 origin_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 protection_settings: Optional[pulumi.Input['WaasWaasPolicyWafConfigProtectionSettingsArgs']] = None,
                 whitelists: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigWhitelistArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleArgs']]] access_rules: (Updatable) The access rules applied to the Web Application Firewall. Access rules allow custom content access policies to be defined and `ALLOW`, `DETECT`, or `BLOCK` actions to be taken on a request when specified criteria are met.
        :param pulumi.Input['WaasWaasPolicyWafConfigAddressRateLimitingArgs'] address_rate_limiting: (Updatable) The settings used to limit the number of requests from an IP address.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleArgs']]] caching_rules: (Updatable) A list of caching rules applied to the web application.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCaptchaArgs']]] captchas: (Updatable) A list of CAPTCHA challenge settings. CAPTCHAs challenge requests to ensure a human is attempting to reach the specified URL and not a bot.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleArgs']]] custom_protection_rules: (Updatable) A list of the custom protection rule OCIDs and their actions.
        :param pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeArgs'] device_fingerprint_challenge: (Updatable) The device fingerprint challenge settings. Blocks bots based on unique device fingerprint information.
        :param pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeArgs'] human_interaction_challenge: (Updatable) The human interaction challenge settings. Detects natural human interactions such as mouse movements, time on site, and page scrolling to identify bots.
        :param pulumi.Input['WaasWaasPolicyWafConfigJsChallengeArgs'] js_challenge: (Updatable) The JavaScript challenge settings. Blocks bots by challenging requests from browsers that have no JavaScript support.
        :param pulumi.Input[str] origin: (Updatable) The key in the map of origins referencing the origin used for the Web Application Firewall. The origin must already be included in `Origins`. Required when creating the `WafConfig` resource, but is not required upon updating the configuration.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] origin_groups: (Updatable) The map of origin groups and their keys used to associate origins to the `wafConfig`. Origin groups allow you to apply weights to groups of origins for load balancing purposes. Origins with higher weights will receive larger proportions of client requests. To add additional origins to your WAAS policy, update the `origins` field of a `UpdateWaasPolicy` request.
        :param pulumi.Input['WaasWaasPolicyWafConfigProtectionSettingsArgs'] protection_settings: (Updatable) The settings applied to protection rules.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigWhitelistArgs']]] whitelists: (Updatable) A list of IP addresses that bypass the Web Application Firewall.
        """
        if access_rules is not None:
            pulumi.set(__self__, "access_rules", access_rules)
        if address_rate_limiting is not None:
            pulumi.set(__self__, "address_rate_limiting", address_rate_limiting)
        if caching_rules is not None:
            pulumi.set(__self__, "caching_rules", caching_rules)
        if captchas is not None:
            pulumi.set(__self__, "captchas", captchas)
        if custom_protection_rules is not None:
            pulumi.set(__self__, "custom_protection_rules", custom_protection_rules)
        if device_fingerprint_challenge is not None:
            pulumi.set(__self__, "device_fingerprint_challenge", device_fingerprint_challenge)
        if human_interaction_challenge is not None:
            pulumi.set(__self__, "human_interaction_challenge", human_interaction_challenge)
        if js_challenge is not None:
            pulumi.set(__self__, "js_challenge", js_challenge)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if origin_groups is not None:
            pulumi.set(__self__, "origin_groups", origin_groups)
        if protection_settings is not None:
            pulumi.set(__self__, "protection_settings", protection_settings)
        if whitelists is not None:
            pulumi.set(__self__, "whitelists", whitelists)

    @property
    @pulumi.getter(name="accessRules")
    def access_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleArgs']]]]:
        """
        (Updatable) The access rules applied to the Web Application Firewall. Access rules allow custom content access policies to be defined and `ALLOW`, `DETECT`, or `BLOCK` actions to be taken on a request when specified criteria are met.
        """
        return pulumi.get(self, "access_rules")

    @access_rules.setter
    def access_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleArgs']]]]):
        pulumi.set(self, "access_rules", value)

    @property
    @pulumi.getter(name="addressRateLimiting")
    def address_rate_limiting(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigAddressRateLimitingArgs']]:
        """
        (Updatable) The settings used to limit the number of requests from an IP address.
        """
        return pulumi.get(self, "address_rate_limiting")

    @address_rate_limiting.setter
    def address_rate_limiting(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigAddressRateLimitingArgs']]):
        pulumi.set(self, "address_rate_limiting", value)

    @property
    @pulumi.getter(name="cachingRules")
    def caching_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleArgs']]]]:
        """
        (Updatable) A list of caching rules applied to the web application.
        """
        return pulumi.get(self, "caching_rules")

    @caching_rules.setter
    def caching_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleArgs']]]]):
        pulumi.set(self, "caching_rules", value)

    @property
    @pulumi.getter
    def captchas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCaptchaArgs']]]]:
        """
        (Updatable) A list of CAPTCHA challenge settings. CAPTCHAs challenge requests to ensure a human is attempting to reach the specified URL and not a bot.
        """
        return pulumi.get(self, "captchas")

    @captchas.setter
    def captchas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCaptchaArgs']]]]):
        pulumi.set(self, "captchas", value)

    @property
    @pulumi.getter(name="customProtectionRules")
    def custom_protection_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleArgs']]]]:
        """
        (Updatable) A list of the custom protection rule OCIDs and their actions.
        """
        return pulumi.get(self, "custom_protection_rules")

    @custom_protection_rules.setter
    def custom_protection_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleArgs']]]]):
        pulumi.set(self, "custom_protection_rules", value)

    @property
    @pulumi.getter(name="deviceFingerprintChallenge")
    def device_fingerprint_challenge(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeArgs']]:
        """
        (Updatable) The device fingerprint challenge settings. Blocks bots based on unique device fingerprint information.
        """
        return pulumi.get(self, "device_fingerprint_challenge")

    @device_fingerprint_challenge.setter
    def device_fingerprint_challenge(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeArgs']]):
        pulumi.set(self, "device_fingerprint_challenge", value)

    @property
    @pulumi.getter(name="humanInteractionChallenge")
    def human_interaction_challenge(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeArgs']]:
        """
        (Updatable) The human interaction challenge settings. Detects natural human interactions such as mouse movements, time on site, and page scrolling to identify bots.
        """
        return pulumi.get(self, "human_interaction_challenge")

    @human_interaction_challenge.setter
    def human_interaction_challenge(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeArgs']]):
        pulumi.set(self, "human_interaction_challenge", value)

    @property
    @pulumi.getter(name="jsChallenge")
    def js_challenge(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeArgs']]:
        """
        (Updatable) The JavaScript challenge settings. Blocks bots by challenging requests from browsers that have no JavaScript support.
        """
        return pulumi.get(self, "js_challenge")

    @js_challenge.setter
    def js_challenge(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeArgs']]):
        pulumi.set(self, "js_challenge", value)

    @property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The key in the map of origins referencing the origin used for the Web Application Firewall. The origin must already be included in `Origins`. Required when creating the `WafConfig` resource, but is not required upon updating the configuration.
        """
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "origin", value)

    @property
    @pulumi.getter(name="originGroups")
    def origin_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The map of origin groups and their keys used to associate origins to the `wafConfig`. Origin groups allow you to apply weights to groups of origins for load balancing purposes. Origins with higher weights will receive larger proportions of client requests. To add additional origins to your WAAS policy, update the `origins` field of a `UpdateWaasPolicy` request.
        """
        return pulumi.get(self, "origin_groups")

    @origin_groups.setter
    def origin_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "origin_groups", value)

    @property
    @pulumi.getter(name="protectionSettings")
    def protection_settings(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigProtectionSettingsArgs']]:
        """
        (Updatable) The settings applied to protection rules.
        """
        return pulumi.get(self, "protection_settings")

    @protection_settings.setter
    def protection_settings(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigProtectionSettingsArgs']]):
        pulumi.set(self, "protection_settings", value)

    @property
    @pulumi.getter
    def whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigWhitelistArgs']]]]:
        """
        (Updatable) A list of IP addresses that bypass the Web Application Firewall.
        """
        return pulumi.get(self, "whitelists")

    @whitelists.setter
    def whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigWhitelistArgs']]]]):
        pulumi.set(self, "whitelists", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigAccessRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 criterias: pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleCriteriaArgs']]],
                 name: pulumi.Input[str],
                 block_action: Optional[pulumi.Input[str]] = None,
                 block_error_page_code: Optional[pulumi.Input[str]] = None,
                 block_error_page_description: Optional[pulumi.Input[str]] = None,
                 block_error_page_message: Optional[pulumi.Input[str]] = None,
                 block_response_code: Optional[pulumi.Input[int]] = None,
                 bypass_challenges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 captcha_footer: Optional[pulumi.Input[str]] = None,
                 captcha_header: Optional[pulumi.Input[str]] = None,
                 captcha_submit_label: Optional[pulumi.Input[str]] = None,
                 captcha_title: Optional[pulumi.Input[str]] = None,
                 redirect_response_code: Optional[pulumi.Input[str]] = None,
                 redirect_url: Optional[pulumi.Input[str]] = None,
                 response_header_manipulations: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleResponseHeaderManipulationArgs']]]] = None):
        """
        :param pulumi.Input[str] action: (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleCriteriaArgs']]] criterias: (Updatable) When defined, the JavaScript Challenge would be applied only for the requests that matched all the listed conditions.
        :param pulumi.Input[str] name: (Updatable) The unique name of the whitelist.
        :param pulumi.Input[str] block_action: (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        :param pulumi.Input[str] block_error_page_code: (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        :param pulumi.Input[str] block_error_page_description: (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        :param pulumi.Input[str] block_error_page_message: (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        :param pulumi.Input[int] block_response_code: (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] bypass_challenges: (Updatable) The list of challenges to bypass when `action` is set to `BYPASS`. If unspecified or empty, all challenges are bypassed.
               * **JS_CHALLENGE:** Bypasses JavaScript Challenge.
               * **DEVICE_FINGERPRINT_CHALLENGE:** Bypasses Device Fingerprint Challenge.
               * **HUMAN_INTERACTION_CHALLENGE:** Bypasses Human Interaction Challenge.
               * **CAPTCHA:** Bypasses CAPTCHA Challenge.
        :param pulumi.Input[str] captcha_footer: (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        :param pulumi.Input[str] captcha_header: (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        :param pulumi.Input[str] captcha_submit_label: (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        :param pulumi.Input[str] captcha_title: (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        :param pulumi.Input[str] redirect_response_code: (Updatable) The response status code to return when `action` is set to `REDIRECT`.
               * **MOVED_PERMANENTLY:** Used for designating the permanent movement of a page (numerical code - 301).
               * **FOUND:** Used for designating the temporary movement of a page (numerical code - 302).
        :param pulumi.Input[str] redirect_url: (Updatable) The target to which the request should be redirected, represented as a URI reference. Required when `action` is `REDIRECT`.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleResponseHeaderManipulationArgs']]] response_header_manipulations: (Updatable) An object that represents an action to apply to an HTTP response headers if all rule criteria will be matched regardless of `action` value.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "criterias", criterias)
        pulumi.set(__self__, "name", name)
        if block_action is not None:
            pulumi.set(__self__, "block_action", block_action)
        if block_error_page_code is not None:
            pulumi.set(__self__, "block_error_page_code", block_error_page_code)
        if block_error_page_description is not None:
            pulumi.set(__self__, "block_error_page_description", block_error_page_description)
        if block_error_page_message is not None:
            pulumi.set(__self__, "block_error_page_message", block_error_page_message)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if bypass_challenges is not None:
            pulumi.set(__self__, "bypass_challenges", bypass_challenges)
        if captcha_footer is not None:
            pulumi.set(__self__, "captcha_footer", captcha_footer)
        if captcha_header is not None:
            pulumi.set(__self__, "captcha_header", captcha_header)
        if captcha_submit_label is not None:
            pulumi.set(__self__, "captcha_submit_label", captcha_submit_label)
        if captcha_title is not None:
            pulumi.set(__self__, "captcha_title", captcha_title)
        if redirect_response_code is not None:
            pulumi.set(__self__, "redirect_response_code", redirect_response_code)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if response_header_manipulations is not None:
            pulumi.set(__self__, "response_header_manipulations", response_header_manipulations)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def criterias(self) -> pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleCriteriaArgs']]]:
        """
        (Updatable) When defined, the JavaScript Challenge would be applied only for the requests that matched all the listed conditions.
        """
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleCriteriaArgs']]]):
        pulumi.set(self, "criterias", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="blockAction")
    def block_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        """
        return pulumi.get(self, "block_action")

    @block_action.setter
    def block_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_action", value)

    @property
    @pulumi.getter(name="blockErrorPageCode")
    def block_error_page_code(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        """
        return pulumi.get(self, "block_error_page_code")

    @block_error_page_code.setter
    def block_error_page_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_code", value)

    @property
    @pulumi.getter(name="blockErrorPageDescription")
    def block_error_page_description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        """
        return pulumi.get(self, "block_error_page_description")

    @block_error_page_description.setter
    def block_error_page_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_description", value)

    @property
    @pulumi.getter(name="blockErrorPageMessage")
    def block_error_page_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        """
        return pulumi.get(self, "block_error_page_message")

    @block_error_page_message.setter
    def block_error_page_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_message", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="bypassChallenges")
    def bypass_challenges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of challenges to bypass when `action` is set to `BYPASS`. If unspecified or empty, all challenges are bypassed.
        * **JS_CHALLENGE:** Bypasses JavaScript Challenge.
        * **DEVICE_FINGERPRINT_CHALLENGE:** Bypasses Device Fingerprint Challenge.
        * **HUMAN_INTERACTION_CHALLENGE:** Bypasses Human Interaction Challenge.
        * **CAPTCHA:** Bypasses CAPTCHA Challenge.
        """
        return pulumi.get(self, "bypass_challenges")

    @bypass_challenges.setter
    def bypass_challenges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "bypass_challenges", value)

    @property
    @pulumi.getter(name="captchaFooter")
    def captcha_footer(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        """
        return pulumi.get(self, "captcha_footer")

    @captcha_footer.setter
    def captcha_footer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_footer", value)

    @property
    @pulumi.getter(name="captchaHeader")
    def captcha_header(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        """
        return pulumi.get(self, "captcha_header")

    @captcha_header.setter
    def captcha_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_header", value)

    @property
    @pulumi.getter(name="captchaSubmitLabel")
    def captcha_submit_label(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        """
        return pulumi.get(self, "captcha_submit_label")

    @captcha_submit_label.setter
    def captcha_submit_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_submit_label", value)

    @property
    @pulumi.getter(name="captchaTitle")
    def captcha_title(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        """
        return pulumi.get(self, "captcha_title")

    @captcha_title.setter
    def captcha_title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_title", value)

    @property
    @pulumi.getter(name="redirectResponseCode")
    def redirect_response_code(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The response status code to return when `action` is set to `REDIRECT`.
        * **MOVED_PERMANENTLY:** Used for designating the permanent movement of a page (numerical code - 301).
        * **FOUND:** Used for designating the temporary movement of a page (numerical code - 302).
        """
        return pulumi.get(self, "redirect_response_code")

    @redirect_response_code.setter
    def redirect_response_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_response_code", value)

    @property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target to which the request should be redirected, represented as a URI reference. Required when `action` is `REDIRECT`.
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_url", value)

    @property
    @pulumi.getter(name="responseHeaderManipulations")
    def response_header_manipulations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleResponseHeaderManipulationArgs']]]]:
        """
        (Updatable) An object that represents an action to apply to an HTTP response headers if all rule criteria will be matched regardless of `action` value.
        """
        return pulumi.get(self, "response_header_manipulations")

    @response_header_manipulations.setter
    def response_header_manipulations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigAccessRuleResponseHeaderManipulationArgs']]]]):
        pulumi.set(self, "response_header_manipulations", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigAccessRuleCriteriaArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 value: pulumi.Input[str],
                 is_case_sensitive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] condition: (Updatable) The criteria the access rule and JavaScript Challenge uses to determine if action should be taken on a request.
               * **URL_IS:** Matches if the concatenation of request URL path and query is identical to the contents of the `value` field. URL must start with a `/`.
               * **URL_IS_NOT:** Matches if the concatenation of request URL path and query is not identical to the contents of the `value` field. URL must start with a `/`.
               * **URL_STARTS_WITH:** Matches if the concatenation of request URL path and query starts with the contents of the `value` field. URL must start with a `/`.
               * **URL_PART_ENDS_WITH:** Matches if the concatenation of request URL path and query ends with the contents of the `value` field.
               * **URL_PART_CONTAINS:** Matches if the concatenation of request URL path and query contains the contents of the `value` field.
               * **URL_REGEX:** Matches if the concatenation of request URL path and query is described by the regular expression in the value field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
               * **URL_DOES_NOT_MATCH_REGEX:** Matches if the concatenation of request URL path and query is not described by the regular expression in the `value` field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
               * **URL_DOES_NOT_START_WITH:** Matches if the concatenation of request URL path and query does not start with the contents of the `value` field.
               * **URL_PART_DOES_NOT_CONTAIN:** Matches if the concatenation of request URL path and query does not contain the contents of the `value` field.
               * **URL_PART_DOES_NOT_END_WITH:** Matches if the concatenation of request URL path and query does not end with the contents of the `value` field.
               * **IP_IS:** Matches if the request originates from one of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
               * **IP_IS_NOT:** Matches if the request does not originate from any of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
               * **IP_IN_LIST:** Matches if the request originates from one of the IP addresses contained in the referenced address list. The `value` in this case is OCID of the address list.
               * **IP_NOT_IN_LIST:** Matches if the request does not originate from any IP address contained in the referenced address list. The `value` field in this case is OCID of the address list.
               * **HTTP_HEADER_CONTAINS:** The HTTP_HEADER_CONTAINS criteria is defined using a compound value separated by a colon: a header field name and a header field value. `host:test.example.com` is an example of a criteria value where `host` is the header field name and `test.example.com` is the header field value. A request matches when the header field name is a case insensitive match and the header field value is a case insensitive, substring match. *Example:* With a criteria value of `host:test.example.com`, where `host` is the name of the field and `test.example.com` is the value of the host field, a request with the header values, `Host: www.test.example.com` will match, where as a request with header values of `host: www.example.com` or `host: test.sub.example.com` will not match.
               * **HTTP_METHOD_IS:** Matches if the request method is identical to one of the values listed in field. The `value` in this case is string with one or multiple HTTP methods separated by new line symbol \n The list of available methods: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`
        :param pulumi.Input[str] value: (Updatable) The value of the header.
        :param pulumi.Input[bool] is_case_sensitive: (Updatable) When enabled, the condition will be matched with case-sensitive rules.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "value", value)
        if is_case_sensitive is not None:
            pulumi.set(__self__, "is_case_sensitive", is_case_sensitive)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        (Updatable) The criteria the access rule and JavaScript Challenge uses to determine if action should be taken on a request.
        * **URL_IS:** Matches if the concatenation of request URL path and query is identical to the contents of the `value` field. URL must start with a `/`.
        * **URL_IS_NOT:** Matches if the concatenation of request URL path and query is not identical to the contents of the `value` field. URL must start with a `/`.
        * **URL_STARTS_WITH:** Matches if the concatenation of request URL path and query starts with the contents of the `value` field. URL must start with a `/`.
        * **URL_PART_ENDS_WITH:** Matches if the concatenation of request URL path and query ends with the contents of the `value` field.
        * **URL_PART_CONTAINS:** Matches if the concatenation of request URL path and query contains the contents of the `value` field.
        * **URL_REGEX:** Matches if the concatenation of request URL path and query is described by the regular expression in the value field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
        * **URL_DOES_NOT_MATCH_REGEX:** Matches if the concatenation of request URL path and query is not described by the regular expression in the `value` field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
        * **URL_DOES_NOT_START_WITH:** Matches if the concatenation of request URL path and query does not start with the contents of the `value` field.
        * **URL_PART_DOES_NOT_CONTAIN:** Matches if the concatenation of request URL path and query does not contain the contents of the `value` field.
        * **URL_PART_DOES_NOT_END_WITH:** Matches if the concatenation of request URL path and query does not end with the contents of the `value` field.
        * **IP_IS:** Matches if the request originates from one of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
        * **IP_IS_NOT:** Matches if the request does not originate from any of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
        * **IP_IN_LIST:** Matches if the request originates from one of the IP addresses contained in the referenced address list. The `value` in this case is OCID of the address list.
        * **IP_NOT_IN_LIST:** Matches if the request does not originate from any IP address contained in the referenced address list. The `value` field in this case is OCID of the address list.
        * **HTTP_HEADER_CONTAINS:** The HTTP_HEADER_CONTAINS criteria is defined using a compound value separated by a colon: a header field name and a header field value. `host:test.example.com` is an example of a criteria value where `host` is the header field name and `test.example.com` is the header field value. A request matches when the header field name is a case insensitive match and the header field value is a case insensitive, substring match. *Example:* With a criteria value of `host:test.example.com`, where `host` is the name of the field and `test.example.com` is the value of the host field, a request with the header values, `Host: www.test.example.com` will match, where as a request with header values of `host: www.example.com` or `host: test.sub.example.com` will not match.
        * **HTTP_METHOD_IS:** Matches if the request method is identical to one of the values listed in field. The `value` in this case is string with one or multiple HTTP methods separated by new line symbol \n The list of available methods: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isCaseSensitive")
    def is_case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) When enabled, the condition will be matched with case-sensitive rules.
        """
        return pulumi.get(self, "is_case_sensitive")

    @is_case_sensitive.setter
    def is_case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_case_sensitive", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigAccessRuleResponseHeaderManipulationArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 header: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        :param pulumi.Input[str] header: (Updatable) A header field name that conforms to RFC 7230.  Example: `example_header_name`
        :param pulumi.Input[str] value: (Updatable) The value of the header.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "header", header)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input[str]:
        """
        (Updatable) A header field name that conforms to RFC 7230.  Example: `example_header_name`
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input[str]):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigAddressRateLimitingArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 allowed_rate_per_address: Optional[pulumi.Input[int]] = None,
                 block_response_code: Optional[pulumi.Input[int]] = None,
                 max_delayed_count_per_address: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        :param pulumi.Input[int] allowed_rate_per_address: (Updatable) The number of allowed requests per second from one IP address. If unspecified, defaults to `1`.
        :param pulumi.Input[int] block_response_code: (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        :param pulumi.Input[int] max_delayed_count_per_address: (Updatable) The maximum number of requests allowed to be queued before subsequent requests are dropped. If unspecified, defaults to `10`.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if allowed_rate_per_address is not None:
            pulumi.set(__self__, "allowed_rate_per_address", allowed_rate_per_address)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if max_delayed_count_per_address is not None:
            pulumi.set(__self__, "max_delayed_count_per_address", max_delayed_count_per_address)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="allowedRatePerAddress")
    def allowed_rate_per_address(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of allowed requests per second from one IP address. If unspecified, defaults to `1`.
        """
        return pulumi.get(self, "allowed_rate_per_address")

    @allowed_rate_per_address.setter
    def allowed_rate_per_address(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "allowed_rate_per_address", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="maxDelayedCountPerAddress")
    def max_delayed_count_per_address(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum number of requests allowed to be queued before subsequent requests are dropped. If unspecified, defaults to `10`.
        """
        return pulumi.get(self, "max_delayed_count_per_address")

    @max_delayed_count_per_address.setter
    def max_delayed_count_per_address(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_delayed_count_per_address", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigCachingRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 criterias: pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleCriteriaArgs']]],
                 name: pulumi.Input[str],
                 caching_duration: Optional[pulumi.Input[str]] = None,
                 client_caching_duration: Optional[pulumi.Input[str]] = None,
                 is_client_caching_enabled: Optional[pulumi.Input[bool]] = None,
                 key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleCriteriaArgs']]] criterias: (Updatable) When defined, the JavaScript Challenge would be applied only for the requests that matched all the listed conditions.
        :param pulumi.Input[str] name: (Updatable) The unique name of the whitelist.
        :param pulumi.Input[str] caching_duration: (Updatable) The duration to cache content for the caching rule, specified in ISO 8601 extended format. Supported units: seconds, minutes, hours, days, weeks, months. The maximum value that can be set for any unit is `99`. Mixing of multiple units is not supported. Only applies when the `action` is set to `CACHE`. Example: `PT1H`
        :param pulumi.Input[str] client_caching_duration: (Updatable) The duration to cache content in the user's browser, specified in ISO 8601 extended format. Supported units: seconds, minutes, hours, days, weeks, months. The maximum value that can be set for any unit is `99`. Mixing of multiple units is not supported. Only applies when the `action` is set to `CACHE`. Example: `PT1H`
        :param pulumi.Input[bool] is_client_caching_enabled: (Updatable) Enables or disables client caching. Browsers use the `Cache-Control` header value for caching content locally in the browser. This setting overrides the addition of a `Cache-Control` header in responses.
        :param pulumi.Input[str] key: (Updatable) The unique key for the caching rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "criterias", criterias)
        pulumi.set(__self__, "name", name)
        if caching_duration is not None:
            pulumi.set(__self__, "caching_duration", caching_duration)
        if client_caching_duration is not None:
            pulumi.set(__self__, "client_caching_duration", client_caching_duration)
        if is_client_caching_enabled is not None:
            pulumi.set(__self__, "is_client_caching_enabled", is_client_caching_enabled)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def criterias(self) -> pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleCriteriaArgs']]]:
        """
        (Updatable) When defined, the JavaScript Challenge would be applied only for the requests that matched all the listed conditions.
        """
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCachingRuleCriteriaArgs']]]):
        pulumi.set(self, "criterias", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="cachingDuration")
    def caching_duration(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The duration to cache content for the caching rule, specified in ISO 8601 extended format. Supported units: seconds, minutes, hours, days, weeks, months. The maximum value that can be set for any unit is `99`. Mixing of multiple units is not supported. Only applies when the `action` is set to `CACHE`. Example: `PT1H`
        """
        return pulumi.get(self, "caching_duration")

    @caching_duration.setter
    def caching_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caching_duration", value)

    @property
    @pulumi.getter(name="clientCachingDuration")
    def client_caching_duration(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The duration to cache content in the user's browser, specified in ISO 8601 extended format. Supported units: seconds, minutes, hours, days, weeks, months. The maximum value that can be set for any unit is `99`. Mixing of multiple units is not supported. Only applies when the `action` is set to `CACHE`. Example: `PT1H`
        """
        return pulumi.get(self, "client_caching_duration")

    @client_caching_duration.setter
    def client_caching_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_caching_duration", value)

    @property
    @pulumi.getter(name="isClientCachingEnabled")
    def is_client_caching_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Enables or disables client caching. Browsers use the `Cache-Control` header value for caching content locally in the browser. This setting overrides the addition of a `Cache-Control` header in responses.
        """
        return pulumi.get(self, "is_client_caching_enabled")

    @is_client_caching_enabled.setter
    def is_client_caching_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_client_caching_enabled", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The unique key for the caching rule.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigCachingRuleCriteriaArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] condition: (Updatable) The criteria the access rule and JavaScript Challenge uses to determine if action should be taken on a request.
               * **URL_IS:** Matches if the concatenation of request URL path and query is identical to the contents of the `value` field. URL must start with a `/`.
               * **URL_IS_NOT:** Matches if the concatenation of request URL path and query is not identical to the contents of the `value` field. URL must start with a `/`.
               * **URL_STARTS_WITH:** Matches if the concatenation of request URL path and query starts with the contents of the `value` field. URL must start with a `/`.
               * **URL_PART_ENDS_WITH:** Matches if the concatenation of request URL path and query ends with the contents of the `value` field.
               * **URL_PART_CONTAINS:** Matches if the concatenation of request URL path and query contains the contents of the `value` field.
               * **URL_REGEX:** Matches if the concatenation of request URL path and query is described by the regular expression in the value field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
               * **URL_DOES_NOT_MATCH_REGEX:** Matches if the concatenation of request URL path and query is not described by the regular expression in the `value` field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
               * **URL_DOES_NOT_START_WITH:** Matches if the concatenation of request URL path and query does not start with the contents of the `value` field.
               * **URL_PART_DOES_NOT_CONTAIN:** Matches if the concatenation of request URL path and query does not contain the contents of the `value` field.
               * **URL_PART_DOES_NOT_END_WITH:** Matches if the concatenation of request URL path and query does not end with the contents of the `value` field.
               * **IP_IS:** Matches if the request originates from one of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
               * **IP_IS_NOT:** Matches if the request does not originate from any of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
               * **IP_IN_LIST:** Matches if the request originates from one of the IP addresses contained in the referenced address list. The `value` in this case is OCID of the address list.
               * **IP_NOT_IN_LIST:** Matches if the request does not originate from any IP address contained in the referenced address list. The `value` field in this case is OCID of the address list.
               * **HTTP_HEADER_CONTAINS:** The HTTP_HEADER_CONTAINS criteria is defined using a compound value separated by a colon: a header field name and a header field value. `host:test.example.com` is an example of a criteria value where `host` is the header field name and `test.example.com` is the header field value. A request matches when the header field name is a case insensitive match and the header field value is a case insensitive, substring match. *Example:* With a criteria value of `host:test.example.com`, where `host` is the name of the field and `test.example.com` is the value of the host field, a request with the header values, `Host: www.test.example.com` will match, where as a request with header values of `host: www.example.com` or `host: test.sub.example.com` will not match.
               * **HTTP_METHOD_IS:** Matches if the request method is identical to one of the values listed in field. The `value` in this case is string with one or multiple HTTP methods separated by new line symbol \n The list of available methods: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`
        :param pulumi.Input[str] value: (Updatable) The value of the header.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        (Updatable) The criteria the access rule and JavaScript Challenge uses to determine if action should be taken on a request.
        * **URL_IS:** Matches if the concatenation of request URL path and query is identical to the contents of the `value` field. URL must start with a `/`.
        * **URL_IS_NOT:** Matches if the concatenation of request URL path and query is not identical to the contents of the `value` field. URL must start with a `/`.
        * **URL_STARTS_WITH:** Matches if the concatenation of request URL path and query starts with the contents of the `value` field. URL must start with a `/`.
        * **URL_PART_ENDS_WITH:** Matches if the concatenation of request URL path and query ends with the contents of the `value` field.
        * **URL_PART_CONTAINS:** Matches if the concatenation of request URL path and query contains the contents of the `value` field.
        * **URL_REGEX:** Matches if the concatenation of request URL path and query is described by the regular expression in the value field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
        * **URL_DOES_NOT_MATCH_REGEX:** Matches if the concatenation of request URL path and query is not described by the regular expression in the `value` field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
        * **URL_DOES_NOT_START_WITH:** Matches if the concatenation of request URL path and query does not start with the contents of the `value` field.
        * **URL_PART_DOES_NOT_CONTAIN:** Matches if the concatenation of request URL path and query does not contain the contents of the `value` field.
        * **URL_PART_DOES_NOT_END_WITH:** Matches if the concatenation of request URL path and query does not end with the contents of the `value` field.
        * **IP_IS:** Matches if the request originates from one of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
        * **IP_IS_NOT:** Matches if the request does not originate from any of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
        * **IP_IN_LIST:** Matches if the request originates from one of the IP addresses contained in the referenced address list. The `value` in this case is OCID of the address list.
        * **IP_NOT_IN_LIST:** Matches if the request does not originate from any IP address contained in the referenced address list. The `value` field in this case is OCID of the address list.
        * **HTTP_HEADER_CONTAINS:** The HTTP_HEADER_CONTAINS criteria is defined using a compound value separated by a colon: a header field name and a header field value. `host:test.example.com` is an example of a criteria value where `host` is the header field name and `test.example.com` is the header field value. A request matches when the header field name is a case insensitive match and the header field value is a case insensitive, substring match. *Example:* With a criteria value of `host:test.example.com`, where `host` is the name of the field and `test.example.com` is the value of the host field, a request with the header values, `Host: www.test.example.com` will match, where as a request with header values of `host: www.example.com` or `host: test.sub.example.com` will not match.
        * **HTTP_METHOD_IS:** Matches if the request method is identical to one of the values listed in field. The `value` in this case is string with one or multiple HTTP methods separated by new line symbol \n The list of available methods: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigCaptchaArgs:
    def __init__(__self__, *,
                 failure_message: pulumi.Input[str],
                 session_expiration_in_seconds: pulumi.Input[int],
                 submit_label: pulumi.Input[str],
                 title: pulumi.Input[str],
                 url: pulumi.Input[str],
                 footer_text: Optional[pulumi.Input[str]] = None,
                 header_text: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] failure_message: (Updatable) The text to show when incorrect CAPTCHA text is entered. If unspecified, defaults to `The CAPTCHA was incorrect. Try again.`
        :param pulumi.Input[int] session_expiration_in_seconds: (Updatable) The amount of time before the CAPTCHA expires, in seconds. If unspecified, defaults to `300`.
        :param pulumi.Input[str] submit_label: (Updatable) The text to show on the label of the CAPTCHA challenge submit button. If unspecified, defaults to `Yes, I am human`.
        :param pulumi.Input[str] title: (Updatable) The title used when displaying a CAPTCHA challenge. If unspecified, defaults to `Are you human?`
        :param pulumi.Input[str] url: (Updatable) The unique URL path at which to show the CAPTCHA challenge.
        :param pulumi.Input[str] footer_text: (Updatable) The text to show in the footer when showing a CAPTCHA challenge. If unspecified, defaults to 'Enter the letters and numbers as they are shown in the image above.'
        :param pulumi.Input[str] header_text: (Updatable) The text to show in the header when showing a CAPTCHA challenge. If unspecified, defaults to 'We have detected an increased number of attempts to access this website. To help us keep this site secure, please let us know that you are not a robot by entering the text from the image below.'
        """
        pulumi.set(__self__, "failure_message", failure_message)
        pulumi.set(__self__, "session_expiration_in_seconds", session_expiration_in_seconds)
        pulumi.set(__self__, "submit_label", submit_label)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "url", url)
        if footer_text is not None:
            pulumi.set(__self__, "footer_text", footer_text)
        if header_text is not None:
            pulumi.set(__self__, "header_text", header_text)

    @property
    @pulumi.getter(name="failureMessage")
    def failure_message(self) -> pulumi.Input[str]:
        """
        (Updatable) The text to show when incorrect CAPTCHA text is entered. If unspecified, defaults to `The CAPTCHA was incorrect. Try again.`
        """
        return pulumi.get(self, "failure_message")

    @failure_message.setter
    def failure_message(self, value: pulumi.Input[str]):
        pulumi.set(self, "failure_message", value)

    @property
    @pulumi.getter(name="sessionExpirationInSeconds")
    def session_expiration_in_seconds(self) -> pulumi.Input[int]:
        """
        (Updatable) The amount of time before the CAPTCHA expires, in seconds. If unspecified, defaults to `300`.
        """
        return pulumi.get(self, "session_expiration_in_seconds")

    @session_expiration_in_seconds.setter
    def session_expiration_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "session_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="submitLabel")
    def submit_label(self) -> pulumi.Input[str]:
        """
        (Updatable) The text to show on the label of the CAPTCHA challenge submit button. If unspecified, defaults to `Yes, I am human`.
        """
        return pulumi.get(self, "submit_label")

    @submit_label.setter
    def submit_label(self, value: pulumi.Input[str]):
        pulumi.set(self, "submit_label", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        (Updatable) The title used when displaying a CAPTCHA challenge. If unspecified, defaults to `Are you human?`
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        (Updatable) The unique URL path at which to show the CAPTCHA challenge.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="footerText")
    def footer_text(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the footer when showing a CAPTCHA challenge. If unspecified, defaults to 'Enter the letters and numbers as they are shown in the image above.'
        """
        return pulumi.get(self, "footer_text")

    @footer_text.setter
    def footer_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "footer_text", value)

    @property
    @pulumi.getter(name="headerText")
    def header_text(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the header when showing a CAPTCHA challenge. If unspecified, defaults to 'We have detected an increased number of attempts to access this website. To help us keep this site secure, please let us know that you are not a robot by entering the text from the image below.'
        """
        return pulumi.get(self, "header_text")

    @header_text.setter
    def header_text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "header_text", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigCustomProtectionRuleArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input[str]] = None,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleExclusionArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleExclusionArgs']]] exclusions: (Updatable) An array of The target property of a request that would allow it to bypass the protection rule. For example, when `target` is `REQUEST_COOKIE_NAMES`, the list may include names of cookies to exclude from the protection rule. When the target is `ARGS`, the list may include strings of URL query parameters and values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from the protection rule. `Exclusions` properties must not contain whitespace, comma or |. **Note:** If protection rules have been enabled that utilize the `maxArgumentCount` or `maxTotalNameLengthOfArguments` properties, and the `target` property has been set to `ARGS`, it is important that the `exclusions` properties be defined to honor those protection rule settings in a consistent manner.
        :param pulumi.Input[str] id: (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the custom protection rule.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleExclusionArgs']]]]:
        """
        (Updatable) An array of The target property of a request that would allow it to bypass the protection rule. For example, when `target` is `REQUEST_COOKIE_NAMES`, the list may include names of cookies to exclude from the protection rule. When the target is `ARGS`, the list may include strings of URL query parameters and values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from the protection rule. `Exclusions` properties must not contain whitespace, comma or |. **Note:** If protection rules have been enabled that utilize the `maxArgumentCount` or `maxTotalNameLengthOfArguments` properties, and the `target` property has been set to `ARGS`, it is important that the `exclusions` properties be defined to honor those protection rule settings in a consistent manner.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigCustomProtectionRuleExclusionArgs']]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the custom protection rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigCustomProtectionRuleExclusionArgs:
    def __init__(__self__, *,
                 exclusions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusions: (Updatable) An array of The target property of a request that would allow it to bypass the protection rule. For example, when `target` is `REQUEST_COOKIE_NAMES`, the list may include names of cookies to exclude from the protection rule. When the target is `ARGS`, the list may include strings of URL query parameters and values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from the protection rule. `Exclusions` properties must not contain whitespace, comma or |. **Note:** If protection rules have been enabled that utilize the `maxArgumentCount` or `maxTotalNameLengthOfArguments` properties, and the `target` property has been set to `ARGS`, it is important that the `exclusions` properties be defined to honor those protection rule settings in a consistent manner.
        :param pulumi.Input[str] target: (Updatable) The target of the exclusion.
        """
        if exclusions is not None:
            pulumi.set(__self__, "exclusions", exclusions)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) An array of The target property of a request that would allow it to bypass the protection rule. For example, when `target` is `REQUEST_COOKIE_NAMES`, the list may include names of cookies to exclude from the protection rule. When the target is `ARGS`, the list may include strings of URL query parameters and values from form-urlencoded XML, JSON, AMP, or POST payloads to exclude from the protection rule. `Exclusions` properties must not contain whitespace, comma or |. **Note:** If protection rules have been enabled that utilize the `maxArgumentCount` or `maxTotalNameLengthOfArguments` properties, and the `target` property has been set to `ARGS`, it is important that the `exclusions` properties be defined to honor those protection rule settings in a consistent manner.
        """
        return pulumi.get(self, "exclusions")

    @exclusions.setter
    def exclusions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusions", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The target of the exclusion.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigDeviceFingerprintChallengeArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 action: Optional[pulumi.Input[str]] = None,
                 action_expiration_in_seconds: Optional[pulumi.Input[int]] = None,
                 challenge_settings: Optional[pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeChallengeSettingsArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 failure_threshold_expiration_in_seconds: Optional[pulumi.Input[int]] = None,
                 max_address_count: Optional[pulumi.Input[int]] = None,
                 max_address_count_expiration_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        :param pulumi.Input[str] action: (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        :param pulumi.Input[int] action_expiration_in_seconds: (Updatable) The number of seconds between challenges from the same IP address. If unspecified, defaults to `60`.
        :param pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeChallengeSettingsArgs'] challenge_settings: (Updatable) The challenge settings if `action` is set to `BLOCK`.
        :param pulumi.Input[int] failure_threshold: (Updatable) The number of failed requests before taking action. If unspecified, defaults to `10`.
        :param pulumi.Input[int] failure_threshold_expiration_in_seconds: (Updatable) The number of seconds before the failure threshold resets. If unspecified, defaults to  `60`.
        :param pulumi.Input[int] max_address_count: (Updatable) The maximum number of IP addresses permitted with the same device fingerprint. If unspecified, defaults to `20`.
        :param pulumi.Input[int] max_address_count_expiration_in_seconds: (Updatable) The number of seconds before the maximum addresses count resets. If unspecified, defaults to `60`.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_expiration_in_seconds is not None:
            pulumi.set(__self__, "action_expiration_in_seconds", action_expiration_in_seconds)
        if challenge_settings is not None:
            pulumi.set(__self__, "challenge_settings", challenge_settings)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if failure_threshold_expiration_in_seconds is not None:
            pulumi.set(__self__, "failure_threshold_expiration_in_seconds", failure_threshold_expiration_in_seconds)
        if max_address_count is not None:
            pulumi.set(__self__, "max_address_count", max_address_count)
        if max_address_count_expiration_in_seconds is not None:
            pulumi.set(__self__, "max_address_count_expiration_in_seconds", max_address_count_expiration_in_seconds)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="actionExpirationInSeconds")
    def action_expiration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds between challenges from the same IP address. If unspecified, defaults to `60`.
        """
        return pulumi.get(self, "action_expiration_in_seconds")

    @action_expiration_in_seconds.setter
    def action_expiration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "action_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="challengeSettings")
    def challenge_settings(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeChallengeSettingsArgs']]:
        """
        (Updatable) The challenge settings if `action` is set to `BLOCK`.
        """
        return pulumi.get(self, "challenge_settings")

    @challenge_settings.setter
    def challenge_settings(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigDeviceFingerprintChallengeChallengeSettingsArgs']]):
        pulumi.set(self, "challenge_settings", value)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of failed requests before taking action. If unspecified, defaults to `10`.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="failureThresholdExpirationInSeconds")
    def failure_threshold_expiration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds before the failure threshold resets. If unspecified, defaults to  `60`.
        """
        return pulumi.get(self, "failure_threshold_expiration_in_seconds")

    @failure_threshold_expiration_in_seconds.setter
    def failure_threshold_expiration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="maxAddressCount")
    def max_address_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum number of IP addresses permitted with the same device fingerprint. If unspecified, defaults to `20`.
        """
        return pulumi.get(self, "max_address_count")

    @max_address_count.setter
    def max_address_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_address_count", value)

    @property
    @pulumi.getter(name="maxAddressCountExpirationInSeconds")
    def max_address_count_expiration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds before the maximum addresses count resets. If unspecified, defaults to `60`.
        """
        return pulumi.get(self, "max_address_count_expiration_in_seconds")

    @max_address_count_expiration_in_seconds.setter
    def max_address_count_expiration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_address_count_expiration_in_seconds", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigDeviceFingerprintChallengeChallengeSettingsArgs:
    def __init__(__self__, *,
                 block_action: Optional[pulumi.Input[str]] = None,
                 block_error_page_code: Optional[pulumi.Input[str]] = None,
                 block_error_page_description: Optional[pulumi.Input[str]] = None,
                 block_error_page_message: Optional[pulumi.Input[str]] = None,
                 block_response_code: Optional[pulumi.Input[int]] = None,
                 captcha_footer: Optional[pulumi.Input[str]] = None,
                 captcha_header: Optional[pulumi.Input[str]] = None,
                 captcha_submit_label: Optional[pulumi.Input[str]] = None,
                 captcha_title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] block_action: (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        :param pulumi.Input[str] block_error_page_code: (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        :param pulumi.Input[str] block_error_page_description: (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        :param pulumi.Input[str] block_error_page_message: (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        :param pulumi.Input[int] block_response_code: (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        :param pulumi.Input[str] captcha_footer: (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        :param pulumi.Input[str] captcha_header: (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        :param pulumi.Input[str] captcha_submit_label: (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        :param pulumi.Input[str] captcha_title: (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        """
        if block_action is not None:
            pulumi.set(__self__, "block_action", block_action)
        if block_error_page_code is not None:
            pulumi.set(__self__, "block_error_page_code", block_error_page_code)
        if block_error_page_description is not None:
            pulumi.set(__self__, "block_error_page_description", block_error_page_description)
        if block_error_page_message is not None:
            pulumi.set(__self__, "block_error_page_message", block_error_page_message)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if captcha_footer is not None:
            pulumi.set(__self__, "captcha_footer", captcha_footer)
        if captcha_header is not None:
            pulumi.set(__self__, "captcha_header", captcha_header)
        if captcha_submit_label is not None:
            pulumi.set(__self__, "captcha_submit_label", captcha_submit_label)
        if captcha_title is not None:
            pulumi.set(__self__, "captcha_title", captcha_title)

    @property
    @pulumi.getter(name="blockAction")
    def block_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        """
        return pulumi.get(self, "block_action")

    @block_action.setter
    def block_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_action", value)

    @property
    @pulumi.getter(name="blockErrorPageCode")
    def block_error_page_code(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        """
        return pulumi.get(self, "block_error_page_code")

    @block_error_page_code.setter
    def block_error_page_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_code", value)

    @property
    @pulumi.getter(name="blockErrorPageDescription")
    def block_error_page_description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        """
        return pulumi.get(self, "block_error_page_description")

    @block_error_page_description.setter
    def block_error_page_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_description", value)

    @property
    @pulumi.getter(name="blockErrorPageMessage")
    def block_error_page_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        """
        return pulumi.get(self, "block_error_page_message")

    @block_error_page_message.setter
    def block_error_page_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_message", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="captchaFooter")
    def captcha_footer(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        """
        return pulumi.get(self, "captcha_footer")

    @captcha_footer.setter
    def captcha_footer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_footer", value)

    @property
    @pulumi.getter(name="captchaHeader")
    def captcha_header(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        """
        return pulumi.get(self, "captcha_header")

    @captcha_header.setter
    def captcha_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_header", value)

    @property
    @pulumi.getter(name="captchaSubmitLabel")
    def captcha_submit_label(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        """
        return pulumi.get(self, "captcha_submit_label")

    @captcha_submit_label.setter
    def captcha_submit_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_submit_label", value)

    @property
    @pulumi.getter(name="captchaTitle")
    def captcha_title(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        """
        return pulumi.get(self, "captcha_title")

    @captcha_title.setter
    def captcha_title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_title", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigHumanInteractionChallengeArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 action: Optional[pulumi.Input[str]] = None,
                 action_expiration_in_seconds: Optional[pulumi.Input[int]] = None,
                 challenge_settings: Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeChallengeSettingsArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 failure_threshold_expiration_in_seconds: Optional[pulumi.Input[int]] = None,
                 interaction_threshold: Optional[pulumi.Input[int]] = None,
                 is_nat_enabled: Optional[pulumi.Input[bool]] = None,
                 recording_period_in_seconds: Optional[pulumi.Input[int]] = None,
                 set_http_header: Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeSetHttpHeaderArgs']] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        :param pulumi.Input[str] action: (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        :param pulumi.Input[int] action_expiration_in_seconds: (Updatable) The number of seconds between challenges from the same IP address. If unspecified, defaults to `60`.
        :param pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeChallengeSettingsArgs'] challenge_settings: (Updatable) The challenge settings if `action` is set to `BLOCK`.
        :param pulumi.Input[int] failure_threshold: (Updatable) The number of failed requests before taking action. If unspecified, defaults to `10`.
        :param pulumi.Input[int] failure_threshold_expiration_in_seconds: (Updatable) The number of seconds before the failure threshold resets. If unspecified, defaults to  `60`.
        :param pulumi.Input[int] interaction_threshold: (Updatable) The number of interactions required to pass the challenge. If unspecified, defaults to `3`.
        :param pulumi.Input[bool] is_nat_enabled: (Updatable) When enabled, the user is identified not only by the IP address but also by an unique additional hash, which prevents blocking visitors with shared IP addresses.
        :param pulumi.Input[int] recording_period_in_seconds: (Updatable) The number of seconds to record the interactions from the user. If unspecified, defaults to `15`.
        :param pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeSetHttpHeaderArgs'] set_http_header: (Updatable) Adds an additional HTTP header to requests that fail the challenge before being passed to the origin. Only applicable when the `action` is set to `DETECT`.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_expiration_in_seconds is not None:
            pulumi.set(__self__, "action_expiration_in_seconds", action_expiration_in_seconds)
        if challenge_settings is not None:
            pulumi.set(__self__, "challenge_settings", challenge_settings)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if failure_threshold_expiration_in_seconds is not None:
            pulumi.set(__self__, "failure_threshold_expiration_in_seconds", failure_threshold_expiration_in_seconds)
        if interaction_threshold is not None:
            pulumi.set(__self__, "interaction_threshold", interaction_threshold)
        if is_nat_enabled is not None:
            pulumi.set(__self__, "is_nat_enabled", is_nat_enabled)
        if recording_period_in_seconds is not None:
            pulumi.set(__self__, "recording_period_in_seconds", recording_period_in_seconds)
        if set_http_header is not None:
            pulumi.set(__self__, "set_http_header", set_http_header)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="actionExpirationInSeconds")
    def action_expiration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds between challenges from the same IP address. If unspecified, defaults to `60`.
        """
        return pulumi.get(self, "action_expiration_in_seconds")

    @action_expiration_in_seconds.setter
    def action_expiration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "action_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="challengeSettings")
    def challenge_settings(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeChallengeSettingsArgs']]:
        """
        (Updatable) The challenge settings if `action` is set to `BLOCK`.
        """
        return pulumi.get(self, "challenge_settings")

    @challenge_settings.setter
    def challenge_settings(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeChallengeSettingsArgs']]):
        pulumi.set(self, "challenge_settings", value)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of failed requests before taking action. If unspecified, defaults to `10`.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="failureThresholdExpirationInSeconds")
    def failure_threshold_expiration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds before the failure threshold resets. If unspecified, defaults to  `60`.
        """
        return pulumi.get(self, "failure_threshold_expiration_in_seconds")

    @failure_threshold_expiration_in_seconds.setter
    def failure_threshold_expiration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="interactionThreshold")
    def interaction_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of interactions required to pass the challenge. If unspecified, defaults to `3`.
        """
        return pulumi.get(self, "interaction_threshold")

    @interaction_threshold.setter
    def interaction_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interaction_threshold", value)

    @property
    @pulumi.getter(name="isNatEnabled")
    def is_nat_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) When enabled, the user is identified not only by the IP address but also by an unique additional hash, which prevents blocking visitors with shared IP addresses.
        """
        return pulumi.get(self, "is_nat_enabled")

    @is_nat_enabled.setter
    def is_nat_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_nat_enabled", value)

    @property
    @pulumi.getter(name="recordingPeriodInSeconds")
    def recording_period_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds to record the interactions from the user. If unspecified, defaults to `15`.
        """
        return pulumi.get(self, "recording_period_in_seconds")

    @recording_period_in_seconds.setter
    def recording_period_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recording_period_in_seconds", value)

    @property
    @pulumi.getter(name="setHttpHeader")
    def set_http_header(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeSetHttpHeaderArgs']]:
        """
        (Updatable) Adds an additional HTTP header to requests that fail the challenge before being passed to the origin. Only applicable when the `action` is set to `DETECT`.
        """
        return pulumi.get(self, "set_http_header")

    @set_http_header.setter
    def set_http_header(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigHumanInteractionChallengeSetHttpHeaderArgs']]):
        pulumi.set(self, "set_http_header", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigHumanInteractionChallengeChallengeSettingsArgs:
    def __init__(__self__, *,
                 block_action: Optional[pulumi.Input[str]] = None,
                 block_error_page_code: Optional[pulumi.Input[str]] = None,
                 block_error_page_description: Optional[pulumi.Input[str]] = None,
                 block_error_page_message: Optional[pulumi.Input[str]] = None,
                 block_response_code: Optional[pulumi.Input[int]] = None,
                 captcha_footer: Optional[pulumi.Input[str]] = None,
                 captcha_header: Optional[pulumi.Input[str]] = None,
                 captcha_submit_label: Optional[pulumi.Input[str]] = None,
                 captcha_title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] block_action: (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        :param pulumi.Input[str] block_error_page_code: (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        :param pulumi.Input[str] block_error_page_description: (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        :param pulumi.Input[str] block_error_page_message: (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        :param pulumi.Input[int] block_response_code: (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        :param pulumi.Input[str] captcha_footer: (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        :param pulumi.Input[str] captcha_header: (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        :param pulumi.Input[str] captcha_submit_label: (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        :param pulumi.Input[str] captcha_title: (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        """
        if block_action is not None:
            pulumi.set(__self__, "block_action", block_action)
        if block_error_page_code is not None:
            pulumi.set(__self__, "block_error_page_code", block_error_page_code)
        if block_error_page_description is not None:
            pulumi.set(__self__, "block_error_page_description", block_error_page_description)
        if block_error_page_message is not None:
            pulumi.set(__self__, "block_error_page_message", block_error_page_message)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if captcha_footer is not None:
            pulumi.set(__self__, "captcha_footer", captcha_footer)
        if captcha_header is not None:
            pulumi.set(__self__, "captcha_header", captcha_header)
        if captcha_submit_label is not None:
            pulumi.set(__self__, "captcha_submit_label", captcha_submit_label)
        if captcha_title is not None:
            pulumi.set(__self__, "captcha_title", captcha_title)

    @property
    @pulumi.getter(name="blockAction")
    def block_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        """
        return pulumi.get(self, "block_action")

    @block_action.setter
    def block_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_action", value)

    @property
    @pulumi.getter(name="blockErrorPageCode")
    def block_error_page_code(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        """
        return pulumi.get(self, "block_error_page_code")

    @block_error_page_code.setter
    def block_error_page_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_code", value)

    @property
    @pulumi.getter(name="blockErrorPageDescription")
    def block_error_page_description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        """
        return pulumi.get(self, "block_error_page_description")

    @block_error_page_description.setter
    def block_error_page_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_description", value)

    @property
    @pulumi.getter(name="blockErrorPageMessage")
    def block_error_page_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        """
        return pulumi.get(self, "block_error_page_message")

    @block_error_page_message.setter
    def block_error_page_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_message", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="captchaFooter")
    def captcha_footer(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        """
        return pulumi.get(self, "captcha_footer")

    @captcha_footer.setter
    def captcha_footer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_footer", value)

    @property
    @pulumi.getter(name="captchaHeader")
    def captcha_header(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        """
        return pulumi.get(self, "captcha_header")

    @captcha_header.setter
    def captcha_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_header", value)

    @property
    @pulumi.getter(name="captchaSubmitLabel")
    def captcha_submit_label(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        """
        return pulumi.get(self, "captcha_submit_label")

    @captcha_submit_label.setter
    def captcha_submit_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_submit_label", value)

    @property
    @pulumi.getter(name="captchaTitle")
    def captcha_title(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        """
        return pulumi.get(self, "captcha_title")

    @captcha_title.setter
    def captcha_title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_title", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigHumanInteractionChallengeSetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) The unique name of the whitelist.
        :param pulumi.Input[str] value: (Updatable) The value of the header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigJsChallengeArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool],
                 action: Optional[pulumi.Input[str]] = None,
                 action_expiration_in_seconds: Optional[pulumi.Input[int]] = None,
                 are_redirects_challenged: Optional[pulumi.Input[bool]] = None,
                 challenge_settings: Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeChallengeSettingsArgs']] = None,
                 criterias: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeCriteriaArgs']]]] = None,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 is_nat_enabled: Optional[pulumi.Input[bool]] = None,
                 set_http_header: Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeSetHttpHeaderArgs']] = None):
        """
        :param pulumi.Input[bool] is_enabled: (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        :param pulumi.Input[str] action: (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        :param pulumi.Input[int] action_expiration_in_seconds: (Updatable) The number of seconds between challenges from the same IP address. If unspecified, defaults to `60`.
        :param pulumi.Input[bool] are_redirects_challenged: (Updatable) When enabled, redirect responses from the origin will also be challenged. This will change HTTP 301/302 responses from origin to HTTP 200 with an HTML body containing JavaScript page redirection.
        :param pulumi.Input['WaasWaasPolicyWafConfigJsChallengeChallengeSettingsArgs'] challenge_settings: (Updatable) The challenge settings if `action` is set to `BLOCK`.
        :param pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeCriteriaArgs']]] criterias: (Updatable) When defined, the JavaScript Challenge would be applied only for the requests that matched all the listed conditions.
        :param pulumi.Input[int] failure_threshold: (Updatable) The number of failed requests before taking action. If unspecified, defaults to `10`.
        :param pulumi.Input[bool] is_nat_enabled: (Updatable) When enabled, the user is identified not only by the IP address but also by an unique additional hash, which prevents blocking visitors with shared IP addresses.
        :param pulumi.Input['WaasWaasPolicyWafConfigJsChallengeSetHttpHeaderArgs'] set_http_header: (Updatable) Adds an additional HTTP header to requests that fail the challenge before being passed to the origin. Only applicable when the `action` is set to `DETECT`.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if action_expiration_in_seconds is not None:
            pulumi.set(__self__, "action_expiration_in_seconds", action_expiration_in_seconds)
        if are_redirects_challenged is not None:
            pulumi.set(__self__, "are_redirects_challenged", are_redirects_challenged)
        if challenge_settings is not None:
            pulumi.set(__self__, "challenge_settings", challenge_settings)
        if criterias is not None:
            pulumi.set(__self__, "criterias", criterias)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if is_nat_enabled is not None:
            pulumi.set(__self__, "is_nat_enabled", is_nat_enabled)
        if set_http_header is not None:
            pulumi.set(__self__, "set_http_header", set_http_header)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        (Updatable) Enables or disables the JavaScript challenge Web Application Firewall feature.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The action to take against requests from detected bots. If unspecified, defaults to `DETECT`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="actionExpirationInSeconds")
    def action_expiration_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of seconds between challenges from the same IP address. If unspecified, defaults to `60`.
        """
        return pulumi.get(self, "action_expiration_in_seconds")

    @action_expiration_in_seconds.setter
    def action_expiration_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "action_expiration_in_seconds", value)

    @property
    @pulumi.getter(name="areRedirectsChallenged")
    def are_redirects_challenged(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) When enabled, redirect responses from the origin will also be challenged. This will change HTTP 301/302 responses from origin to HTTP 200 with an HTML body containing JavaScript page redirection.
        """
        return pulumi.get(self, "are_redirects_challenged")

    @are_redirects_challenged.setter
    def are_redirects_challenged(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "are_redirects_challenged", value)

    @property
    @pulumi.getter(name="challengeSettings")
    def challenge_settings(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeChallengeSettingsArgs']]:
        """
        (Updatable) The challenge settings if `action` is set to `BLOCK`.
        """
        return pulumi.get(self, "challenge_settings")

    @challenge_settings.setter
    def challenge_settings(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeChallengeSettingsArgs']]):
        pulumi.set(self, "challenge_settings", value)

    @property
    @pulumi.getter
    def criterias(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeCriteriaArgs']]]]:
        """
        (Updatable) When defined, the JavaScript Challenge would be applied only for the requests that matched all the listed conditions.
        """
        return pulumi.get(self, "criterias")

    @criterias.setter
    def criterias(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeCriteriaArgs']]]]):
        pulumi.set(self, "criterias", value)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The number of failed requests before taking action. If unspecified, defaults to `10`.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="isNatEnabled")
    def is_nat_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) When enabled, the user is identified not only by the IP address but also by an unique additional hash, which prevents blocking visitors with shared IP addresses.
        """
        return pulumi.get(self, "is_nat_enabled")

    @is_nat_enabled.setter
    def is_nat_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_nat_enabled", value)

    @property
    @pulumi.getter(name="setHttpHeader")
    def set_http_header(self) -> Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeSetHttpHeaderArgs']]:
        """
        (Updatable) Adds an additional HTTP header to requests that fail the challenge before being passed to the origin. Only applicable when the `action` is set to `DETECT`.
        """
        return pulumi.get(self, "set_http_header")

    @set_http_header.setter
    def set_http_header(self, value: Optional[pulumi.Input['WaasWaasPolicyWafConfigJsChallengeSetHttpHeaderArgs']]):
        pulumi.set(self, "set_http_header", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigJsChallengeChallengeSettingsArgs:
    def __init__(__self__, *,
                 block_action: Optional[pulumi.Input[str]] = None,
                 block_error_page_code: Optional[pulumi.Input[str]] = None,
                 block_error_page_description: Optional[pulumi.Input[str]] = None,
                 block_error_page_message: Optional[pulumi.Input[str]] = None,
                 block_response_code: Optional[pulumi.Input[int]] = None,
                 captcha_footer: Optional[pulumi.Input[str]] = None,
                 captcha_header: Optional[pulumi.Input[str]] = None,
                 captcha_submit_label: Optional[pulumi.Input[str]] = None,
                 captcha_title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] block_action: (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        :param pulumi.Input[str] block_error_page_code: (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        :param pulumi.Input[str] block_error_page_description: (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        :param pulumi.Input[str] block_error_page_message: (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        :param pulumi.Input[int] block_response_code: (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        :param pulumi.Input[str] captcha_footer: (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        :param pulumi.Input[str] captcha_header: (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        :param pulumi.Input[str] captcha_submit_label: (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        :param pulumi.Input[str] captcha_title: (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        """
        if block_action is not None:
            pulumi.set(__self__, "block_action", block_action)
        if block_error_page_code is not None:
            pulumi.set(__self__, "block_error_page_code", block_error_page_code)
        if block_error_page_description is not None:
            pulumi.set(__self__, "block_error_page_description", block_error_page_description)
        if block_error_page_message is not None:
            pulumi.set(__self__, "block_error_page_message", block_error_page_message)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if captcha_footer is not None:
            pulumi.set(__self__, "captcha_footer", captcha_footer)
        if captcha_header is not None:
            pulumi.set(__self__, "captcha_header", captcha_header)
        if captcha_submit_label is not None:
            pulumi.set(__self__, "captcha_submit_label", captcha_submit_label)
        if captcha_title is not None:
            pulumi.set(__self__, "captcha_title", captcha_title)

    @property
    @pulumi.getter(name="blockAction")
    def block_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        """
        return pulumi.get(self, "block_action")

    @block_action.setter
    def block_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_action", value)

    @property
    @pulumi.getter(name="blockErrorPageCode")
    def block_error_page_code(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        """
        return pulumi.get(self, "block_error_page_code")

    @block_error_page_code.setter
    def block_error_page_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_code", value)

    @property
    @pulumi.getter(name="blockErrorPageDescription")
    def block_error_page_description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        """
        return pulumi.get(self, "block_error_page_description")

    @block_error_page_description.setter
    def block_error_page_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_description", value)

    @property
    @pulumi.getter(name="blockErrorPageMessage")
    def block_error_page_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        """
        return pulumi.get(self, "block_error_page_message")

    @block_error_page_message.setter
    def block_error_page_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_message", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="captchaFooter")
    def captcha_footer(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the footer when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, default to `Enter the letters and numbers as they are shown in image above`.
        """
        return pulumi.get(self, "captcha_footer")

    @captcha_footer.setter
    def captcha_footer(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_footer", value)

    @property
    @pulumi.getter(name="captchaHeader")
    def captcha_header(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show in the header when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `We have detected an increased number of attempts to access this webapp. To help us keep this webapp secure, please let us know that you are not a robot by entering the text from captcha below.`
        """
        return pulumi.get(self, "captcha_header")

    @captcha_header.setter
    def captcha_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_header", value)

    @property
    @pulumi.getter(name="captchaSubmitLabel")
    def captcha_submit_label(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The text to show on the label of the CAPTCHA challenge submit button when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Yes, I am human`.
        """
        return pulumi.get(self, "captcha_submit_label")

    @captcha_submit_label.setter
    def captcha_submit_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_submit_label", value)

    @property
    @pulumi.getter(name="captchaTitle")
    def captcha_title(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The title used when showing a CAPTCHA challenge when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_CAPTCHA`, and the request is blocked. If unspecified, defaults to `Are you human?`
        """
        return pulumi.get(self, "captcha_title")

    @captcha_title.setter
    def captcha_title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "captcha_title", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigJsChallengeCriteriaArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 value: pulumi.Input[str],
                 is_case_sensitive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] condition: (Updatable) The criteria the access rule and JavaScript Challenge uses to determine if action should be taken on a request.
               * **URL_IS:** Matches if the concatenation of request URL path and query is identical to the contents of the `value` field. URL must start with a `/`.
               * **URL_IS_NOT:** Matches if the concatenation of request URL path and query is not identical to the contents of the `value` field. URL must start with a `/`.
               * **URL_STARTS_WITH:** Matches if the concatenation of request URL path and query starts with the contents of the `value` field. URL must start with a `/`.
               * **URL_PART_ENDS_WITH:** Matches if the concatenation of request URL path and query ends with the contents of the `value` field.
               * **URL_PART_CONTAINS:** Matches if the concatenation of request URL path and query contains the contents of the `value` field.
               * **URL_REGEX:** Matches if the concatenation of request URL path and query is described by the regular expression in the value field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
               * **URL_DOES_NOT_MATCH_REGEX:** Matches if the concatenation of request URL path and query is not described by the regular expression in the `value` field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
               * **URL_DOES_NOT_START_WITH:** Matches if the concatenation of request URL path and query does not start with the contents of the `value` field.
               * **URL_PART_DOES_NOT_CONTAIN:** Matches if the concatenation of request URL path and query does not contain the contents of the `value` field.
               * **URL_PART_DOES_NOT_END_WITH:** Matches if the concatenation of request URL path and query does not end with the contents of the `value` field.
               * **IP_IS:** Matches if the request originates from one of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
               * **IP_IS_NOT:** Matches if the request does not originate from any of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
               * **IP_IN_LIST:** Matches if the request originates from one of the IP addresses contained in the referenced address list. The `value` in this case is OCID of the address list.
               * **IP_NOT_IN_LIST:** Matches if the request does not originate from any IP address contained in the referenced address list. The `value` field in this case is OCID of the address list.
               * **HTTP_HEADER_CONTAINS:** The HTTP_HEADER_CONTAINS criteria is defined using a compound value separated by a colon: a header field name and a header field value. `host:test.example.com` is an example of a criteria value where `host` is the header field name and `test.example.com` is the header field value. A request matches when the header field name is a case insensitive match and the header field value is a case insensitive, substring match. *Example:* With a criteria value of `host:test.example.com`, where `host` is the name of the field and `test.example.com` is the value of the host field, a request with the header values, `Host: www.test.example.com` will match, where as a request with header values of `host: www.example.com` or `host: test.sub.example.com` will not match.
               * **HTTP_METHOD_IS:** Matches if the request method is identical to one of the values listed in field. The `value` in this case is string with one or multiple HTTP methods separated by new line symbol \n The list of available methods: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`
        :param pulumi.Input[str] value: (Updatable) The value of the header.
        :param pulumi.Input[bool] is_case_sensitive: (Updatable) When enabled, the condition will be matched with case-sensitive rules.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "value", value)
        if is_case_sensitive is not None:
            pulumi.set(__self__, "is_case_sensitive", is_case_sensitive)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        (Updatable) The criteria the access rule and JavaScript Challenge uses to determine if action should be taken on a request.
        * **URL_IS:** Matches if the concatenation of request URL path and query is identical to the contents of the `value` field. URL must start with a `/`.
        * **URL_IS_NOT:** Matches if the concatenation of request URL path and query is not identical to the contents of the `value` field. URL must start with a `/`.
        * **URL_STARTS_WITH:** Matches if the concatenation of request URL path and query starts with the contents of the `value` field. URL must start with a `/`.
        * **URL_PART_ENDS_WITH:** Matches if the concatenation of request URL path and query ends with the contents of the `value` field.
        * **URL_PART_CONTAINS:** Matches if the concatenation of request URL path and query contains the contents of the `value` field.
        * **URL_REGEX:** Matches if the concatenation of request URL path and query is described by the regular expression in the value field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
        * **URL_DOES_NOT_MATCH_REGEX:** Matches if the concatenation of request URL path and query is not described by the regular expression in the `value` field. The value must be a valid regular expression recognized by the PCRE library in Nginx (https://www.pcre.org).
        * **URL_DOES_NOT_START_WITH:** Matches if the concatenation of request URL path and query does not start with the contents of the `value` field.
        * **URL_PART_DOES_NOT_CONTAIN:** Matches if the concatenation of request URL path and query does not contain the contents of the `value` field.
        * **URL_PART_DOES_NOT_END_WITH:** Matches if the concatenation of request URL path and query does not end with the contents of the `value` field.
        * **IP_IS:** Matches if the request originates from one of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
        * **IP_IS_NOT:** Matches if the request does not originate from any of the IP addresses contained in the defined address list. The `value` in this case is string with one or multiple IPs or CIDR notations separated by new line symbol \n *Example:* "1.1.1.1\n1.1.1.2\n1.2.2.1/30"
        * **IP_IN_LIST:** Matches if the request originates from one of the IP addresses contained in the referenced address list. The `value` in this case is OCID of the address list.
        * **IP_NOT_IN_LIST:** Matches if the request does not originate from any IP address contained in the referenced address list. The `value` field in this case is OCID of the address list.
        * **HTTP_HEADER_CONTAINS:** The HTTP_HEADER_CONTAINS criteria is defined using a compound value separated by a colon: a header field name and a header field value. `host:test.example.com` is an example of a criteria value where `host` is the header field name and `test.example.com` is the header field value. A request matches when the header field name is a case insensitive match and the header field value is a case insensitive, substring match. *Example:* With a criteria value of `host:test.example.com`, where `host` is the name of the field and `test.example.com` is the value of the host field, a request with the header values, `Host: www.test.example.com` will match, where as a request with header values of `host: www.example.com` or `host: test.sub.example.com` will not match.
        * **HTTP_METHOD_IS:** Matches if the request method is identical to one of the values listed in field. The `value` in this case is string with one or multiple HTTP methods separated by new line symbol \n The list of available methods: `GET`, `HEAD`, `POST`, `PUT`, `DELETE`, `CONNECT`, `OPTIONS`, `TRACE`, `PATCH`
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="isCaseSensitive")
    def is_case_sensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) When enabled, the condition will be matched with case-sensitive rules.
        """
        return pulumi.get(self, "is_case_sensitive")

    @is_case_sensitive.setter
    def is_case_sensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_case_sensitive", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigJsChallengeSetHttpHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: (Updatable) The unique name of the whitelist.
        :param pulumi.Input[str] value: (Updatable) The value of the header.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        (Updatable) The value of the header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigProtectionSettingsArgs:
    def __init__(__self__, *,
                 allowed_http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 block_action: Optional[pulumi.Input[str]] = None,
                 block_error_page_code: Optional[pulumi.Input[str]] = None,
                 block_error_page_description: Optional[pulumi.Input[str]] = None,
                 block_error_page_message: Optional[pulumi.Input[str]] = None,
                 block_response_code: Optional[pulumi.Input[int]] = None,
                 is_response_inspected: Optional[pulumi.Input[bool]] = None,
                 max_argument_count: Optional[pulumi.Input[int]] = None,
                 max_name_length_per_argument: Optional[pulumi.Input[int]] = None,
                 max_response_size_in_ki_b: Optional[pulumi.Input[int]] = None,
                 max_total_name_length_of_arguments: Optional[pulumi.Input[int]] = None,
                 media_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 recommendations_period_in_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_http_methods: (Updatable) The list of allowed HTTP methods. If unspecified, default to `[OPTIONS, GET, HEAD, POST]`. This setting only applies if a corresponding protection rule is enabled, such as the "Restrict HTTP Request Methods" rule (key: 911100).
        :param pulumi.Input[str] block_action: (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        :param pulumi.Input[str] block_error_page_code: (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        :param pulumi.Input[str] block_error_page_description: (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        :param pulumi.Input[str] block_error_page_message: (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        :param pulumi.Input[int] block_response_code: (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        :param pulumi.Input[bool] is_response_inspected: (Updatable) Inspects the response body of origin responses. Can be used to detect leakage of sensitive data. If unspecified, defaults to `false`.
        :param pulumi.Input[int] max_argument_count: (Updatable) The maximum number of arguments allowed to be passed to your application before an action is taken. Arguements are query parameters or body parameters in a PUT or POST request. If unspecified, defaults to `255`. This setting only applies if a corresponding protection rule is enabled, such as the "Number of Arguments Limits" rule (key: 960335).  Example: If `maxArgumentCount` to `2` for the Max Number of Arguments protection rule (key: 960335), the following requests would be blocked: `GET /myapp/path?query=one&query=two&query=three` `POST /myapp/path` with Body `{"argument1":"one","argument2":"two","argument3":"three"}`
        :param pulumi.Input[int] max_name_length_per_argument: (Updatable) The maximum length allowed for each argument name, in characters. Arguements are query parameters or body parameters in a PUT or POST request. If unspecified, defaults to `400`. This setting only applies if a corresponding protection rule is enabled, such as the "Values Limits" rule (key: 960208).
        :param pulumi.Input[int] max_response_size_in_ki_b: (Updatable) The maximum response size to be fully inspected, in binary kilobytes (KiB). Anything over this limit will be partially inspected. If unspecified, defaults to `1024`.
        :param pulumi.Input[int] max_total_name_length_of_arguments: (Updatable) The maximum length allowed for the sum of the argument name and value, in characters. Arguements are query parameters or body parameters in a PUT or POST request. If unspecified, defaults to `64000`. This setting only applies if a corresponding protection rule is enabled, such as the "Total Arguments Limits" rule (key: 960341).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] media_types: (Updatable) The list of media types to allow for inspection, if `isResponseInspected` is enabled. Only responses with MIME types in this list will be inspected. If unspecified, defaults to `["text/html", "text/plain", "text/xml"]`.
        :param pulumi.Input[int] recommendations_period_in_days: (Updatable) The length of time to analyze traffic traffic, in days. After the analysis period, `WafRecommendations` will be populated. If unspecified, defaults to `10`.
        """
        if allowed_http_methods is not None:
            pulumi.set(__self__, "allowed_http_methods", allowed_http_methods)
        if block_action is not None:
            pulumi.set(__self__, "block_action", block_action)
        if block_error_page_code is not None:
            pulumi.set(__self__, "block_error_page_code", block_error_page_code)
        if block_error_page_description is not None:
            pulumi.set(__self__, "block_error_page_description", block_error_page_description)
        if block_error_page_message is not None:
            pulumi.set(__self__, "block_error_page_message", block_error_page_message)
        if block_response_code is not None:
            pulumi.set(__self__, "block_response_code", block_response_code)
        if is_response_inspected is not None:
            pulumi.set(__self__, "is_response_inspected", is_response_inspected)
        if max_argument_count is not None:
            pulumi.set(__self__, "max_argument_count", max_argument_count)
        if max_name_length_per_argument is not None:
            pulumi.set(__self__, "max_name_length_per_argument", max_name_length_per_argument)
        if max_response_size_in_ki_b is not None:
            pulumi.set(__self__, "max_response_size_in_ki_b", max_response_size_in_ki_b)
        if max_total_name_length_of_arguments is not None:
            pulumi.set(__self__, "max_total_name_length_of_arguments", max_total_name_length_of_arguments)
        if media_types is not None:
            pulumi.set(__self__, "media_types", media_types)
        if recommendations_period_in_days is not None:
            pulumi.set(__self__, "recommendations_period_in_days", recommendations_period_in_days)

    @property
    @pulumi.getter(name="allowedHttpMethods")
    def allowed_http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of allowed HTTP methods. If unspecified, default to `[OPTIONS, GET, HEAD, POST]`. This setting only applies if a corresponding protection rule is enabled, such as the "Restrict HTTP Request Methods" rule (key: 911100).
        """
        return pulumi.get(self, "allowed_http_methods")

    @allowed_http_methods.setter
    def allowed_http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_http_methods", value)

    @property
    @pulumi.getter(name="blockAction")
    def block_action(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) If `action` is set to `BLOCK`, this specifies how the traffic is blocked when detected as malicious by a protection rule. If unspecified, defaults to `SET_RESPONSE_CODE`.
        """
        return pulumi.get(self, "block_action")

    @block_action.setter
    def block_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_action", value)

    @property
    @pulumi.getter(name="blockErrorPageCode")
    def block_error_page_code(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The error code to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`.
        """
        return pulumi.get(self, "block_error_page_code")

    @block_error_page_code.setter
    def block_error_page_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_code", value)

    @property
    @pulumi.getter(name="blockErrorPageDescription")
    def block_error_page_description(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The description text to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `Access blocked by website owner. Please contact support.`
        """
        return pulumi.get(self, "block_error_page_description")

    @block_error_page_description.setter
    def block_error_page_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_description", value)

    @property
    @pulumi.getter(name="blockErrorPageMessage")
    def block_error_page_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Updatable) The message to show on the error page when `action` is set to `BLOCK`, `blockAction` is set to `SHOW_ERROR_PAGE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to 'Access to the website is blocked.'
        """
        return pulumi.get(self, "block_error_page_message")

    @block_error_page_message.setter
    def block_error_page_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_error_page_message", value)

    @property
    @pulumi.getter(name="blockResponseCode")
    def block_response_code(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The response code returned when `action` is set to `BLOCK`, `blockAction` is set to `SET_RESPONSE_CODE`, and the traffic is detected as malicious by a protection rule. If unspecified, defaults to `403`. The list of available response codes: `400`, `401`, `403`, `405`, `409`, `411`, `412`, `413`, `414`, `415`, `416`, `500`, `501`, `502`, `503`, `504`, `507`.
        """
        return pulumi.get(self, "block_response_code")

    @block_response_code.setter
    def block_response_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "block_response_code", value)

    @property
    @pulumi.getter(name="isResponseInspected")
    def is_response_inspected(self) -> Optional[pulumi.Input[bool]]:
        """
        (Updatable) Inspects the response body of origin responses. Can be used to detect leakage of sensitive data. If unspecified, defaults to `false`.
        """
        return pulumi.get(self, "is_response_inspected")

    @is_response_inspected.setter
    def is_response_inspected(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_response_inspected", value)

    @property
    @pulumi.getter(name="maxArgumentCount")
    def max_argument_count(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum number of arguments allowed to be passed to your application before an action is taken. Arguements are query parameters or body parameters in a PUT or POST request. If unspecified, defaults to `255`. This setting only applies if a corresponding protection rule is enabled, such as the "Number of Arguments Limits" rule (key: 960335).  Example: If `maxArgumentCount` to `2` for the Max Number of Arguments protection rule (key: 960335), the following requests would be blocked: `GET /myapp/path?query=one&query=two&query=three` `POST /myapp/path` with Body `{"argument1":"one","argument2":"two","argument3":"three"}`
        """
        return pulumi.get(self, "max_argument_count")

    @max_argument_count.setter
    def max_argument_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_argument_count", value)

    @property
    @pulumi.getter(name="maxNameLengthPerArgument")
    def max_name_length_per_argument(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum length allowed for each argument name, in characters. Arguements are query parameters or body parameters in a PUT or POST request. If unspecified, defaults to `400`. This setting only applies if a corresponding protection rule is enabled, such as the "Values Limits" rule (key: 960208).
        """
        return pulumi.get(self, "max_name_length_per_argument")

    @max_name_length_per_argument.setter
    def max_name_length_per_argument(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_name_length_per_argument", value)

    @property
    @pulumi.getter(name="maxResponseSizeInKiB")
    def max_response_size_in_ki_b(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum response size to be fully inspected, in binary kilobytes (KiB). Anything over this limit will be partially inspected. If unspecified, defaults to `1024`.
        """
        return pulumi.get(self, "max_response_size_in_ki_b")

    @max_response_size_in_ki_b.setter
    def max_response_size_in_ki_b(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_response_size_in_ki_b", value)

    @property
    @pulumi.getter(name="maxTotalNameLengthOfArguments")
    def max_total_name_length_of_arguments(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The maximum length allowed for the sum of the argument name and value, in characters. Arguements are query parameters or body parameters in a PUT or POST request. If unspecified, defaults to `64000`. This setting only applies if a corresponding protection rule is enabled, such as the "Total Arguments Limits" rule (key: 960341).
        """
        return pulumi.get(self, "max_total_name_length_of_arguments")

    @max_total_name_length_of_arguments.setter
    def max_total_name_length_of_arguments(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_total_name_length_of_arguments", value)

    @property
    @pulumi.getter(name="mediaTypes")
    def media_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) The list of media types to allow for inspection, if `isResponseInspected` is enabled. Only responses with MIME types in this list will be inspected. If unspecified, defaults to `["text/html", "text/plain", "text/xml"]`.
        """
        return pulumi.get(self, "media_types")

    @media_types.setter
    def media_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "media_types", value)

    @property
    @pulumi.getter(name="recommendationsPeriodInDays")
    def recommendations_period_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        (Updatable) The length of time to analyze traffic traffic, in days. After the analysis period, `WafRecommendations` will be populated. If unspecified, defaults to `10`.
        """
        return pulumi.get(self, "recommendations_period_in_days")

    @recommendations_period_in_days.setter
    def recommendations_period_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recommendations_period_in_days", value)


@pulumi.input_type
class WaasWaasPolicyWafConfigWhitelistArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 address_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: (Updatable) The unique name of the whitelist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address_lists: (Updatable) A list of [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of IP address lists to include in the whitelist.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: (Updatable) A set of IP addresses or CIDR notations to include in the whitelist.
        """
        pulumi.set(__self__, "name", name)
        if address_lists is not None:
            pulumi.set(__self__, "address_lists", address_lists)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        (Updatable) The unique name of the whitelist.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="addressLists")
    def address_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A list of [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of IP address lists to include in the whitelist.
        """
        return pulumi.get(self, "address_lists")

    @address_lists.setter
    def address_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "address_lists", value)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Updatable) A set of IP addresses or CIDR notations to include in the whitelist.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addresses", value)


