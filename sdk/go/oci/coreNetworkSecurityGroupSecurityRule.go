// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package oci

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// This resource provides the Network Security Group Security Rule resource in Oracle Cloud Infrastructure Core service.
//
// Adds a security rule to the specified network security group.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-oci/sdk/go/oci"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := oci.NewCoreNetworkSecurityGroupSecurityRule(ctx, "testNetworkSecurityGroupSecurityRule", &oci.CoreNetworkSecurityGroupSecurityRuleArgs{
// 			NetworkSecurityGroupId: pulumi.Any(oci_core_network_security_group.Test_network_security_group.Id),
// 			Direction:              pulumi.Any(_var.Network_security_group_security_rule_direction),
// 			Protocol:               pulumi.Any(_var.Network_security_group_security_rule_protocol),
// 			Description:            pulumi.Any(_var.Network_security_group_security_rule_description),
// 			Destination:            pulumi.Any(_var.Network_security_group_security_rule_destination),
// 			DestinationType:        pulumi.Any(_var.Network_security_group_security_rule_destination_type),
// 			IcmpOptions: &CoreNetworkSecurityGroupSecurityRuleIcmpOptionsArgs{
// 				Type: pulumi.Any(_var.Network_security_group_security_rule_icmp_options_type),
// 				Code: pulumi.Any(_var.Network_security_group_security_rule_icmp_options_code),
// 			},
// 			Source:     pulumi.Any(_var.Network_security_group_security_rule_source),
// 			SourceType: pulumi.Any(_var.Network_security_group_security_rule_source_type),
// 			Stateless:  pulumi.Any(_var.Network_security_group_security_rule_stateless),
// 			TcpOptions: &CoreNetworkSecurityGroupSecurityRuleTcpOptionsArgs{
// 				DestinationPortRange: &CoreNetworkSecurityGroupSecurityRuleTcpOptionsDestinationPortRangeArgs{
// 					Max: pulumi.Any(_var.Network_security_group_security_rule_tcp_options_destination_port_range_max),
// 					Min: pulumi.Any(_var.Network_security_group_security_rule_tcp_options_destination_port_range_min),
// 				},
// 				SourcePortRange: &CoreNetworkSecurityGroupSecurityRuleTcpOptionsSourcePortRangeArgs{
// 					Max: pulumi.Any(_var.Network_security_group_security_rule_tcp_options_source_port_range_max),
// 					Min: pulumi.Any(_var.Network_security_group_security_rule_tcp_options_source_port_range_min),
// 				},
// 			},
// 			UdpOptions: &CoreNetworkSecurityGroupSecurityRuleUdpOptionsArgs{
// 				DestinationPortRange: &CoreNetworkSecurityGroupSecurityRuleUdpOptionsDestinationPortRangeArgs{
// 					Max: pulumi.Any(_var.Network_security_group_security_rule_udp_options_destination_port_range_max),
// 					Min: pulumi.Any(_var.Network_security_group_security_rule_udp_options_destination_port_range_min),
// 				},
// 				SourcePortRange: &CoreNetworkSecurityGroupSecurityRuleUdpOptionsSourcePortRangeArgs{
// 					Max: pulumi.Any(_var.Network_security_group_security_rule_udp_options_source_port_range_max),
// 					Min: pulumi.Any(_var.Network_security_group_security_rule_udp_options_source_port_range_min),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// NetworkSecurityGroupSecurityRule can be imported using the `id`, e.g.
//
// ```sh
//  $ pulumi import oci:index/coreNetworkSecurityGroupSecurityRule:CoreNetworkSecurityGroupSecurityRule test_network_security_group_security_rule "networkSecurityGroups/{networkSecurityGroupId}/securityRules/{securityRuleId}"
// ```
type CoreNetworkSecurityGroupSecurityRule struct {
	pulumi.CustomResourceState

	// An optional description of your choice for the rule. Avoid entering confidential information.
	Description pulumi.StringOutput `pulumi:"description"`
	// Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
	Destination pulumi.StringOutput `pulumi:"destination"`
	// Type of destination for the rule. Required if `direction` = `EGRESS`.
	DestinationType pulumi.StringOutput `pulumi:"destinationType"`
	// Direction of the security rule. Set to `EGRESS` for rules to allow outbound IP packets, or `INGRESS` for rules to allow inbound IP packets.
	Direction pulumi.StringOutput `pulumi:"direction"`
	// Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
	// * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
	// * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
	IcmpOptions CoreNetworkSecurityGroupSecurityRuleIcmpOptionsPtrOutput `pulumi:"icmpOptions"`
	// Whether the rule is valid. The value is `True` when the rule is first created. If the rule's `source` or `destination` is a network security group, the value changes to `False` if that network security group is deleted.
	IsValid pulumi.BoolOutput `pulumi:"isValid"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security group.
	NetworkSecurityGroupId pulumi.StringOutput `pulumi:"networkSecurityGroupId"`
	// The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
	Protocol pulumi.StringOutput `pulumi:"protocol"`
	// Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
	Source pulumi.StringPtrOutput `pulumi:"source"`
	// Type of source for the rule. Required if `direction` = `INGRESS`.
	// * `CIDR_BLOCK`: If the rule's `source` is an IP address range in CIDR notation.
	// * `SERVICE_CIDR_BLOCK`: If the rule's `source` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic coming from a particular `Service` through a service gateway).
	// * `NETWORK_SECURITY_GROUP`: If the rule's `source` is the OCID of a [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
	SourceType pulumi.StringOutput `pulumi:"sourceType"`
	// A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if egress traffic allows TCP destination port 80, there should be an ingress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
	Stateless pulumi.BoolOutput `pulumi:"stateless"`
	// Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
	TcpOptions CoreNetworkSecurityGroupSecurityRuleTcpOptionsPtrOutput `pulumi:"tcpOptions"`
	// The date and time the security rule was created. Format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
	TimeCreated pulumi.StringOutput `pulumi:"timeCreated"`
	// Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
	UdpOptions CoreNetworkSecurityGroupSecurityRuleUdpOptionsPtrOutput `pulumi:"udpOptions"`
}

// NewCoreNetworkSecurityGroupSecurityRule registers a new resource with the given unique name, arguments, and options.
func NewCoreNetworkSecurityGroupSecurityRule(ctx *pulumi.Context,
	name string, args *CoreNetworkSecurityGroupSecurityRuleArgs, opts ...pulumi.ResourceOption) (*CoreNetworkSecurityGroupSecurityRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Direction == nil {
		return nil, errors.New("invalid value for required argument 'Direction'")
	}
	if args.NetworkSecurityGroupId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkSecurityGroupId'")
	}
	if args.Protocol == nil {
		return nil, errors.New("invalid value for required argument 'Protocol'")
	}
	var resource CoreNetworkSecurityGroupSecurityRule
	err := ctx.RegisterResource("oci:index/coreNetworkSecurityGroupSecurityRule:CoreNetworkSecurityGroupSecurityRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCoreNetworkSecurityGroupSecurityRule gets an existing CoreNetworkSecurityGroupSecurityRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCoreNetworkSecurityGroupSecurityRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CoreNetworkSecurityGroupSecurityRuleState, opts ...pulumi.ResourceOption) (*CoreNetworkSecurityGroupSecurityRule, error) {
	var resource CoreNetworkSecurityGroupSecurityRule
	err := ctx.ReadResource("oci:index/coreNetworkSecurityGroupSecurityRule:CoreNetworkSecurityGroupSecurityRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CoreNetworkSecurityGroupSecurityRule resources.
type coreNetworkSecurityGroupSecurityRuleState struct {
	// An optional description of your choice for the rule. Avoid entering confidential information.
	Description *string `pulumi:"description"`
	// Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
	Destination *string `pulumi:"destination"`
	// Type of destination for the rule. Required if `direction` = `EGRESS`.
	DestinationType *string `pulumi:"destinationType"`
	// Direction of the security rule. Set to `EGRESS` for rules to allow outbound IP packets, or `INGRESS` for rules to allow inbound IP packets.
	Direction *string `pulumi:"direction"`
	// Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
	// * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
	// * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
	IcmpOptions *CoreNetworkSecurityGroupSecurityRuleIcmpOptions `pulumi:"icmpOptions"`
	// Whether the rule is valid. The value is `True` when the rule is first created. If the rule's `source` or `destination` is a network security group, the value changes to `False` if that network security group is deleted.
	IsValid *bool `pulumi:"isValid"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security group.
	NetworkSecurityGroupId *string `pulumi:"networkSecurityGroupId"`
	// The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
	Protocol *string `pulumi:"protocol"`
	// Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
	Source *string `pulumi:"source"`
	// Type of source for the rule. Required if `direction` = `INGRESS`.
	// * `CIDR_BLOCK`: If the rule's `source` is an IP address range in CIDR notation.
	// * `SERVICE_CIDR_BLOCK`: If the rule's `source` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic coming from a particular `Service` through a service gateway).
	// * `NETWORK_SECURITY_GROUP`: If the rule's `source` is the OCID of a [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
	SourceType *string `pulumi:"sourceType"`
	// A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if egress traffic allows TCP destination port 80, there should be an ingress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
	Stateless *bool `pulumi:"stateless"`
	// Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
	TcpOptions *CoreNetworkSecurityGroupSecurityRuleTcpOptions `pulumi:"tcpOptions"`
	// The date and time the security rule was created. Format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
	TimeCreated *string `pulumi:"timeCreated"`
	// Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
	UdpOptions *CoreNetworkSecurityGroupSecurityRuleUdpOptions `pulumi:"udpOptions"`
}

type CoreNetworkSecurityGroupSecurityRuleState struct {
	// An optional description of your choice for the rule. Avoid entering confidential information.
	Description pulumi.StringPtrInput
	// Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
	Destination pulumi.StringPtrInput
	// Type of destination for the rule. Required if `direction` = `EGRESS`.
	DestinationType pulumi.StringPtrInput
	// Direction of the security rule. Set to `EGRESS` for rules to allow outbound IP packets, or `INGRESS` for rules to allow inbound IP packets.
	Direction pulumi.StringPtrInput
	// Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
	// * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
	// * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
	IcmpOptions CoreNetworkSecurityGroupSecurityRuleIcmpOptionsPtrInput
	// Whether the rule is valid. The value is `True` when the rule is first created. If the rule's `source` or `destination` is a network security group, the value changes to `False` if that network security group is deleted.
	IsValid pulumi.BoolPtrInput
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security group.
	NetworkSecurityGroupId pulumi.StringPtrInput
	// The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
	Protocol pulumi.StringPtrInput
	// Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
	Source pulumi.StringPtrInput
	// Type of source for the rule. Required if `direction` = `INGRESS`.
	// * `CIDR_BLOCK`: If the rule's `source` is an IP address range in CIDR notation.
	// * `SERVICE_CIDR_BLOCK`: If the rule's `source` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic coming from a particular `Service` through a service gateway).
	// * `NETWORK_SECURITY_GROUP`: If the rule's `source` is the OCID of a [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
	SourceType pulumi.StringPtrInput
	// A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if egress traffic allows TCP destination port 80, there should be an ingress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
	Stateless pulumi.BoolPtrInput
	// Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
	TcpOptions CoreNetworkSecurityGroupSecurityRuleTcpOptionsPtrInput
	// The date and time the security rule was created. Format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
	TimeCreated pulumi.StringPtrInput
	// Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
	UdpOptions CoreNetworkSecurityGroupSecurityRuleUdpOptionsPtrInput
}

func (CoreNetworkSecurityGroupSecurityRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*coreNetworkSecurityGroupSecurityRuleState)(nil)).Elem()
}

type coreNetworkSecurityGroupSecurityRuleArgs struct {
	// An optional description of your choice for the rule. Avoid entering confidential information.
	Description *string `pulumi:"description"`
	// Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
	Destination *string `pulumi:"destination"`
	// Type of destination for the rule. Required if `direction` = `EGRESS`.
	DestinationType *string `pulumi:"destinationType"`
	// Direction of the security rule. Set to `EGRESS` for rules to allow outbound IP packets, or `INGRESS` for rules to allow inbound IP packets.
	Direction string `pulumi:"direction"`
	// Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
	// * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
	// * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
	IcmpOptions *CoreNetworkSecurityGroupSecurityRuleIcmpOptions `pulumi:"icmpOptions"`
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security group.
	NetworkSecurityGroupId string `pulumi:"networkSecurityGroupId"`
	// The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
	Protocol string `pulumi:"protocol"`
	// Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
	Source *string `pulumi:"source"`
	// Type of source for the rule. Required if `direction` = `INGRESS`.
	// * `CIDR_BLOCK`: If the rule's `source` is an IP address range in CIDR notation.
	// * `SERVICE_CIDR_BLOCK`: If the rule's `source` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic coming from a particular `Service` through a service gateway).
	// * `NETWORK_SECURITY_GROUP`: If the rule's `source` is the OCID of a [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
	SourceType *string `pulumi:"sourceType"`
	// A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if egress traffic allows TCP destination port 80, there should be an ingress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
	Stateless *bool `pulumi:"stateless"`
	// Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
	TcpOptions *CoreNetworkSecurityGroupSecurityRuleTcpOptions `pulumi:"tcpOptions"`
	// Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
	UdpOptions *CoreNetworkSecurityGroupSecurityRuleUdpOptions `pulumi:"udpOptions"`
}

// The set of arguments for constructing a CoreNetworkSecurityGroupSecurityRule resource.
type CoreNetworkSecurityGroupSecurityRuleArgs struct {
	// An optional description of your choice for the rule. Avoid entering confidential information.
	Description pulumi.StringPtrInput
	// Conceptually, this is the range of IP addresses that a packet originating from the instance can go to.
	Destination pulumi.StringPtrInput
	// Type of destination for the rule. Required if `direction` = `EGRESS`.
	DestinationType pulumi.StringPtrInput
	// Direction of the security rule. Set to `EGRESS` for rules to allow outbound IP packets, or `INGRESS` for rules to allow inbound IP packets.
	Direction pulumi.StringInput
	// Optional and valid only for ICMP and ICMPv6. Use to specify a particular ICMP type and code as defined in:
	// * [ICMP Parameters](http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml)
	// * [ICMPv6 Parameters](https://www.iana.org/assignments/icmpv6-parameters/icmpv6-parameters.xhtml)
	IcmpOptions CoreNetworkSecurityGroupSecurityRuleIcmpOptionsPtrInput
	// The [OCID](https://docs.cloud.oracle.com/iaas/Content/General/Concepts/identifiers.htm) of the network security group.
	NetworkSecurityGroupId pulumi.StringInput
	// The transport protocol. Specify either `all` or an IPv4 protocol number as defined in [Protocol Numbers](http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml). Options are supported only for ICMP ("1"), TCP ("6"), UDP ("17"), and ICMPv6 ("58").
	Protocol pulumi.StringInput
	// Conceptually, this is the range of IP addresses that a packet coming into the instance can come from.
	Source pulumi.StringPtrInput
	// Type of source for the rule. Required if `direction` = `INGRESS`.
	// * `CIDR_BLOCK`: If the rule's `source` is an IP address range in CIDR notation.
	// * `SERVICE_CIDR_BLOCK`: If the rule's `source` is the `cidrBlock` value for a [Service](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/Service/) (the rule is for traffic coming from a particular `Service` through a service gateway).
	// * `NETWORK_SECURITY_GROUP`: If the rule's `source` is the OCID of a [NetworkSecurityGroup](https://docs.cloud.oracle.com/iaas/api/#/en/iaas/latest/NetworkSecurityGroup/).
	SourceType pulumi.StringPtrInput
	// A stateless rule allows traffic in one direction. Remember to add a corresponding stateless rule in the other direction if you need to support bidirectional traffic. For example, if egress traffic allows TCP destination port 80, there should be an ingress rule to allow TCP source port 80. Defaults to false, which means the rule is stateful and a corresponding rule is not necessary for bidirectional traffic.
	Stateless pulumi.BoolPtrInput
	// Optional and valid only for TCP. Use to specify particular destination ports for TCP rules. If you specify TCP as the protocol but omit this object, then all destination ports are allowed.
	TcpOptions CoreNetworkSecurityGroupSecurityRuleTcpOptionsPtrInput
	// Optional and valid only for UDP. Use to specify particular destination ports for UDP rules. If you specify UDP as the protocol but omit this object, then all destination ports are allowed.
	UdpOptions CoreNetworkSecurityGroupSecurityRuleUdpOptionsPtrInput
}

func (CoreNetworkSecurityGroupSecurityRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*coreNetworkSecurityGroupSecurityRuleArgs)(nil)).Elem()
}

type CoreNetworkSecurityGroupSecurityRuleInput interface {
	pulumi.Input

	ToCoreNetworkSecurityGroupSecurityRuleOutput() CoreNetworkSecurityGroupSecurityRuleOutput
	ToCoreNetworkSecurityGroupSecurityRuleOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRuleOutput
}

func (*CoreNetworkSecurityGroupSecurityRule) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreNetworkSecurityGroupSecurityRule)(nil))
}

func (i *CoreNetworkSecurityGroupSecurityRule) ToCoreNetworkSecurityGroupSecurityRuleOutput() CoreNetworkSecurityGroupSecurityRuleOutput {
	return i.ToCoreNetworkSecurityGroupSecurityRuleOutputWithContext(context.Background())
}

func (i *CoreNetworkSecurityGroupSecurityRule) ToCoreNetworkSecurityGroupSecurityRuleOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreNetworkSecurityGroupSecurityRuleOutput)
}

func (i *CoreNetworkSecurityGroupSecurityRule) ToCoreNetworkSecurityGroupSecurityRulePtrOutput() CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return i.ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(context.Background())
}

func (i *CoreNetworkSecurityGroupSecurityRule) ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreNetworkSecurityGroupSecurityRulePtrOutput)
}

type CoreNetworkSecurityGroupSecurityRulePtrInput interface {
	pulumi.Input

	ToCoreNetworkSecurityGroupSecurityRulePtrOutput() CoreNetworkSecurityGroupSecurityRulePtrOutput
	ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRulePtrOutput
}

type coreNetworkSecurityGroupSecurityRulePtrType CoreNetworkSecurityGroupSecurityRuleArgs

func (*coreNetworkSecurityGroupSecurityRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreNetworkSecurityGroupSecurityRule)(nil))
}

func (i *coreNetworkSecurityGroupSecurityRulePtrType) ToCoreNetworkSecurityGroupSecurityRulePtrOutput() CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return i.ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(context.Background())
}

func (i *coreNetworkSecurityGroupSecurityRulePtrType) ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreNetworkSecurityGroupSecurityRulePtrOutput)
}

// CoreNetworkSecurityGroupSecurityRuleArrayInput is an input type that accepts CoreNetworkSecurityGroupSecurityRuleArray and CoreNetworkSecurityGroupSecurityRuleArrayOutput values.
// You can construct a concrete instance of `CoreNetworkSecurityGroupSecurityRuleArrayInput` via:
//
//          CoreNetworkSecurityGroupSecurityRuleArray{ CoreNetworkSecurityGroupSecurityRuleArgs{...} }
type CoreNetworkSecurityGroupSecurityRuleArrayInput interface {
	pulumi.Input

	ToCoreNetworkSecurityGroupSecurityRuleArrayOutput() CoreNetworkSecurityGroupSecurityRuleArrayOutput
	ToCoreNetworkSecurityGroupSecurityRuleArrayOutputWithContext(context.Context) CoreNetworkSecurityGroupSecurityRuleArrayOutput
}

type CoreNetworkSecurityGroupSecurityRuleArray []CoreNetworkSecurityGroupSecurityRuleInput

func (CoreNetworkSecurityGroupSecurityRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CoreNetworkSecurityGroupSecurityRule)(nil)).Elem()
}

func (i CoreNetworkSecurityGroupSecurityRuleArray) ToCoreNetworkSecurityGroupSecurityRuleArrayOutput() CoreNetworkSecurityGroupSecurityRuleArrayOutput {
	return i.ToCoreNetworkSecurityGroupSecurityRuleArrayOutputWithContext(context.Background())
}

func (i CoreNetworkSecurityGroupSecurityRuleArray) ToCoreNetworkSecurityGroupSecurityRuleArrayOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreNetworkSecurityGroupSecurityRuleArrayOutput)
}

// CoreNetworkSecurityGroupSecurityRuleMapInput is an input type that accepts CoreNetworkSecurityGroupSecurityRuleMap and CoreNetworkSecurityGroupSecurityRuleMapOutput values.
// You can construct a concrete instance of `CoreNetworkSecurityGroupSecurityRuleMapInput` via:
//
//          CoreNetworkSecurityGroupSecurityRuleMap{ "key": CoreNetworkSecurityGroupSecurityRuleArgs{...} }
type CoreNetworkSecurityGroupSecurityRuleMapInput interface {
	pulumi.Input

	ToCoreNetworkSecurityGroupSecurityRuleMapOutput() CoreNetworkSecurityGroupSecurityRuleMapOutput
	ToCoreNetworkSecurityGroupSecurityRuleMapOutputWithContext(context.Context) CoreNetworkSecurityGroupSecurityRuleMapOutput
}

type CoreNetworkSecurityGroupSecurityRuleMap map[string]CoreNetworkSecurityGroupSecurityRuleInput

func (CoreNetworkSecurityGroupSecurityRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CoreNetworkSecurityGroupSecurityRule)(nil)).Elem()
}

func (i CoreNetworkSecurityGroupSecurityRuleMap) ToCoreNetworkSecurityGroupSecurityRuleMapOutput() CoreNetworkSecurityGroupSecurityRuleMapOutput {
	return i.ToCoreNetworkSecurityGroupSecurityRuleMapOutputWithContext(context.Background())
}

func (i CoreNetworkSecurityGroupSecurityRuleMap) ToCoreNetworkSecurityGroupSecurityRuleMapOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CoreNetworkSecurityGroupSecurityRuleMapOutput)
}

type CoreNetworkSecurityGroupSecurityRuleOutput struct {
	*pulumi.OutputState
}

func (CoreNetworkSecurityGroupSecurityRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CoreNetworkSecurityGroupSecurityRule)(nil))
}

func (o CoreNetworkSecurityGroupSecurityRuleOutput) ToCoreNetworkSecurityGroupSecurityRuleOutput() CoreNetworkSecurityGroupSecurityRuleOutput {
	return o
}

func (o CoreNetworkSecurityGroupSecurityRuleOutput) ToCoreNetworkSecurityGroupSecurityRuleOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRuleOutput {
	return o
}

func (o CoreNetworkSecurityGroupSecurityRuleOutput) ToCoreNetworkSecurityGroupSecurityRulePtrOutput() CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return o.ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(context.Background())
}

func (o CoreNetworkSecurityGroupSecurityRuleOutput) ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return o.ApplyT(func(v CoreNetworkSecurityGroupSecurityRule) *CoreNetworkSecurityGroupSecurityRule {
		return &v
	}).(CoreNetworkSecurityGroupSecurityRulePtrOutput)
}

type CoreNetworkSecurityGroupSecurityRulePtrOutput struct {
	*pulumi.OutputState
}

func (CoreNetworkSecurityGroupSecurityRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CoreNetworkSecurityGroupSecurityRule)(nil))
}

func (o CoreNetworkSecurityGroupSecurityRulePtrOutput) ToCoreNetworkSecurityGroupSecurityRulePtrOutput() CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return o
}

func (o CoreNetworkSecurityGroupSecurityRulePtrOutput) ToCoreNetworkSecurityGroupSecurityRulePtrOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRulePtrOutput {
	return o
}

type CoreNetworkSecurityGroupSecurityRuleArrayOutput struct{ *pulumi.OutputState }

func (CoreNetworkSecurityGroupSecurityRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CoreNetworkSecurityGroupSecurityRule)(nil))
}

func (o CoreNetworkSecurityGroupSecurityRuleArrayOutput) ToCoreNetworkSecurityGroupSecurityRuleArrayOutput() CoreNetworkSecurityGroupSecurityRuleArrayOutput {
	return o
}

func (o CoreNetworkSecurityGroupSecurityRuleArrayOutput) ToCoreNetworkSecurityGroupSecurityRuleArrayOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRuleArrayOutput {
	return o
}

func (o CoreNetworkSecurityGroupSecurityRuleArrayOutput) Index(i pulumi.IntInput) CoreNetworkSecurityGroupSecurityRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CoreNetworkSecurityGroupSecurityRule {
		return vs[0].([]CoreNetworkSecurityGroupSecurityRule)[vs[1].(int)]
	}).(CoreNetworkSecurityGroupSecurityRuleOutput)
}

type CoreNetworkSecurityGroupSecurityRuleMapOutput struct{ *pulumi.OutputState }

func (CoreNetworkSecurityGroupSecurityRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]CoreNetworkSecurityGroupSecurityRule)(nil))
}

func (o CoreNetworkSecurityGroupSecurityRuleMapOutput) ToCoreNetworkSecurityGroupSecurityRuleMapOutput() CoreNetworkSecurityGroupSecurityRuleMapOutput {
	return o
}

func (o CoreNetworkSecurityGroupSecurityRuleMapOutput) ToCoreNetworkSecurityGroupSecurityRuleMapOutputWithContext(ctx context.Context) CoreNetworkSecurityGroupSecurityRuleMapOutput {
	return o
}

func (o CoreNetworkSecurityGroupSecurityRuleMapOutput) MapIndex(k pulumi.StringInput) CoreNetworkSecurityGroupSecurityRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) CoreNetworkSecurityGroupSecurityRule {
		return vs[0].(map[string]CoreNetworkSecurityGroupSecurityRule)[vs[1].(string)]
	}).(CoreNetworkSecurityGroupSecurityRuleOutput)
}

func init() {
	pulumi.RegisterOutputType(CoreNetworkSecurityGroupSecurityRuleOutput{})
	pulumi.RegisterOutputType(CoreNetworkSecurityGroupSecurityRulePtrOutput{})
	pulumi.RegisterOutputType(CoreNetworkSecurityGroupSecurityRuleArrayOutput{})
	pulumi.RegisterOutputType(CoreNetworkSecurityGroupSecurityRuleMapOutput{})
}
