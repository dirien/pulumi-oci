// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Oci
{
    public static class GetDatacatalogCatalogType
    {
        /// <summary>
        /// This data source provides details about a specific Catalog Type resource in Oracle Cloud Infrastructure Data Catalog service.
        /// 
        /// Gets a specific type by key within a data catalog.
        /// 
        /// {{% examples %}}
        /// ## Example Usage
        /// {{% example %}}
        /// 
        /// ```csharp
        /// using Pulumi;
        /// using Oci = Pulumi.Oci;
        /// 
        /// class MyStack : Stack
        /// {
        ///     public MyStack()
        ///     {
        ///         var testCatalogType = Output.Create(Oci.GetDatacatalogCatalogType.InvokeAsync(new Oci.GetDatacatalogCatalogTypeArgs
        ///         {
        ///             CatalogId = oci_datacatalog_catalog.Test_catalog.Id,
        ///             TypeKey = @var.Catalog_type_type_key,
        ///             Fields = @var.Catalog_type_fields,
        ///         }));
        ///     }
        /// 
        /// }
        /// ```
        /// {{% /example %}}
        /// {{% /examples %}}
        /// </summary>
        public static Task<GetDatacatalogCatalogTypeResult> InvokeAsync(GetDatacatalogCatalogTypeArgs args, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.InvokeAsync<GetDatacatalogCatalogTypeResult>("oci:index/getDatacatalogCatalogType:GetDatacatalogCatalogType", args ?? new GetDatacatalogCatalogTypeArgs(), options.WithVersion());
    }


    public sealed class GetDatacatalogCatalogTypeArgs : Pulumi.InvokeArgs
    {
        /// <summary>
        /// Unique catalog identifier.
        /// </summary>
        [Input("catalogId", required: true)]
        public string CatalogId { get; set; } = null!;

        [Input("fields")]
        private List<string>? _fields;

        /// <summary>
        /// Specifies the fields to return in a type response.
        /// </summary>
        public List<string> Fields
        {
            get => _fields ?? (_fields = new List<string>());
            set => _fields = value;
        }

        /// <summary>
        /// Unique type key.
        /// </summary>
        [Input("typeKey", required: true)]
        public string TypeKey { get; set; } = null!;

        public GetDatacatalogCatalogTypeArgs()
        {
        }
    }


    [OutputType]
    public sealed class GetDatacatalogCatalogTypeResult
    {
        /// <summary>
        /// The data catalog's OCID.
        /// </summary>
        public readonly string CatalogId;
        /// <summary>
        /// Detailed description of the type.
        /// </summary>
        public readonly string Description;
        /// <summary>
        /// Mapping type equivalence in the external system.
        /// </summary>
        public readonly string ExternalTypeName;
        public readonly ImmutableArray<string> Fields;
        /// <summary>
        /// The provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;
        /// <summary>
        /// Indicates whether the type is approved for use as a classifying object.
        /// </summary>
        public readonly bool IsApproved;
        /// <summary>
        /// Indicates whether the type is internal, making it unavailable for use by metadata elements.
        /// </summary>
        public readonly bool IsInternal;
        /// <summary>
        /// Indicates whether the type can be used for tagging metadata elements.
        /// </summary>
        public readonly bool IsTag;
        /// <summary>
        /// Unique type key that is immutable.
        /// </summary>
        public readonly string Key;
        /// <summary>
        /// The immutable name of the type.
        /// </summary>
        public readonly string Name;
        /// <summary>
        /// A map of arrays which defines the type specific properties, both required and optional. The map keys are category names and the values are arrays contiaing all property details. Every property is contained inside of a category. Most types have required properties within the "default" category. Example: `{ "properties": { "default": { "attributes:": [ { "name": "host", "type": "string", "isRequired": true, "isUpdatable": false }, ... ] } } }`
        /// </summary>
        public readonly ImmutableDictionary<string, object> Properties;
        /// <summary>
        /// The current state of the type.
        /// </summary>
        public readonly string State;
        /// <summary>
        /// Indicates the category this type belongs to. For instance, data assets, connections.
        /// </summary>
        public readonly string TypeCategory;
        public readonly string TypeKey;
        /// <summary>
        /// URI to the type instance in the API.
        /// </summary>
        public readonly string Uri;

        [OutputConstructor]
        private GetDatacatalogCatalogTypeResult(
            string catalogId,

            string description,

            string externalTypeName,

            ImmutableArray<string> fields,

            string id,

            bool isApproved,

            bool isInternal,

            bool isTag,

            string key,

            string name,

            ImmutableDictionary<string, object> properties,

            string state,

            string typeCategory,

            string typeKey,

            string uri)
        {
            CatalogId = catalogId;
            Description = description;
            ExternalTypeName = externalTypeName;
            Fields = fields;
            Id = id;
            IsApproved = isApproved;
            IsInternal = isInternal;
            IsTag = isTag;
            Key = key;
            Name = name;
            Properties = properties;
            State = state;
            TypeCategory = typeCategory;
            TypeKey = typeKey;
            Uri = uri;
        }
    }
}
